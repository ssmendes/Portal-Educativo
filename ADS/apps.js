! função (e) {var t = {}; função n (r) {if (t [r]) retornar t [r]. exportações; var i = t [r] = {i: r, l:! 1 , exportações: {}}; retornar e [r] .call (i.exportações, i, i.exportações, n), il =! 0, i.exportações} nm = e, nc = t, nd = função (e , t, r) {no (e, t) || Object.defineProperty (e, t, {enumerable:! 0, get: r})}, nr = function (e) {"undefined"! = typeof Symbol && Symbol. toStringTag && Object.defineProperty (e, Symbol.toStringTag, {value: "Module"}), Object.defineProperty (e, "__ esModule", {value:! 0})}, nt = function (e, t) {if (1 & t && (e = n (e)), 8 & t) return e; if (4 & t && "objeto" == typeof e && e && e .__ esModule) return e; var r = Object.create (null); if (nr (r), Object.defineProperty (r, "default", {enumerable:! 0, value: e}), 2 & t && "string"! = typeof e) for (var i in e) nd (r, i, function (t) {return e [t ]}. bind (null, i)); return r}, n.n = function (e) {var t = e && e .__ esModule? function () {return e.default}: function () {return e}; return nd (t, "a", t), t}, no = function (e, t) {return Object.prototype.hasOwnProperty.call (e, t)}, np = "/", n (ns = 11)} ([function (e, t, n) {"use strict"; var r = n (5), i = n (19), o = Object.prototype.toString; função a (e) {return "[array de objeto]" === o.call (e)} função s (e ) {return null! == e && "object" == typeof e} função u (e) {return "[object Function]" === o.call (e)} função c (e, t) {if (null ! = e) if ("objeto"! = tipo de e && (e = [e]), a (e)) para (var n = 0, r = e.length; n <r; n ++) t.call (nulo , e [n], n, e); else for (var i in e) Object.prototype.hasOwnProperty.call (e, i) && t.call (null, e [i], i, e)} e.exports = {isArray: a, isArrayBuffer: function (e) {return "[object ArrayBuffer]" === o.call (e)}, isBuffer: i, isFormData:function (e) {return "undefined"! = typeof FormData && e instanceof FormData}, isArrayBufferView: function (e) {return "undefined"! = typeof ArrayBuffer && ArrayBuffer.isView? ArrayBuffer.isView (e): e && e.buffer instanceof && e.buffer instância} , isString: function (e) {return "string" == typeof e}, isNumber: function (e) {return "number" == typeof e}, isObject: s, isUndefined: function (e) {return void 0 = == e}, isDate: function (e) {return "[object Date]" === o.call (e)}, isFile: function (e) {return "[object File]" === o.call (e)}, isBlob: function (e) {return "[object Blob]" === o.call (e)}, isFunction: u, isStream: function (e) {return s (e) && u (e. pipe)}, isURLSearchParams: function (e) {return "undefined"! = typeof URLSearchParams && e instanceof URLSearchParams}, isStandardBrowserEnv:function () {return ("undefined" == typeof navigator || "ReactNative"! == navigator.product) && "undefined"! = typeof window && "undefined"! = typeof document}, forEach: c, merge: function e () {var t = {}; função n (n, r) {"objeto" == tipo de t [r] && "objeto" == tipo de n? t [r] = e (t [r], n) : t [r] = n} para (var r = 0, i = argumentos.comprimento; r <i; r ++) c (argumentos [r], n); retornar t}, extender: função (e, t, n ) {return c (t, function (t, i) {e [i] = n && "function" == typeof t? r (t, n): t}), e}, trim: function (e) {return e.replace (/ ^ \ s * /, ""). replace (/ \ s * $ /, "")}}}, function (e, t) {var n; n = function () {return this} (); tente {n = n || new Function ("return this") ()} catch (e) {"object" == typeof window && (n = window)} e.exports = n}, function (e, t, n) {"usar estrito"; (função (t) {var r = n (0), i = n (21),o = {"Content-Type": "application / x-www-form-urlencoded"}; função a (e, t) {! r.isUndefined (e) && r.isUndefined (e ["Content-Type"]) && (e ["Content-Type"] = t)} var s, u = {adapter :( "undefined"! = typeof XMLHttpRequest? s = n (7): void 0! == t && (s = n (7 )), s), transformRequest: [function (e, t) {return i (t, "Content-Type"), r.isFormData (e) || r.isArrayBuffer (e) || r.isBuffer (e) || r.isStream (e) || r.isFile (e) || r.isBlob (e)? e: r.isArrayBufferView (e)? e.buffer: r.isURLSearchParams (e)? (a (t, "application / x-www-form-urlencoded; charset = utf-8"), e.toString ()): r.isObject (e)? (a (t, "application / json; charset = utf-8") , JSON.stringify (e)): e}], transformResponse: [function (e) {if ("string" == typeof e) try {e = JSON.parse (e)} catch (e) {} return e }], tempo limite: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName:"X-XSRF-TOKEN", maxContentLength: -1, validateStatus: function (e) {return e> = 200 && e <300}}; u.headers = {common: {Accept: "application / json, text / plain, * /*"}},r.forEach(["delete","get","head"],function(e){u.headers[e]={}}),r.forEach(["post ", "colocar", "patch"], função (e) {u.headers [e] = r.merge (o)}), e.exports = u}). call (this, n (6))}, função (e, t, n) {"usar estrito"; nr (t), função (e) {para (var n = "indefinido"! = tipo de janela && "indefinido"! = tipo de documento, r = ["Borda", "Trident", "Firefox"], i = 0, o = 0; o <r.length; o + = 1) if (n && navigator.userAgent.indexOf (r [o])> = 0) {i = 1; quebrar } var a = n && window.Promise? function (e) {var t =! 1; return function () {t || (t =! 0, window.Promise.resolve (). then (function () {t =! 1, e ()}))}}:function (e) {var t =! 1; return function () {t || (t =! 0, setTimeout (function () {t =! 1, e ()}, i))}}; função s ( e) {return e && "[object Function]" === {}. toString.call (e)} função u (e, t) {if (1! == e.nodeType) return []; var n = e .ownerDocument.defaultView.getComputedStyle (e, null); return t? n [t]: n} função c (e) {return "HTML" === e.nodeName? e: e.parentNode || e.host} função l (e) {if (! e) return document.body; switch (e.nodeName) {case "HTML": case "BODY": return e.ownerDocument.body; case "#document": return e.body } var t = u (e), n = t.overflow, r = t.overflowX, i = t.overflowY; return / (auto | scroll | overlay) /. test (n + i + r)? e: l (c (e))} var f = n &&! (! window.MSInputMethodContext ||! document.documentMode), p = n && / MSIE 10 / .test (navigator.userAgent); função d (e) {return 11 == = e? f: 10 === e? p: f || p} função h (e) {if (! e) return document.documentElement;for (var t = d (10)? document.body: null, n = e.offsetParent || null; n === t && e.nextElementSibling;) n = (e = e.nextElementSibling) .offsetParent; var r = n && n .nodeName; return r && "BODY"! == r && "HTML"! == r? -1! == ["TH", "TD", "TABLE"]. indexOf (n.nodeName) && "static" = == u (n, "posição")? h (n): n: e? e.ownerDocument.documentElement: document.documentElement} função v (e) {return null! == e.parentNode? v (e.parentNode ): e} função g (e, t) {if (! (e && e.nodeType && t && t.nodeType)) return document.documentElement; var n = e.compareDocumentPosition (t) & Node.DOCUMENT_POSITION_FOLLOWING, r = n? e: t, i = n? t: e, o = document.createRange (); o.setStart (r, 0), o.setEnd (i, 0); var a, s, u = o.commonAncestorContainer; if (e! == u && t! == u || r.contains (i)) return "BODY" === (s = (a = u).nodeName) || "HTML"! == s && h (a.firstElementChild)! == a? h (u): u; var c = v (e); return c.host?g(c.host,t): g (e, v (t) .host)} função m (e) {var t = "top" === (argumentos.length> 1 && void 0! == argumentos [1]? argumentos [1]: "topo" )? "scrollTop": "scrollLeft", n = e.nodeName; if ("BODY" === n || "HTML" === n) {var r = e.ownerDocument.documentElement; return (e.ownerDocument .scrollingElement || r) [t]} return e [t]} função y (e, t) {var n = "x" === t? "Left": "Top", r = "Left" == = n? "Direita": "Inferior"; retornar parseFloat (e ["borda" + n + "Largura"], 10) + parseFloat (e ["borda" + r + "Largura"], 10)} função _ (e , t, n, r) {return Math.max (t ["deslocamento" + e], t ["rolar" + e], n ["cliente" + e], n ["deslocamento" + e], n ["rolagem"+ e], d (10)? parseInt (n ["offset" + e]) + parseInt (r ["margin" + ("Height" === e? "Top": "Left")]) + parseInt (r ["margin" + ("Height" === e? "Bottom": "Right")]): 0)} função b (e) {var t = e.body, n = e.documentElement, r = d (10) && getComputedStyle (n); retornar {altura: _ ("Altura", t, n, r), largura: _ ("Largura", t, n, r)}} var w = função (e, t) {if (! (e instanceof t)) throw new TypeError ("Não é possível chamar uma classe como uma função")}, T = function () {function e (e, t) {for (var n = 0; n <t.length; n ++) {var r = t [n]; r.enumerable = r.enumerable ||! 1, r.configurable =! 0, "valor" em r && (r.writable =! 0), Objeto .defineProperty (e, r.key, r)}} função de retorno (t, n, r) {return n && e (t.protótipo, n), r && e (t, r), t}} (), E = função ( e, t, n) {retornar t em e? Object.defineProperty (e, t, {valor: n, enumerável:! 0, configurável:! 0, gravável:! 0}): e [t] = n, e}, x = Object.assign || function (e) {for (var t = 1; t <arguments.length; t ++) {var n = argumentos [t]; para (var r em n) Object.prototype.hasOwnProperty.call (n, r) && (e [r] = n [r])} retorno e}; função C ( e) {return x ({}, e, {right: e.left + e.width, bottom: e.top + e.height})} função A (e) {var t = {}; tente {if ( d (10)) {t = e.getBoundingClientRect (); var n = m (e, "topo"), r = m (e, "esquerda"); t.top + = n, t.esquerdo + = r, t .bottom + = n, t.right + = r} else t = e.getBoundingClientRect ()} catch (e) {} var i = {left: t.left, top: t.top, width: t.right-t. esquerda, altura: t.bottom-t.top}, o = "HTML" === e.nodeName? b (e.ownerDocument): {}, a = o.width || e.clientWidth || i.right -i.left, s = o.height || e.clientHeight || i.bottom-i.top, c = e.offsetWidth-a, l = e.offsetHeight-s; if (c || l) {var f = u (e); c- = y (f, "x"), l- = y (f, "y"), i.width- = c, i.height- = l} return C (i) } função S (e,t) {var n = argumentos.comprimento> 2 && void 0! == argumentos [2] && argumentos [2], r = d (10), i = "HTML" === t.Nome do nó, o = A (e), a = A (t), s = l (e), c = u (t), f = parseFloat (c.borderTopWidth, 10), p = parseFloat (c.borderLeftWidth, 10); n && i && (a.top = Math .max (a.top, 0), a.left = Math.max (a.left, 0)); var h = C ({top: o.top-a.top-f, left: o.left- a.left-p, width: o.width, height: o.height}); if (h.marginTop = 0, h.marginLeft = 0,! r && i) {var v = parseFloat (c.marginTop, 10), g = parseFloat (c.marginLeft, 10); h.top- = fv, h.bottom- = fv, h.esquerdo- = pg, h.right- = pg, h.marginTop = v, h.marginLeft = g } return (r &&! n? t.contains (s): t === s && "BODY"! == s.nodeName) && (h = function (e, t) {var n = arguments.length> 2 && void 0! == argumentos [2] && argumentos [2], r = m (t, "topo"), i = m (t, "esquerda"), o = n? -1: 1; retornar e.top + = r * o , e.bottom + = r * o, e.esquerdo + = i * o, e.direita + = i * o, e} (h, t)), h} função O (e) {if (! e ||! e.parentElement || d ()) retornar document.documentElement; for (var t = e .parentElement; t && "nenhum" === u (t, "transformar");) t = t.parentElement; retornar t || document.documentElement} função D (e, t, n, r) {var i = argumentos .length> 4 && void 0! == argumentos [4] && argumentos [4], o = {topo: 0, esquerda: 0}, a = i? O (e): g (e, t); if ("janela de visualização" === r) o = função (e) {var t = argumentos.length> 1 && void 0! == argumentos [1] && argumentos [1], n = e.ownerDocument.documentElement, r = S (e, n), i = Math.max (n.clientWidth, window.innerWidth || 0), o = Math.max (n.clientHeight, window.innerHeight || 0), a = t? 0: m (n), s = t ? 0: m (n, "left"); return C ({top: ar.top + r.marginTop, left: sr.left + r.marginLeft, width: i, height: o})} (a, i ); else {var s = void 0; "scrollParent" === r? "BODY" === (s = l (c (t))). nodeName && (s = e.ownerDocument.documentElement): s = "window" === r? e.ownerDocument.documentElement: r; var f = S (s, a, i); if ("HTML"! == s.nodeName || function e (t) {var n = t.nodeName; return "BODY"! == n && "HTML"! == n && ("fixed" === u (t, "position") || e (c (t)) )} (a)) o = f; else {var p = b (e.ownerDocument), d = p.altura, h = p.width; o.top + = f.top-f.marginTop, o.bottom = d + f.top, o.left + = f.left-f.marginLeft, o.right = h + f.left}} var v = "número" == typeof (n = n || 0); retornar o. esquerda + = v? n: n.esquerdo || 0, o.top + = v? n: n.top || 0, o.direito- = v? n: n.direito || 0, o.bottom- = v ? n: n.bottom || 0, o} função I (e, t, n, r, i) {var o = argumentos.comprimento> 5 && void 0! == argumentos [5]? argumentos [5]: 0; if (-1 === e.indexOf ("auto")) retorna e; var a = D (n, r, o, i), s = {topo: {largura: a.width, altura: t.top -a.top}, direita: {largura: a.right-t.right, height: a.height}, bottom: {width: a.width, height: a.bottom-t.bottom}, left: {width: t.left-a.left, height: a.height}}, u = Object.keys (s) .map (function (e) {return x ({key: e}, s [e], {área: (t = s [e], t.width * t.height)}); var t}). sort (function (e, t) {return t.area-e .area}), c = u.filter (function (e) {var t = e.width, r = e.height; return t> = n.clientWidth && r> = n.clientHeight}), l = c.length> 0? C [0] .key: u [0] .key, f = e.split ("-") [1]; return l + (f? "-" + f: "")} função k (e, t, n) {var r = argumentos.comprimento> 3 && vazio 0! == argumentos [3]? argumentos [3]: nulo; retornar S (n, r? O (t): g (t, n), r) } função N (e) {var t = e.ownerDocument.defaultView.getComputedStyle (e), n = parseFloat (t.marginTop || 0) + parseFloat (t.marginBottom || 0), r = parseFloat (t.marginLeft || 0) + parseFloat (t.marginRight || 0); retornar {largura: e.offsetWidth + r, altura: e.offsetHeight + n}} função L (e) {var t = {esquerda: "direita", direita: "esquerda", inferior: "top ", top:" bottom "}; return e.replace (/ left | right | bottom | top / g, function (e) {return t [e]})} função j (e, t, n) {n = n.split ("-") [0]; var r = N (e), i = {largura: r.width, height: r.height}, o = -1! == ["right", " left "]. indexOf (n), a = o?" top ":" left ", s = o?" left ":" top ", u = o?" height ":" width ", c = o?" largura ":" altura "; retornar i [a] = t [a] + t [u] / 2-r [u] / 2, i [s] = n === s? t [s] -r [ c]: t [L (s)], i} função P (e, t) {return Array.prototype.find? e.find (t): e.filter (t) [0]} função R (e, t, n) {return (void 0 === n? e: e.slice (0, function (e, t, n) {if (Array.prototype.findIndex) return e.findIndex (function (e) {return e [t] === n}); var r = P (e, função (e) {retornar e [t] === n}); retornar e.indexOf (r)} (e, "nome", n))). forEach (function (e) {e.function && console.warn ("` modifier.function` está obsoleto,use `modifier.fn`!"); var n = e.function || e.fn; e.enabled && s (n) && (t.offsets.popper = C (t.offsets.popper), t.offsets.reference = C (t.offsets.reference), t = n (t, e))}), t} função $ (e, t) {return e.some (function (e) {var n = e.name; return e.enabled && n === t})} função H (e) {for (var t = [! 1, "ms", "Webkit", "Moz", "O"], n = e.charAt (0) .toUpperCase () + e.slice (1), r = 0; r <t.length; r ++) {var i = t [r], o = i? "" + i + n: e; se (vazio 0 ! == document.body.style [o]) return o} return null} função M (e) {var t = e.ownerDocument; return t? t.defaultView: window} função F (e, t, n, r ) {n.updateBound = r, M (e) .addEventListener ("resize", n.updateBound, {passive:! 0}); var i = l (e); função de retorno e (t, n, r, i ) {var o = "BODY" === t.nodeName, a = o? t.ownerDocument.defaultView: t; a.addEventListener (n, r, {passive:! 0}), o || e (l ( a.parentNode), n, r, i), i.push (a)} (i, "rolar", n.updateBound, n.scrollParents), n.scrollElement = i, n.eventsEnabled =! 0, n} função W () {var e, t; this.state. eventsEnabled && (cancelAnimationFrame (this.scheduleUpdate), this.state = (e = this.reference, t = this.state, M (e) .removeEventListener ("resize", t.updateBound), t.scrollParents.forEach (function ( e) função {e.removeEventListener ("scroll", t.updateBound)}), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled =! 1, t))} q (e) {return ""! == e &&! isNaN (parseFloat (e)) && isFinite (e)} função B (e, t) {Object.keys (t) .forEach (function (n) {var r = " "; -1! == [" largura "," altura "," superior "," direita "," inferior "," esquerda "]. IndexOf (n) && q (t [n]) && (r =" px "), e.style [n] = t [n] + r})} var U = n && / Firefox / i.test (navigator.userAgent); função V (e, t, n) {var r = P (e, função (e) {return e.name === t}), i = !! r && e.some (function ( e) {return e.name === n && e.enabled && e.order <r.order}); if (! i) {var o = "` "+ t +" `", a = "` "+ n +" `" ; console.warn (um modificador + "é exigido pelo modificador" + o + "para funcionar, certifique-se de incluí-lo antes de" + o + "!")} return i} var z = ["auto-start", "auto "," fim automático "," início superior "," superior "," extremidade superior "," início à direita "," direita "," extremidade direita "," extremidade inferior "," inferior ", "início inferior", "extremidade esquerda", "esquerda", "início esquerdo"], K = z.slice (3); função G (e) {var t = argumentos.length> 1 && void 0! == argumentos [1] && argumentos [1], n = K.indexOf (e), r = K.slice (n + 1) .concat (K.slice (0, n)); retornar t? r.reverse (): r} var X = {FLIP: "flip", HORÁRIO: "sentido horário", ANTI-HORÁRIO: "sentido anti-horário "}; função Q (e, t, n, r) {var i = [0,0], o = -1! == [" direita "," esquerda "]. indexOf (r), a = e. split (/ (\ + | \ -) ​​/). map (function (e) {return e.trim ()}), s = a.indexOf (P (a, function (e) {return-1! == e.search (/, | \ s /)})); a [s] && - 1 === a [s] .indexOf (",") && console.warn ("Os deslocamentos separados por espaços em branco são obsoleto, use uma vírgula (,) no lugar. "); var u = / \ s *, \ s * | \ s + /, c = -1! == s? [a.slice (0, s) .concat ( [a [s] .split (u) [0]]), [a [s] .split (u) [1]]. concat (a.slice (s + 1))]: [a]; return ( c = c.map (function (e, r) {var i = (1 === r?! o: o)? "height": "width", a =! 1; return e.reduce (function (e , t) {return "" === e [e.length-1] && - 1! == ["+", "-"]. indexOf (t)? (e [e.comprimento-1] = t, a =! 0, e): a? (e [e.length-1] + = t, a =! 1, e): e.concat (t)}, []). map (function (e) {return function (e, t, n, r) {var i = e.match (/ ((?: \ - | \ +)? \ d * \.? \ d *) (. *) /), o = + i [1], a = i [2]; if (! o) retornar e; if (0 === a.indexOf ("%")) {var s = void 0; switch (a) {case "% p": s = n; break; case "%": case "% r": default: s = r} return C (s) [t] / 100 * o} if (" vh "=== a ||" vw "=== a) return (" vh "=== a? Math.max (document.documentElement.clientHeight, window.innerHeight || 0): Math.max (document. documentElement.clientWidth, window.innerWidth || 0)) / 100 * o; return o} (e, i, t, n)})})). forEach (function (e, t) {e.forEach (function ( n, r) {q (n) && (i [t] + = n * ("-" === e [r-1]? - 1: 1))})}), i} var Y = { posicionamento: "bottom", positionFixed:! 1, eventsEnabled:! 0, removeOnDestroy:! 1, onCreate: function () {}, onUpdate: function () {}, modificadores: {shift: {order: 100, enabled :! 0, fn:função (e) {var t = e.colocação, n = t.split ("-") [0], r = t.split ("-") [1]; se (r) {var i = e. offsets, o = i.reference, a = i.popper, s = -1! == ["bottom", "top"]. indexOf (n), u = s? "left": "top", c = s? "largura": "altura", l = {início: E ({}, u, o [u]), fim: E ({}, u, o [u] + o [c] -a [c ])}; e.offsets.popper = x ({}, a, l [r])} retornar e}}, deslocamento: {pedido: 200, ativado:! 0, fn: função (e, t) {var n = t.offset, r = e.placement, i = e.offsets, o = i.popper, a = i.reference, s = r.split ("-") [0], u = void 0; retornar u = q (+ n)? [+ n, 0]: Q (n, o, a, s), "esquerda" === s? (o.top + = u [0], o.esquerdo- = u [1]): "direita" === s? (O.top + = u [0], o.esquerdo + = u [1]): "superior" === s? (O.esquerda + = u [0] , o.top- = u [1]): "inferior" === s && (o.esquerdo + = u [0], o.top + = u [1]), e.popper = o, e}, deslocamento: 0}, preventOverflow: {ordem: 300, ativado:! 0, fn: função (e, t) {var n = t.boundariesElement || h (e.instância.popper); e.instance.reference === n && (n = h (n)); var r = H ("transformar"), i = e.instance.popper.style, o = i.top, a = i.left, s = i [r]; i.top = "", i.left = "", i [r] = ""; var u = D (e.instance.popper, e.instance.reference , t.padding, n, e.positionFixed); i.top = o, i.left = a, i [r] = s, t.boundaries = u; var c = t.priority, l = e.offsets. popper, f = {primary: function (e) {var n = l [e]; return l [e] <u [e] &&! t.escapeWithReference && (n = Math.max (l [e], u [e ])), E ({}, e, n)}, secundário: função (e) {var n = "direita" === e? "Esquerda": "topo", r = l [n]; retornar l [e]> u [e] &&! t.escapeWithReference && (r = Math.min (l [n], u [e] - ("direito" === e? l.width: l.height))), E ({}, n, r)}}; return c.forEach (function (e) {var t = -1! == ["left", "top"]. IndexOf (e)? "Primary": " secundário "; l = x ({}, l, f [t] (e))}), e.offsets.popper = l, e}, priority: ["left", "right", "top", "bottom"], padding: 5, boundariesElement: "scrollParent"}, keepTogether: {order: 400, enabled :! 0, fn: function (e) {var t = e.offsets, n = t.popper, r = t.reference, i = e.placement.split ("-") [0], o = Math.floor, a = -1! == ["superior", "inferior"]. indexOf (i), s = a? "direita": "inferior", u = a? "esquerda": "superior", c = a? "largura": "altura"; retornar n [s] <o (r [u]) && (e.offsets.popper [u] = o (r [u]) - n [c]), n [u] > o (r [s]) && (e.offsets.popper [u] = o (r [s])), e}}, seta: {ordem: 500, habilitado:! 0, fn: função (e, t) {var n; if (! V (e.instance.modifiers, "arrow", "keepTogether")) return e; var r = t.element; if ("string" == typeof r) {if (! (r = e.instance.popper.querySelector (r))) return e} else if (! e.instance.popper.contém (r)) return console.warn ("AVISO: ʻarrow.element` deve ser filho de seu elemento popper!"), e; var i = e.placement.split ("-") [0], o = e.offsets, a = o.popper, s = o.reference, c = -1! == ["left", "right"]. indexOf (i), l = c? "height": "width", f = c? "Top": "Left", p = f.toLowerCase (), d = c? "left": "top", h = c? "bottom": "right", v = N (r) [l]; s [h] -v <a [p] && (e.offsets.popper [p] - = a [p] - (s [h] -v)), s [p] + v> a [h] && (e.offsets.popper [p] + = s [p] + va [h]), e.offsets.popper = C (e.offsets.popper); var g = s [p] + s [l] / 2-v / 2, m = u (e.instance.popper), y = parseFloat (m ["margin" + f], 10), _ = parseFloat (m ["border" + f + "Width "], 10), b = ge.offsets.popper [p] -y -_; return b = Math.max (Math.min (a [l] -v, b), 0), e.arrowElement = r , e.offsets.arrow = (E (n = {}, p, Math.round (b)), E (n,d, ""), n), e}, elemento: "[x-seta]"}, inverter: {ordem: 600, habilitado:! 0, fn: função (e, t) {if ($ (e. instance.modifiers, "inner")) return e; if (e.flipped && e.placement === e.originalPlacement) return e; var n = D (e.instance.popper, e.instance.reference, t.padding, t.boundariesElement, e.positionFixed), r = e.placement.split ("-") [0], i = L (r), o = e.placement.split ("-") [1] || " ", a = []; switch (t.behavior) {case X.FLIP: a = [r, i]; break; case X.CLOCKWISE: a = G (r); break; case X.COUNTERCLOCKWISE: a = G (r,! 0); break; default: a = t.behavior} return a.forEach (function (s, u) {if (r! == s || a.length === u + 1) return e; r = e.placement.split ("-") [0], i = L (r); var c = e.offsets.popper, l = e.offsets.reference, f = Math.floor, p = "left" === r && f (c.right)> f (l.left) || "right" === r && f (c.esquerda) <f (l.right) || "top" === r &&f (c.bottom)> f (c.top) || "inferior" === r && f (c.top) <f (l.bottom), d = f (c.esquerdo) <f (n.esquerda) , h = f (c.direito)> f (n.direito), v = f (c.top) <f (n.top), g = f (c.bottom)> f (n.bottom), m = "esquerda" === r && d || "direita" === r && h || "superior" === r && v || "inferior" === r && g, y = -1! == ["superior", "inferior "] .indexOf (r), _ = !! t.flipVariations && (y &&" start "=== o && d || y &&" end "=== o && h ||! y &&" start "=== o && v ||! y &&" end "=== o && g); (p || m || _) && (e.flipped =! 0, (p || m) && (r = a [u + 1]), _ && (o = função ( e) {return "end" === e? "start": "start" === e? "end": e} (o)), e.placement = r + (o? "-" + o: " "), e.offsets.popper = x ({}, e.offsets.popper, j (e.instance.popper, e.offsets.reference, e.placement)), e = R (e.instance.modifiers, e, "flip"))}), e}, comportamento: "flip", preenchimento: 5, boundariesElement: " janela de visualização "}, interno: {pedido: 700, ativado:! 1, fn: função (e) {var t = e.placement, n = t.split (" - ") [0], r = e.offsets, i = r.popper, o = r.reference, a = -1! == ["left", "right"]. indexOf (n), s = -1 === ["top", "left"] .indexOf (n); return i [a? "left": "top"] = o [n] - (s? i [a? "width": "height"]: 0), e.placement = L ( t), e.offsets.popper = C (i), e}}, ocultar: {ordem: 800, habilitado:! 0, fn: função (e) {if (! V (e.instance.modifiers, "ocultar "," preventOverflow ")) return e; var t = e.offsets.reference, n = P (e.instance.modifiers, function (e) {return" preventOverflow "=== e.name}). limites; se (t.bottom <n.top || t.left> n.right || t.top> n.bottom || t.right <n.esquerda) {if (! 0 === e.hide) return e; e.hide =! 0, e.attributes ["x-out-of-boundaries"] = ""} else {if (! 1 == = e.hide) return e; e.hide =! 1, e.attributes ["x-out-of-boundaries"] =! 1} return e}}, computeStyle: {order: 850, enabled:! 0, fn: função (e, t) {var n = tx, r = ty, i = e.offsets.popper, o = P (e.instance.modifiers, function (e) {return "applyStyle" === e. name}). gpuAcceleration; void 0! == o && console.warn ("AVISO: a opção` gpuAcceleration` foi movida para o modificador `computeStyle` e não será suportada em versões futuras do Popper.js!"); var a = void 0! == o? o: t.gpuAcceleration, s = h (e.instance.popper), u = A (s), c = {position: i.position}, l = function (e, t) {var n = e.offsets, r = n.popper, i = n.reference, o = -1! == ["left", "right"]. indexOf (e.placement), a = -1! == e.placement .indexOf ("-"), s = i.width% 2 == r.width% 2, u = i.width% 2 == 1 && r.largura% 2 == 1, c = função (e) {retornar e}, l = t? o || a || s? Math.round: Math.floor: c, f = t? Math.round: c; return {left: l (u &&! a && t? r.left-1: r.left), top: f (r.top), bottom: f (r.bottom), right: l (r.right)}} ( e, window.devicePixelRatio <2 ||! U), f = "bottom" === n? "top": "bottom", p = "right" === r? "left": "right", d = H ("transformar"), v = void 0, g = void 0; if (g = "bottom" === f? "HTML" === s.nodeName? -S.clientHeight + l.bottom: - u.height + l.bottom: l.top, v = "right" === p? "HTML" === s.nodeName? -s.clientWidth + l.right: -u.width + l.right: l.esquerdo, a && d) c [d] = "translate3d (" + v + "px," + g + "px, 0)", c [f] = 0, c [p] = 0, c.willChange = "transformar "; senão {var m =" inferior "=== f? -1: 1, y =" direito "=== p? -1: 1; c [f] = g * m, c [p] = v * y, c.willChange = f + ","+ p} var _ = {"x-placement": e.placement}; retornar e.attributes = x ({}, _, e.attributes), e.styles = x ({}, c, e.styles) , e.arrowStyles = x ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: "bottom", y: "right"}, applyStyle: {pedido: 900, ativado :! 0, fn: function (e) {var t, n; return B (e.instance.popper, e.styles), t = e.instance.popper, n = e.attributes, Object.keys (n) .forEach (function (e) {! 1! == n [e]? t.setAttribute (e, n [e]): t.removeAttribute (e)}), e.arrowElement && Object.keys (e.arrowStyles). comprimento && B (e.arrowElement, e.arrowStyles), e}, onLoad: função (e, t, n, r, i) {var o = k (i, t, e, n.positionFixed), a = I (n .placement, o, t, e, n.modifiers.flip.boundariesElement, n.modifiers.flip.padding); retornar t.setAttribute ("x-placement", a), B (t, {position: n.positionFixed ? "fixo": "absoluto"}), n}, gpuAcceleration: void 0}}},J = função () {função e (t, n) {var r = isto, i = argumentos.comprimento> 2 && vazio 0! == argumentos [2]? Argumentos [2]: {}; w (isto, e), this.scheduleUpdate = function () {return requestAnimationFrame (r.update)}, this.update = a (this.update.bind (this)), this.options = x ({}, e.Defaults, i), this .state = {isDestroyed:! 1, isCreated:! 1, scrollParents: []}, this.reference = t && t.jquery? t [0]: t, this.popper = n && n.jquery? n [0]: n, this.options.modifiers = {}, Object.keys (x ({}, e.Defaults.modifiers, i.modifiers)). forEach (function (t) {r.options.modifiers [t] = x ({} , e.Defaults.modifiers [t] || {}, i.modifiers? i.modifiers [t]: {})}), this.modifiers = Object.keys (this.options.modifiers) .map (function ( e) {return x ({name: e}, r.options.modifiers [e])}). sort (function (e, t) {return e.order-t.order}), this.modifiers.forEach ( function (e) {e.enabled && s (e.onLoad) && e.onLoad (r.reference, r.popper, r.options, e,r.state)}), this.update (); var o = this.options.eventsEnabled; o && this.enableEventListeners (), this.state.eventsEnabled = o} return T (e, [{chave: "atualizar", valor : function () {return function () {if (! this.state.isDestroyed) {var e = {instance: this, styles: {}, arrowStyles: {}, attribute: {}, invertido:! 1, offsets: {}}; e.offsets.reference = k (this.state, this.popper, this.reference, this.options.positionFixed), e.placement = I (this.options.placement, e.offsets.reference, este .popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets. popper = j (this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed? "fixed": "absoluto", e = R (this.modifiers, e ), this.state.isCreated? this.options.onUpdate (e):(this.state.isCreated =! 0, this.options.onCreate (e))}}. call (this)}}, {key: "destroy", value: function () {return function () {return this. state.isDestroyed =! 0, $ (this.modifiers, "applyStyle") && (this.popper.removeAttribute ("x-placement"), this.popper.style.position = "", this.popper.style.top = "", this.popper.style.left = "", this.popper.style.right = "", this.popper.style.bottom = "", this.popper.style.willChange = "", isso. popper.style [H ("transform")] = ""), this.disableEventListeners (), this.options.removeOnDestroy && this.popper.parentNode.removeChild (this.popper), this} .call (this)}}, { chave: "enableEventListeners", valor: function () {return function () {this.state.eventsEnabled || (this.state = F (this.reference, this.options, this.state, this.scheduleUpdate))}.call (this)}}, {key: "disableEventListeners", value: function () {return W.call (this)}}]), e} (); J.Utils = ("undefined"! = typeof window? janela: e) .PopperUtils, J.placements = z, J.Defaults = Y, t.default = J} .call (this, n (1))}, function (e, t, n) {var r ;! function (t, n) {"use strict"; "object" == typeof e.exports? e.exports = t.document? n (t,! 0): function (e) {if (! e.document) lançar um novo erro ("jQuery requer uma janela com um documento"); return n (e)}: n (t)} ("indefinido"! = tipo de janela? janela: this, function (n, i) {"use estrito "; var o = [], a = n.document, s = Object.getPrototypeOf, u = o.slice, c = o.concat, l = o.push, f = o.indexOf, p = {}, d = p.toString, h = p.hasOwnProperty, v = h.toString, g = v.call (Object), m = {}, y = function (e) {return "function" == typeof e && "number"! = typeof e.nodeType}, _ = function (e) {return null! = e && e === e.janela}, b = {tipo:! 0, src:! 0, noModule:! 0}; função w (e, t, n) {var r, i = (t = t || a) .createElement ("script "); if (i.text = e, n) for (r in b) n [r] && (i [r] = n [r]); t.head.appendChild (i) .parentNode.removeChild (i )} função T (e) {return null == e? e + "": "objeto" == typeof e || "function" == typeof e? p [d.call (e)] || "object": typeof e} var E = function (e, t) {return new E.fn.init (e, t)}, x = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; função C (e) {var t = !! e && "comprimento" em e && e.length, n = T (e); return! y (e) &&! _ (e) && ("matriz" == = n || 0 === t || "número" == typeof t && t> 0 && t-1 em e)} E.fn = E.prototype = {jquery: "3.3.1", construtor: E, comprimento: 0 , toArray: function () {return u.call (this)}, get: function (e) {return null == e? u.call (this): e <0? this [e + this.length]: this [e]}, pushStack:function (e) {var t = E.merge (this.constructor (), e); return t.prevObject = this, t}, each: function (e) {return E.each (this, e)}, map : function (e) {return this.pushStack (E.map (this, function (t, n) {return e.call (t, n, t)}))}, slice: function () {return this.pushStack (u.aplicar (isto, argumentos))}, primeiro: função () {retornar isto.eq (0)}, último: função () {retornar isto.eq (-1)}, eq: função (e) { var t = this.length, n = + e + (e <0? t: 0); return this.pushStack (n> = 0 && n <t? [this [n]]: [])}, end: function () {return this.prevObject || this.constructor ()}, push: l, sort: o.sort, splice: o.splice}, E.extend = E.fn.extend = function () {var e, t, n, r, i, o, a = argumentos [0] || {}, s = 1, u = argumentos.comprimento, c =! 1; for ("booleano" == tipo de a && (c = a, a = argumentos [s] || {}, s ++), "objeto" == typeof a || y (a) || (a = {}), s === u && (a = this, s -); s <u; s ++) if (null! = (e = argumentos [s])) para (t em e) n = a [t], a! == (r = e [t]) && (c && r && (E.isPlainObject (r) || (i = Array.isArray (r)))? (i? (i =! 1, o = n && Array.isArray (n)? n: []): o = n && E.isPlainObject (n)? n: {}, a [t] = E.extend (c, o, r)): void 0! == r && (a [t] = r)); retornar a}, E .extend ({expando: "jQuery" + ("3.3.1" + Math.random ()). substituir (/ \ D / g, ""), isReady:! 0, erro: função (e) {lançar novo Erro (e)}, noop: function () {}, isPlainObject: function (e) {var t, n; return! (! E || "[Object Object]"! == d.call (e)) && (! (t = s (e)) || "função" == typeof (n = h.call (t, "construtor") && t.constructor) && v.call (n) === g)}, isEmptyObject: function (e) {var t; for (t in e) return! 1; return! 0}, globalEval: function (e) {w (e)}, each: function (e, t) {var n, r = 0; if (C (e)) para (n = e.length; r <n &&! 1! == t.call (e [r], r, e [r]); r ++); else for (r em e) if (! 1 === t.call (e [r], r, e [r])) interromper; retornar e}, cortar:function (e) {return null == e? "" :( e + ""). replace (x, "")}, makeArray: function (e, t) {var n = t || []; return null! = e && (C (Object (e))? E.merge (n, "string" == typeof e? [e]: e): l.call (n, e)), n}, inArray: function (e , t, n) {return null == t? -1: f.call (t, e, n)}, merge: function (e, t) {for (var n = + t.length, r = 0, i = e.length; r <n; r ++) e [i ++] = t [r]; retornar e.length = i, e}, grep: function (e, t, n) {for (var r = [] , i = 0, o = e.length, a =! n; i <o; i ++)! t (e [i], i)! == a && r.push (e [i]); return r}, mapa : função (e, t, n) {var r, i, o = 0, a = []; if (C (e)) para (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) && a.push (i); senão para (o em e) nulo! = (i = t (e [o], o, n)) && a.push (i ); return c.apply ([], a)}, guid: 1, support: m}), "função" == typeof Symbol && (E.fn [Symbol.iterator] = o [Symbol.iterator]), E .cada("Número booleano String Função Matriz Data RegExp Objeto Símbolo de erro ".split (" "), função (e, t) {p [" [objeto "+ t +"] "] = t.toLowerCase ()}); var A = função (e) {var t, n, r, i, o, a, s, u, c, l, f, p, d, h, v, g, m, y, _, b = "chiar" +1 * nova data, w = e.documento, T = 0, E = 0, x = ae (), C = ae (), A = ae (), S = função (e, t) {return e === t && (f =! 0), 0}, O = {}. hasOwnProperty, D = [], I = D.pop, k = D.push, N = D.push, L = D.slice, j = função (e, t) {for (var n = 0, r = e.length; n <r; n ++) if (e [n] === t) return n; return-1}, P = "verificado | selecionado | assíncrono | foco automático | reprodução automática | controles | adiar | desativado | oculto | ismap | loop | múltiplo | aberto | somente leitura | necessário | escopo ", R =" [\\ x20 \\ t \\ r \\ n \\ f] ", $ =" (?: \\\\. | [\\ w-] | [^ \ 0 - \\ xa0]) + ", H =" \\ ["+ R +" * ("+ $ + ") (?:" + R + "* ([* ^ $ |! ~]? =)" + R + "* (?: '((?: \\\\. | [^ \\\\']) *) '| \ "((?: \\\\.| [^ \\\\\ "]) *) \" | ("+ $ +")) |) "+ R +" * \\] ", M =" :( "+ $ +") (?: \\ ((('((?: \\\\. | [^ \\\\']) *) '| \ "((?: \\\\. | [^ \\\\\"] ) *) \ ") | ((?: \\\\. | [^ \\\\ () [\\]] |" + H + ") *) |. *) \\) |)", F = novo RegExp (R + "+", "g"), W = novo RegExp ("^" + R + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *) "+ R +" + $ "," g "), q = novo RegExp (" ^ "+ R +" *, "+ R +" * "), B = novo RegExp (" ^ "+ R +" * ([ > + ~] | "+ R +") "+ R +" * "), U = novo RegExp (" = "+ R +" * ([^ \\] '\ "] *?)" + R + "* \\ ] "," g "), V = novo RegExp (M), z = novo RegExp (" ^ "+ $ +" $ "), K = {ID: novo RegExp (" ^ # ("+ $ +") "), CLASSE: novo RegExp (" ^ \\. ("+ $ +") "), TAG: novo RegExp (" ^ ("+ $ +" | [*]) "), ATTR:new RegExp ("^" + H), PSEUDO: new RegExp ("^" + M), CHILD: new RegExp ("^ :( apenas | primeiro | último | enésimo | enésimo último) - (filho | do tipo ) (?: \\ ("+ R +" * (par | ímpar | (([+ -] |) (\\ d *) n |) "+ R +" * (?: ([+ -] |) " + R + "* (\\ d +) |))" + R + "* \\) |)", "i"), bool: novo RegExp ("^ (?:" + P + ") $", "i" ), needsContext: new RegExp ("^" + R + "* [> + ~] |: (par | ímpar | eq | gt | lt | enésimo | primeiro | último) (?: \\ (" + R + "* ( (?: - \\ d)? \\ d *) "+ R +" * \\) |) (? = [^ -] | $) "," i ")}, G = / ^ (?: entrada | selecionar | textarea | botão) $ / i, X = / ^ h \ d $ / i, Q = / ^ [^ {] + \ {\ s * \ [nativo \ w /, Y = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, J = / [+ ~] /, Z = novo RegExp ("\\\\ ([ \\ da-f] {1,6} "+ R +"? | ("+ R +") |.) "," ig "), ee = função (e, t, n) {var r =" 0x " + t-65536; retornar r! = r || n? t: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296,1023 & r | 56320)}, te = / ([\ 0- \ x1f \ x7f] | ^ -? \ d) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, ne = função (e, t) {return t? "\ 0" === e? "ï¿½": e.slice (0, -1) + "\\" + e.charCodeAt (e.length-1) .toString (16) + "": "\\" + e}, re = function () {p ()}, ou seja, = ye (function (e) {return! 0 === e.disabled && ("form" in e || "label" in e)}, {dir: "parentNode", next: "legend"}); tente {N.apply (D = L.call ( w.childNodes), w.childNodes), D [w.childNodes.length] .nodeType} catch (e) {N = {aplicar: D.length? função (e, t) {k.apply (e, L. call (t))}: function (e, t) {for (var n = e.length, r = 0; e [n ++] = t [r ++];); e.length = n-1}}} function oe (e, t, r, i) {var o, s, c, l, f, h, m, y = t && t.ownerDocument, T = t? t.nodeType: 9; if (r = r || [ ], "string"! = typeof e ||! e || 1! == T && 9! == T && 11! == T) return r; if (! i && ((t? t.ownerDocument || t: w)! == d && p (t), t = t || d, v)) {if (11! == T && (f = Y.exec (e))) if (o = f [ 1]) {if (9 === T) {if (! (C = t.getElementById (o))) return r; if (c.id === o) return r.push (c), r} else if (y && (c = y.getElementById (o)) && _ (t, c) && c.id === o) return r.push (c), r} else {if (f [2]) retorna N. aplicar (r, t.getElementsByTagName (e)), r; if ((o = f [3]) && n.getElementsByClassName && t.getElementsByClassName) retornar N.apply (r, t.getElementsByClassName (o)), r} if (n .qsa &&! A [e + ""] && (! g ||! g.test (e))) {if (1! == T) y = t, m = e; else if ("objeto"! == t.nodeName.toLowerCase ()) {for ((l = t.getAttribute ("id"))? l = l.replace (te, ne): t.setAttribute ("id", l = b), s = (h = a (e)). comprimento; s -;) h [s] = "#" + l + "" + me (h [s]); m = h.join (","), y = J.test (e) && ve (t.parentNode) || t} if (m) try {return N.apply (r, y.querySelectorAll (m)), r} catch (e) {} finalmente {l === b && t.removeAttribute ("id")}}} return u (e.replace (W, "$ 1"), t, r, i )} função ae () {var e = []; função de retorno t (n, i) {return e.push (n + "")> r.cacheLength && delete t [e.shift ()], t [n + ""] = i}} função se (e) {return e [b] =! 0, e} função ue (e) {var t = d.createElement ("fieldset"); tente {return !! e (t)} catch (e) {return! 1} finalmente {t.parentNode && t.parentNode.removeChild (t), t = null}} função ce (e, t) {for (var n = e.split ("|"), i = n.length; i -;) r.attrHandle [n [i]] = t} arquivo de função (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e. sourceIndex-t.sourceIndex; if (r) retorna r; if (n) para (; n = n.nextSibling;) if (n === t) return-1; return e? 1: -1} função fe ( e) {return function (t) {return "input" === t.nodeName.toLowerCase () && t.type === e}} function pe (e) {return function (t) {var n = t.nodeName.toLowerCase (); return ("input" === n || "button" === n) && t .type === e}} function de (e) {return function (t) {return "form" in t? t.parentNode &&! 1 === t.disabled? "label" in t? "label" in t .parentNode? t.parentNode.disabled === e: t.disabled === e: t.isDisabled === e || t.isDisabled! ==! e && ie (t) === e: t.disabled = == e: "rótulo" em t && t.disabled === e}} função he (e) {return se (function (t) {return t = + t, se (function (n, r) {for (var i , o = e ([], n.length, t), a = o.length; a -;) n [i = o [a]] && (n [i] =! (r [i] = n [i]))})})} function ve (e) {return e && void 0! == e.getElementsByTagName && e} for (t in n = oe.support = {}, o = oe.isXML = function (e) { var t = e && (e.ownerDocument || e) .documentElement; return !! t && "HTML"! == t.nodeName}, p = oe.setDocument = function (e) {var t, i, a = e? e.ownerDocument || e: w; return a! == d && 9 === a.nodeType && a.documentElement? (h = (d = a) .documentElement , v =! o (d), w! == d && (i = d.defaultView) && i.top! == i && (i.addEventListener? i.addEventListener ("descarregar", re,! 1): i.attachEvent && i .attachEvent ("onunload", re)), n.attributes = ue (function (e) {return e.className = "i",! e.getAttribute ("className")}), n.getElementsByTagName = ue (function (e) {return e.appendChild (d.createComment ("")) ,! e.getElementsByTagName ("*"). length}), n.getElementsByClassName = Q.test (d.getElementsByClassName), n.getById = ue (function (e) {return h.appendChild (e) .id = b,! d.getElementsByName ||! d.getElementsByName (b) .length}), n.getById? (r.filter.ID = function (e ) {var t = e.replace (Z, ee); função de retorno (e) {return e.getAttribute ("id ") === t}}, r.find.ID = function (e, t) {if (void 0! == t.getElementById && v) {var n = t.getElementById (e); retornar n? [n ]: []}}) :( r.filter.ID = function (e) {var t = e.replace (Z, ee); função de retorno (e) {var n = void 0! == e.getAttributeNode && e. getAttributeNode ("id"); return n && n.value === t}}, r.find.ID = function (e, t) {if (void 0! == t.getElementById && v) {var n, r, i, o = t.getElementById (e); if (o) {if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]; para (i = t.getElementsByName (e ), r = 0; o = i [r ++];) if ((n = o.getAttributeNode ("id")) && n.value === e) return [o]} return []}}), r. find.TAG = n.getElementsByTagName? function (e, t) {return void 0! == t.getElementsByTagName? t.getElementsByTagName (e): n.qsa? t.querySelectorAll (e): void 0}: function (e , t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {para (; n = o [i ++];) 1 == = n.nodeType && r.push (n); return r} return o}, r.find.CLASS = n.getElementsByClassName && function (e, t) {if (void 0! == t.getElementsByClassName && v) return t.getElementsByClassName (e)}, m = [], g = [], (n.qsa = Q.test (d.querySelectorAll)) && (ue (função (e) {h.appendChild (e) .innerHTML = "<a id = '" + b + "'> </a> <select id ='" + b + "- \ r \\ 'msallowcapture =' '> <option selected =' '> </option> </select>", e.querySelectorAll ("[ msallowcapture ^ = ''] "). length && g.push (" [* ^ $] = "+ R +" * (?: '' | \ "\") "), e.querySelectorAll (" [selecionado] "). comprimento || g.push ("\\ [" + R + "* (?: valor |" + P + ")"), e.querySelectorAll ("[id ~ =" + b + "-]"). comprimento || g.push ("~ ="), e.querySelectorAll (": checks"). length || g.push (": checks"), e.querySelectorAll ("a #" + b + "+ *"). length || g.push (". #. + [+ ~] ")}), ue (function (e) {e.innerHTML =" <a href='' disabled='disabled'> </a> <select disabled = 'disabled'> <option /> </ select > "; var t = d.createElement (" input "); t.setAttribute (" type "," hidden "), e.appendChild (t) .setAttribute (" name "," D "), e.querySelectorAll ( "[name = d]"). length && g.push ("name" + R + "* [* ^ $ |! ~]? ="), 2! == e.querySelectorAll (": enabled"). length && g.push (": ativado", ": desativado"), h.appendChild (e) .disabled =! 0,2! == e.querySelectorAll (": desativado"). length && g.push (": ativado", ": desativado "),e.querySelectorAll ("* ,: x"), g.push (",. *:")})), (n.matchesSelector = Q.test (y = h.matches || h.webkitMatchesSelector || h. mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue (function (e) {n.disconnectedMatch = y.call (e, "*"), y.call (e, "[s! = '']: x "), m.push ("! = ", M)}), g = g.length && new RegExp (g.join (" | ")), m = m.length && new RegExp (m.join (" | ") ), t = Q.test (h.compareDocumentPosition), _ = t || Q.test (h.contains)? function (e, t) {var n = 9 === e.nodeType? e.documentElement: e , r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r )))}: function (e, t) {if (t) for (; t = t.parentNode;) if (t === e) return! 0; return! 1}, S = t? function (e , t) {if (e === t) return f =! 0,0; var r =! e.compareDocumentPosition-! t.compareDocumentPosition; return r || (1 & (r = (e.ownerDocument || e) === (t.ownerDocument || t)? e.compareDocumentPosition (t): 1) ||! n.sortDetached && t.compareDocumentPosition (e ) === r? e === d || e.ownerDocument === w && _ (w, e)? - 1: t === d || t.ownerDocument === w && _ (w, t)? 1 : l? j (l, e) -j (l, t): 0: 4 & r? -1: 1)}: função (e, t) {if (e === t) return f =! 0,0 ; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; se (! i ||! o) retornar e === d? -1 : t === d? 1: i? -1: o? 1: l? j (l, e) -j (l, t): 0; se (i === o) retornar le (e, t ); para (n = e; n = n.parentNode;) a.unshift (n); para (n = t; n = n.parentNode;) s.unshift (n); para (; a [r] = == s [r];) r ++; return r? le (a [r], s [r]): a [r] === w? -1: s [r] === w? 1: 0 }, d): d}, oe.matches = function (e, t) {return oe (e, null, null, t)}, oe.matchesSelector = function (e, t) {if ((e.ownerDocument | | e)! == d && p (e), t = t.replace (U, "= '$ 1']"), n.matchesSelector && v &&! A [t + ""] && (! m ||! m.test (t)) && (! g ||! g.test (t))) tente {var r = y.call (e, t); if (r || n. disconnectedMatch || e.document && 11! == e.document.nodeType) return r} catch (e) {} return oe (t, d, null, [e]). length> 0}, oe.contains = function (e , t) {return (e.ownerDocument || e)! == d && p (e), _ (e, t)}, oe.attr = function (e, t) {(e.ownerDocument || e)! = = d && p (e); var i = r.attrHandle [t.toLowerCase ()], o = i && O.call (r.attrHandle, t.toLowerCase ())? i (e, t,! v): vazio 0; return void 0! == o? o: n.attributes ||! v? e.getAttribute (t) :( o = e.getAttributeNode (t)) && o.specified? o.value: null}, oe.escape = function (e) {return (e + ""). replace (te, ne)}, oe.error = function (e) {throw new Error ("Erro de sintaxe, expressão não reconhecida:" + e)}, oe.uniqueSort = função (e) {var t, r = [], i = 0, o = 0; if (f =! n.detectDuplicates, l =! n.sortStable && e.slice (0), e.sort (S), f ) {para (; t = e [o ++];) t === e [o] && (i = r.push (o)); para (; i -;) e.splice (r [i], 1)} return l = null, e}, i = oe.getText = function (e) {var t, n = "", r = 0, o = e.nodeType; if (o) {if (1 === o || 9 === o || 11 === o) {if (" string "== typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n + = i (e)} else if (3 === o || 4 == = o) return e.nodeValue} else for (; t = e [r ++];) n + = i (t); return n}, (r = oe.selectors = {cacheLength: 50, createPseudo: se, match: K , attrHandle: {}, find: {}, relative: {">": {dir: "parentNode", first:! 0}, "": {dir: "parentNode"}, "+": {dir: " previousSibling ", first:! 0}," ~ ": {dir:" previousSibling "}}, preFilter: {ATTR: function (e) {return e [1] = e [1] .replace (Z, ee), e [3] = (e [3] || e [4] || e [5] || ""). substitua (Z, ee), "~ =" === e [2] && (e [ 3] = "" + e [3] + ""), e.slice (0,4)}, CRIANÇA:function (e) {return e [1] = e [1] .toLowerCase (), "enésimo" === e [1] .slice (0,3)? (e [3] || oe.error (e [0]), e [4] = + (e [4]? E [5] + (e [6] || 1): 2 * ("par" === e [3] || "ímpar" === e [3])), e [5] = + (e [7] + e [8] || "ímpar" === e [3])): e [3] && oe.error (e [0]), e}, PSEUDO: função (e) {var t, n =! E [6] && e [2]; retornar K.CHILD.test (e [0])? Null: (e [3] ? e [2] = e [4] || e [5] || "": n && V.test (n) && (t = a (n,! 0)) && (t = n.indexOf (")" , n.length-t) -n.length) && (e [0] = e [0] .slice (0, t), e [2] = n.slice (0, t)), e.slice ( 0,3))}}, filtro: {TAG: function (e) {var t = e.replace (Z, ee) .toLowerCase (); return "*" === e? Function () {return! 0 }: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASSE: function (e) {var t = x [e + ""]; return t || (t = new RegExp ("(^ |" + R + ")" + e + "(" + R + "| $)")) && x (e,function (e) {return t.test ("string" == typeof e.className && e.className || void 0! == e.getAttribute && e.getAttribute ("class") || "")})}, ATTR: function (e, t, n) {função de retorno (r) {var i = oe.attr (r, e); retorno nulo == i? "! =" === t:! t || (i + = "" , "=" === t? i === n: "! =" === t? i! == n: "^ =" === t? n && 0 === i.indexOf (n): "* =" === t? n && i.indexOf (n)> - 1: "$ =" === t? n && i.slice (-n.length) === n: "~ =" === t ? ("" + i.replace (F, "") + "") .indexOf (n)> - 1: "| =" === t && (i === n || i.slice (0, n .comprimento + 1) === n + "-"))}}, CRIANÇA: função (e, t, n, r, i) {var o = "enésimo"! == e.slice (0,3), a = "último"! == e.slice (-4), s = "do tipo" === t; return 1 === r && 0 === i? function (e) {return !! e.parentNode }: função (t, n,u) {var c, l, f, p, d, h, v = o! == a? "nextSibling": "previousSibling", g = t.parentNode, m = s && t.nodeName.toLowerCase (), y = ! u &&! s, _ =! 1; if (g) {if (o) {for (; v;) {for (p = t; p = p [v];) if (s? p.Nome do nó.paraCase inferior () === m: 1 === p.nodeType) return! 1; h = v = "apenas" === e &&! h && "nextSibling"} return! 0} if (h = [a? g.firstChild : g.lastChild], a && y) {for (_ = (d = (c = (l = (f = (p = g) [b] || (p [b] = {})) [p.uniqueID] || (f [p.uniqueID] = {})) [e] || []) [0] === T && c [1]) && c [2], p = d && g.childNodes [d]; p = + + d && p && p [v] || (_ = d = 0) || h.pop ();) if (1 === p.nodeType && ++ _ && p === t) {l [e] = [T, d , _]; quebrar}} else if (y && (_ = d = (c = (l = (f = (p = t) [b] || (p [b] = {})) [p.ID único] || (f [p.uniqueID] = {})) [e] || []) [0] === T && c [1]) ,! 1 === _) para (; (p = ++ d && p && p [v] || (_ = d = 0) || h.pop ()) && ((s? p.nome do nó.toLowerCase ()! == m:1! == p.nodeType) ||! ++ _ || (y && ((l = (f = p [b] || (p [b] = {})) [p.uniqueID] || (f [p.uniqueID] = {})) [e] = [T, _]), p! == t));); return (_- = i) === r || _% r == 0 && _ / r> = 0}}}, PSEUDO: função (e, t) {var n, i = r.pseudos [e] || r.setFilters [e.toLowerCase ()] || oe.error ("pseudo sem suporte : "+ e); retornar i [b]? i (t): i.length> 1? (n = [e, e," ", t], r.setFilters.hasOwnProperty (e.toLowerCase ())? se (função (e, n) {para (var r, o = i (e, t), a = o.comprimento; a -;) e [r = j (e, o [a])] =! (n [r] = o [a])}): função (e) {retorno i (e, 0, n)}): i}}, pseudos: {não: se (função (e) {var t = [], n = [], r = s (e.replace (W, "$ 1")); retornar r [b]? se (função (e, t, n, i) {para (var o, a = r (e, nulo, i, []), s = e.length; s -;) (o = a [s]) && (e [s] =! (t [s] = o))}) : function (e, i, o) {return t [0] = e, r (t, null, o, n), t [0] = null,! n.pop ()}}), has: se ( function (e) {return function (t) {return oe (e, t) .length> 0}}), contém: se (function (e) {return e = e.substituir (Z, ee), função (t) {retornar (t.textContent || t.innerText || i (t)). indexOf (e)> - 1}}), lang: se (função (e) { return z.test (e || "") || oe.error ("idioma não suportado:" + e), e = e.replace (Z, ee) .toLowerCase (), function (t) {var n; fazer {if (n = v? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) return (n = n.toLowerCase ()) === e || 0 = == n.indexOf (e + "-")} while ((t = t.parentNode) && 1 === t.nodeType); return! 1}}), target: function (t) {var n = e.location && e .location.hash; return n && n.slice (1) === t.id}, root: function (e) {return e === h}, focus: function (e) {return e === d.activeElement && (! d.hasFocus || d.hasFocus ()) && !! (e.type || e.href || ~ e.tabIndex)}, ativado: de (! 1), desativado: de (! 0), verificado: function (e) {var t = e.nodeName.toLowerCase (); return "input" === t && !! e.checked || "opção" === t &&!! e.selected}, selecionado: function (e) {return e.parentNode && e.parentNode.selectedIndex,! 0 === e.selected}, vazio: function (e) {for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType <6) return! 1; return! 0}, parent: function (e) {return! r.pseudos.empty (e)}, header: function (e) {return X .test (e.nodeName)}, input: function (e) {return G.test (e.nodeName)}, botão: function (e) {var t = e.nodeName.toLowerCase (); return "input" = == t && "button" === e.type || "button" === t}, text: function (e) {var t; return "input" === e.nodeName.toLowerCase () && "text "=== e.type && (null == (t = e.getAttribute (" type ")) ||" text "=== t.toLowerCase ())}, primeiro: he (function () {return [0 ]}), último: he (função (e, t) {retorno [t-1]}), eq: he (função (e, t, n) {retorno [n <0? n + t: n]} ), mesmo: he (função (e, t) {para (var n = 0; n <t; n + = 2) e.push (n); retornar e}),ímpar: he (função (e, t) {para (var n = 1; n <t; n + = 2) e.push (n); retornar e}), lt: he (função (e, t, n) {para (var r = n <0? n + t: n; - r> = 0;) e.push (r); retornar e}), gt: he (função (e, t, n) {para (var r = n <0? n + t: n; ++ r <t;) e.push (r); retornar e})}}). pseudos.nth = r.pseudos.eq, {rádio :! 0, caixa de seleção:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) r.pseudos [t] = fe (t); for (t em {enviar:! 0, redefinir:! 0} ) r.pseudos [t] = pe (t); função ge () {} função me (e) {para (var t = 0, n = e.length, r = ""; t <n; t ++) r + = e [t] .value; return r} função ye (e, t, n) {var r = t.dir, i = t.next, o = i || r, a = n && "parentNode" === o, s = E ++; return t.first? function (t, n, i) {for (; t = t [r];) if (1 === t.nodeType || a) return e (t, n , i); return! 1}: função (t, n, u) {var c, l, f, p = [T, s]; if (u) {for (; t = t [r];) if ((1 === t.nodeType || a) && e (t, n, u)) return! 0} else for (; t = t [r];) if (1 === t.nodeType || a ) if (l = (f = t [b] || (t [b] = {})) [t.uniqueID] || (f [t.uniqueID] = {}), i && i === t.nodeNome.toLowerCase ()) t = t [r] || t; else {if ((c = l [o]) && c [0] === T && c [1] === s) retornar p [2] = c [2]; if (l [o] = p, p [2] = e (t, n, u)) retornar! 0} retornar! 1}} função _e (e) {retornar e.length> 1? função (t, n, r) {for (var i = e.length; i -;) if (! e [i] (t, n, r)) return! 1; return! 0}: função e [0]} ser (e, t, n, r, i) {para (var o, a = [], s = 0, u = comprimento e, c = nulo! = T; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), c && t.push (s))); retornar a} função nós ( e, t, n, r, i, o) {return r &&! r [b] && (r = we (r)), i &&! i [b] && (i = we (i, o)), se ( função (o, a, s, u) {var c, l, f, p = [], d = [], h = a.length, v = o || função (e, t, n) {para ( var r = 0, i = t.length; r <i; r ++) oe (e, t [r], n); retornar n} (t || "*", s.nodeType? [s]: s, []), g =! e ||! o && t? v: be (v, p, e, s, u), m = n? i || (o? e: h || r)? []: a : g; if (n && n (g, m, s, u), r) para (c = be (m, d), r (c, [], s, u), l = c.length; l-- ;) (f = c [l]) &&(m [d [l]] =! (g [d [l]] = f)); if (o) {if (i || e) {if (i) {for (c = [], l = m.length; l -;) (f = m [l]) && c.push (g [l] = f); i (nulo, m = [], c, u)} para (l = m.length ; l -;) (f = m [l]) && (c = i? j (o, f): p [l])> - 1 && (o [c] =! (a [c] = f) )}} else m = be (m === a? m.splice (h, m.length): m), i? i (null, a, m, u): N.apply (a, m)} )} função Te (e) {para (var t, n, i, o = e.length, a = r.relative [e [0] .type], s = a || r.relative [""], u = a? 1: 0, l = ye (função (e) {return e === t}, s,! 0), f = ye (função (e) {return j (t, e)> - 1 }, s,! 0), p = [função (e, n, r) {var i =! a && (r || n! == c) || ​​((t = n) .nodeType? l (e, n, r): f (e, n, r)); return t = null, i}]; u <o; u ++) if (n = r.relative [e [u] .type]) p = [ye (_e (p), n)]; senão {if ((n = r.filtro [e [u] .type] .apply (null, e [u] .matches)) [b]) {for (i = ++ u; i <o &&! r.relative [e [i] .type]; i ++); retornamos nós (u> 1 && _ e (p), u> 1 && me (e.slice (0, u-1) .concat ( {valor: "" === e [u-2] .tipo? "*":""})). substituir (W, "$ 1"), n, u <i && Te (e.slice (u, i)), i <o && Te (e = e.slice (i)), i <o && me (e ))} p.push (n)} return _e (p)} return ge.prototype = r.filters = r.pseudos, r.setFilters = new ge, a = oe.tokenize = function (e, t) {var n, i, o, a, s, u, c, l = C [e + ""]; se (l) retornar t? 0: l.slice (0); para (s = e, u = [], c = r.preFilter; s;) {para (a em n &&! (i = q.exec (s)) || (i && (s = s.slice (i [0] .comprimento) || s), u .push (o = [])), n =! 1, (i = B.exec (s)) && (n = i.shift (), o.push ({valor: n, digite: i [0] .replace (W, "")}), s = s.slice (n.length)), r.filter)! (i = K [a] .exec (s)) || c [a] &&! ( i = c [a] (i)) || (n = i.shift (), o.push ({valor: n, tipo: a, corresponde a: i}), s = s.slice (n.length) ); if (! n) break} return t? s.length: s? oe.error (e): C (e, u) .slice (0)}, s = oe.compile = function (e, t) {var n, i = [], o = [], s = A [e + ""]; if (! s) {para (t || (t = a (e)), n = t.length; n -;) (s = Te (t [n])) [b] i.push (s): o.push (s); (s = A (e, função (e, t) {var n = t.length> 0, i = e.length> 0, o = function (o, a , s, u, l) {var f, h, g, m = 0, y = "0", _ = o && [], b = [], w = c, E = o || i && r.find.TAG ("*", l), x = T + = nulo == w? 1: Math.random () || .1, C = E.length; para (l && (c = a === d || a | | l); y! == C && null! = (f = E [y]); y ++) {if (i && f) {for (h = 0, a || f.ownerDocument === d || (p (f ), s =! v); g = e [h ++];) if (g (f, a || d, s)) {u.push (f); quebrar} l && (T = x)} n && (( f =! g && f) && m -, o && _. push (f))} if (m + = y, n && y! == m) {for (h = 0; g = t [h ++];) g (_, b, a, s); if (o) {if (m> 0) for (; y -;) _ [y] || b [y] || (b [y] = I.call (u)); b = be (b)} N.apply (u, b), l &&! o && b.length> 0 && m + t.length> 1 && oe.uniqueSort (u)} return l && (T = x, c = w), _}; retornar n? se (o): o} (o, i))). seletor = e} retornar s}, u = oe.select = função (e, t, n, i) {var o, u, c, l, f, p = "função"== typeof e && e, d =! i && a (e = p.seletor || e); if (n = n || [], 1 === d.length) {if ((u = d [0] = d [0] .slice (0)). Length> 2 && "ID" === (c = u [0]). Type && 9 === t.nodeType && v && r.relative [u [1] .type]) {if (! (t = (r.find.ID (c.matches [0] .replace (Z, ee), t) || []) [0])) return n; p && (t = t.parentNode), e = e.slice (u.shift (). value.length)} para (o = K.needsContext.test (e)? 0: u.length; o - && (c = u [o] ,! r.relative [l = c.type]);) if ((f = r.find [l]) && (i = f (c.matches [0] .replace (Z, ee), J.test (u [0] .type) && ve (t.parentNode) || t))) {if (u.splice (o, 1),! (e = i.length && me (u))) return N.apply (n, i), n ; quebrar}} return (p || s (e, d)) (i, t,! v, n,! t || J.test (e) && ve (t.parentNode) || t), n}, n.sortStable = b.split (""). sort (S) .join ("") === b, n.detectDuplicates = !! f, p (), n.sortDetached = ue (function (e) { return 1 & e.compareDocumentPosition (d.createElement ("fieldset"))}), ue (function (e) {return e.innerHTML = "<a href='#'> </a>", "#" === e.firstChild.getAttribute (" href ")}) || ce (" type | href | height | width ", function (e, t, n) {if (! n) return e.getAttribute (t," type "=== t.toLowerCase ( )? 1: 2)}), n.attributes && ue (function (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("value", ""), "" === e .firstChild.getAttribute ("valor")}) || ce ("valor", função (e, t, n) {if (! n && "input" === e.nodeName.toLowerCase ()) return e.defaultValue }), ue (function (e) {return null == e.getAttribute ("disabled")}) || ce (P, function (e, t, n) {var r; if (! n) return! 0 === e [t]? t.toLowerCase () :( r = e.getAttributeNode (t)) && r.specified? r.value: null}), oe} (n); E.find = A, E. expr = A.seletores, E.expr [":"] = E.expr.pseudos, E.uniqueSort = E.unique = A.uniqueSort, E.text = A.getText, E.isXMLDoc = A.isXML, E.contains = A .contains, E.escapeSelector = A.escape; var S = function (e, t, n) {for (var r = [], i = void 0! == n; (e = e [t]) && 9! == e.nodeType;) if (1 === e.nodeType) {if (i && E (e) .is (n)) break; r.push (e)} return r}, O = função (e, t ) {for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e); return n}, D = E.expr.match.needsContext; função I (e, t) {return e.nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()} var k = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; função N (e, t, n) {retorno y (t)? Ex. grep (e, função (e, r) {retorno !! t.call (e, r, e)! == n}): t.nodeType? Ex. grep (e, função ( e) {return e === t! == n}): "string"! = typeof t? Por exemplo, (e, function (e) {return f.call (t, e)> - 1! == n}): E.filter (t, e, n)} E.filtro = função (e, t, n) {var r = t [0]; retornar n && (e = ": não (" + e + ")"), 1 === t.length && 1 === r.nodeType? E.find.matchesSelector (r, e)? [R]: []: E.find.matches (e, E.grep (t, function (e) {return 1 === e.nodeType}))}, E.fn.extend ({find: function (e) {var t, n, r = this.length, i = this; if ("string"! = Typeof e) return this.pushStack (E (e) .filter (function () {for (t = 0; t <r; t ++) if (E.contains (i [t], this)) return! 0})); for (n = this.pushStack ([]), t = 0; t <r; t ++) E. encontrar (e, i [t], n); retornar r> 1? E.uniqueSort (n): n}, filtro: função (e) {retornar este.pushStack (N (this, e || [] ,! 1))}, não: function (e) {return this.pushStack (N (this, e || [] ,! 0))}, é: function (e ) {return !! N (this, "string" == typeof e && D.test (e)? E (e): e || [] ,! 1) .length}}); var L, j = / ^ ( ?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] +)) $ /; (E.fn.init = function (e, t, n) {var r, i; if (! e) retornar isso; if (n = n || L, "string "== typeof e) {if (! (r =" <"=== e [0] &&"> "=== e [e.length-1] && e.length> = 3? [null, e , null]: j.exec (e)) ||! r [1] && t) return! t || t.jquery? (t || n) .find (e): this.constructor (t) .find ( e); if (r [1]) {if (t = t instância de E? t [0]: t, E.merge (this, E.parseHTML (r [1], t && t.nodeType? t.ownerDocument || t: a,! 0)), k.test (r [1]) && E.isPlainObject (t)) para (r em t) y (este [r])? este [r] (t [r]): this.attr (r, t [r]); retornar este} return (i = a.getElementById (r [2])) && (this [0] = i, this.length = 1), this} retornar e. nodeType? (this [0] = e, this.length = 1, this): y (e)? void 0! == n.ready? n.ready (e): e (E): E.makeArray (e , este)}). protótipo = E.fn, L = E (a); var P = / ^ (?: pais | anterior (?: Até | Todos)) /, R = {filhos:! 0, conteúdo: ! 0, próximo:! 0, anterior:! 0}; função $ (e, t) {for (; (e = e [t]) && 1! == e.nodeType;); return e} E.fn. extend ({has: function (e) {var t = E (e, this), n = t.length;return this.filter (function () {for (var e = 0; e <n; e ++) if (E.contains (this, t [e])) return! 0})}, mais próximo: function (e, t ) {var n, r = 0, i = this.length, o = [], a = "string"! = typeof e && E (e); if (! D.test (e)) for (; r <i; r ++) para (n = this [r]; n && n! == t; n = n.parentNode) if (n.nodeType <11 && (a? a.index (n)> - 1: 1 === n.nodeType && E .find.matchesSelector (n, e))) {o.push (n); break} return this.pushStack (o.length> 1? E.uniqueSort (o): o)}, index: function (e) { return e? "string" == typeof e? f.call (E (e), this [0]): f.call (this, e.jquery? e [0]: e): this [0] && this [ 0] .parentNode? This.first (). PrevAll (). Length: -1}, adicione: function (e, t) {return this.pushStack (E.uniqueSort (E.merge (this.get (), E (e, t))))}, addBack: function (e) {return this.add (null == e? this.prevObject: this.prevObject.filter (e))}}), E.each ({parent : function (e) {var t = e.parentNode; return t && 11! == t.nodeType? t: null}, parent: function (e) {return S (e, "parentNode")}, parentsUntil: function (e, t, n) {return S (e, "parentNode", n)}, próximo : function (e) {return $ (e, "nextSibling")}, prev: function (e) {return $ (e, "previousSibling")}, nextAll: function (e) {return S (e, "nextSibling" )}, prevAll: function (e) {return S (e, "previousSibling")}, nextUntil: function (e, t, n) {return S (e, "nextSibling", n)}, prevUntil: function (e , t, n) {return S (e, "previousSibling", n)}, siblings: function (e) {return O ((e.parentNode || {}). firstChild, e)}, children: function (e ) {return O (e.firstChild)}, conteúdo: função (e) {return I (e, "iframe")? e.contentDocument: (I (e, "template") && (e = e.content || e), E.merge ([], e.childNodes))}}, função (e, t) {E.fn [e] = função (n, r) {var i = E.map (this, t, n); retornar "Até"! == e.fatia (-5) && (r = n), r && "string" == typeof r && (i = E.filter (r, i)), this.length> 1 && (R [e] || E.uniqueSort (i ), P.test (e) && i.reverse ()), this.pushStack (i)}}); var H = / [^ \ x20 \ t \ r \ n \ f] + / g; função M (e ) {return e} função F (e) {jogar e} função W (e, t, n, r) {var i; tentar {e && y (i = e.promise)? i.call (e) .done (t ) .fail (n): e && y (i = e.then)? i.call (e, t, n): t.apply (void 0, [e] .slice (r))} catch (e) {n .apply (void 0, [e])}} E.Callbacks = function (e) {e = "string" == typeof e? function (e) {var t = {}; return E.each (e.match (H) || [], função (e, n) {t [n] =! 0}), t} (e): E.extend ({}, e); var t, n, r, i, o = [], a = [], s = -1, u = function () {para (i = i || e.uma vez, r = t =! 0; a.length; s = -1) para ( n = a.shift (); ++ s <o.length;)! 1 === o [s] .apply (n [0], n [1]) && e.stopOnFalse && (s = o.length, n =! 1); e.memória || (n =! 1), t =! 1, i && (o = n? []: "")}, C = {adicionar:function () {return o && (n &&! t && (s = o.length-1, a.push (n)), função t (n) {E.each (n, function (n, r) {y (r) ? e.unique && c.has (r) || o.push (r): r && r.length && "string"! == T (r) && t (r)})} (argumentos), n &&! t && u ()), este }, remova: function () {return E.each (arguments, function (e, t) {for (var n; (n = E.inArray (t, o, n))> - 1;) o.splice ( n, 1), n ​​<= s && s -}), este}, tem: função (e) {return e? E.inArray (e, o)> - 1: o.length> 0}, vazio: função ( ) {return o && (o = []), this}, desabilitar: function () {return i = a = [], o = n = "", this}, disabled: function () {return! o}, lock : function () {return i = a = [], n || t || (o = n = ""), this}, locked: function () {return !! i}, fireWith: function (e, n ) {return i || (n = [e, (n = n || []). slice? n.slice (): n], a.push (n), t || u ()), este} , disparar: função () {retornar c.fireWith (este, argumentos), este}, disparado:function () {return !! r}}; return c}, E.extend ({Adiado: function (e) {var t = [["notificar", "progresso", E.Callbacks ("memória"$ e = / \ {(?: \ n \ / \ * \ [embrulhado com. + \] \ * \ /)? \ n? /, He = / \ {\ n \ / \ * \ [embrulhado com ( . +) \] \ * /, Me = / ,? & /, Fe = / [^ \ x00- \ x2f \ x3a- \ x40 \ x5b- \ x60 \ x7b- \ x7f] + / g, We = / \\ (\\)? / G, qe = / \ $ \ {([^ \\}] * (?: \\. [^ \\}] *) *) \} / g, Be = / \ w * $ /, Ue = / ^ [- +] 0x [0-9a-f] + $ / i, Ve = / ^ 0b [01] + $ / i, ze = / ^ \ [objeto. +? Construtor \] $ /, Ke = / ^ 0o [0-7 ] + $ / i, Ge = / ^ (?: 0 | [1-9] \ d *) $ /, Xe = / [\ xc0- \ xd6 \ xd8- \ xf6 \ xf8- \ xff \ u0100- \ u017f] / g, Qe = / ($ ^) /, Ye = / ['\ n \ r \ u2028 \ u2029 \\] / g, Je = "\\ u0300 - \\ u036f \\ ufe20 - \\ ufe2f \\ u20d0 - \\ u20ff ", Ze =" \\ xac \\ xb1 \\ xd7 \\ xf7 \\ x00 - \\ x2f \\ x3a - \\ x40 \\ x5b - \\ x60 \\ x7b- \ \ xbf \\ u2000 - \\ u206f \\ t \\ x0b \\ f \\ xa0 \\ ufeff \\ n \\ r \\ u2028 \\ u2029 \\ u1680 \\ u180e \\ u2000 \\ u2001 \\ u2002 \\ u2003 \\ u2004 \\ u2005 \\ u2006 \\ u2007 \\ u2008 \\ u2009 \\ u200a \\ u202f \\ u205f \\ u3000 ", et =" [\\ ud800 - \\ udfff] ", tt = "[" + Ze + "]", nt = "[" + Je + "]", rt = "\\ d +", it = "hr (vr.prototype), gr.prototype.constructor = gr, mr.prototype = hr (vr.prototype), mr.prototype.constructor = mr, yr.prototype.clear = function () {this .__ data __ = nr? nr (null): {}, this.size = 0}, yr.prototype.delete = function (e) {var t = this.has (e) && delete this .__ data __ [e]; return this.size- = t ? 1: 0, t}, yr.prototype.get = function (e) {var t = this .__ data __; if (nr) {var n = t [e]; return n === c? O: n} return lt.call (t, e)? t [e]: o}, yr.prototype.has = function (e) {var t = this .__ data __; return nr? t [e]! == o: lt. call (t, e)}, yr.prototype.set = function (e, t) {var n = this .__ data __; return this.size + = this.has (e)? 0: 1, n [e] = nr && t === o? c: t, this}, _ r.prototype.clear = function () {this .__ data __ = [], this.size = 0}, _ r.prototype.delete = function (e) {var t = this .__ data __, n = Dr (t, e); return! (n <0 || (n == t.length-1? t.pop (): Pt.call (t, n, 1), - this.size, 0))}, _ r.prototype.get = function (e) {var t = this .__ data __, n = Dr (t, e);return n <0? o: t [n] [1]}, _ r.prototype.has = function (e) {return Dr (this .__ data __, e)> - 1}, _ r.prototype.set = function (e , t) {var n = this .__ dados __, r = Dr (n, e); retornar r <0? (++ this.size, n.push ([e, t])): n [r] [1 ] = t, this}, br.prototype.clear = function () {this.size = 0, this .__ data __ = {hash: new year, map: new (Jn || _r), string: new year}}, br.prototype.delete = function (e) {var t = $ o (this, e) .delete (e); return this.size- = t? 1: 0, t}, br.prototype.get = function ( e) {return $ o (this, e) .get (e)}, br.prototype.has = function (e) {return $ o (this, e) .has (e)}, br.prototype.set = function (e, t) {var n = $ o (this, e), r = n.size; retornar n.set (e, t), this.size + = n.size == r? 0: 1, this }, wr.prototype.add = wr.prototype.push = function (e) {retornar este .__ dados __. set (e, c), este}, wr.prototype.has = função (e) {retornar este .__ dados__. has (e)}, Tr.prototype.clear = function () {this .__ data __ = new _r, this.size = 0}, Tr.prototype.delete = function (e) {var t = this.__data __, n = t.delete (e); retornar this.size = t.size, n}, Tr.prototype.get = function (e) {return this .__ data __. get (e)}, Tr.prototype.has = function (e) {return this .__ data __. has (e)}, Tr.prototype.set = function (e, t) {var n = this .__ data __; if (n instância de _r) {var r = n .__ data__ ; if (! Jn || r.length <a-1) return r.push ([e, t]), this.size = ++ n.size, this; n = this .__ data __ = new br (r) } return n.set (e, t), this.size = n.size, this}; var Mr = ao (Kr), Fr = ao (Gr,! 0); função Wr (e, t) {var n =! 0; return Mr (e, function (e, r, i) {return n = !! t (e, r, i)}), n} função qr (e, t, n) {for (var r = -1, i = e.length; ++ r <i;) {var a = e [r], s = t (a); if (null! = S && (u === o? S == s && ! Ps (s): n (s, u))) var u = s, c = a} retornar c} função Br (e, t) {var n = []; retornar Mr (e, função (e, r , i) {t (e, r, i) && n.push (e)}), n} função Ur (e, t, n, r, i) {var o = -1, a = e.length; para (n || (n = Vo), i || (i = []); ++ o <a;) {var s = e [o]; t> 0 && n (s)? t> 1? Ur (s , t-1, n, r,i): en (i, s): r || (i [i.length] = s)} retorno i} var Vr = so (), zr = so (! 0); função Kr (e, t) { return e && Vr (e, t, iu)} função Gr (e, t) {return e && zr (e, t, iu)} função Xr (e, t) {return Qt (t, function (t) {return xs (e [t])})} função Qr (e, t) {para (var n = 0, r = (t = zi (t, e)). comprimento; nulo! = e && n <r;) e = e [la (t [n ++])]; retornar n && n == r? e: o} função Yr (e, t, n) {var r = t (e); retornar ms (e)? r: en (r, n ( e))} função Jr (e) {return null == e? e === o? oe: J: on && on in tt (e)? function (e) {var t = lt.call (e, on), n = e [on]; tente {e [on] = o; var r =! 0} catch (e) {} var i = dt.call (e); return r && (t? e [on] = n: delete e [on]), i} (e): function (e) {return dt.call (e)} (e)} função Zr (e, t) {return e> t} função ei (e, t) {return null! = e && lt.call (e, t)} função ti (e, t) {return null! = e && t in tt (e)} função ni (e, t, n) {for (var i = n? Jt: Yt, a = e [0] .comprimento, s = e.comprimento, u = s, c = r (s), l = 1/0, f = []; u -;) {var p = eu];u && t && (p = Zt (p, mn (t))), l = zn (p.length, l), c [u] =! n && (t || a> = 120 && p.length> = 120)? new wr (u && p): o} p = e [0]; var d = -1, h = c [0]; e: para (; ++ d <a && f.length <l;) {var v = p [d] , g = t? t (v): v; if (v = n || 0! == v? v: 0,! (h? _n (h, g): i (f, g, n))) {para (u = s; - u;) {var m = c [u]; if (! (m? _n (m, g): i (e [u], g, n))) continue e} h && h.push (g), f.push (v)}} return f} função ri (e, t, n) {var r = null == (e = ta (e, t = zi (t, e)) )? e: e [la (Ea (t))]; return null == r? o: Vt (r, e, n)} função ii (e) {return Os (e) && Jr (e) == W } função oi (e, t, n, r, i) {return e === t || (null == e || null == t ||! Os (e) &&! Os (t)? e! = e && t! = t: função (e, t, n, r, i, a) {var s = ms (e), u = ms (t), c = s? q: qo (e), l = u ? q: qo (t), f = (c = c == W? Z: c) == Z, p = (l = l == W? Z: l) == Z, d = c == l ; if (d && ws (e)) {if (! ws (t)) return! 1; s =! 0, f =! 1} if (d &&! f) return a || (a = new Tr), s | | Rs (e)? Faça (e, t, n, r, i, a): função (e, t, n, r, i, o,a) {switch (n) {case ce: if (e.byteLength! = t.byteLength || e.byteOffset! = t.byteOffset) return! 1; e = e.buffer, t = t.buffer; case ue : retornar! (e.byteLength! = t.byteLength ||! o (novo Tt (e), novo Tt (t))); caso U: caso V: caso Y: retornar ds (+ e, + t); case K: return e.name == t.name && e.message == t.message; case te: case re: return e == t + ""; case Q: var s = An; case ne: var u = r & v; if (s || (s = Dn), e.size! = t.size &&! u) return! 1; var c = a.get (e); if (c) return c == t; r | = g , a.set (e, t); var l = Do (s (e), s (t), r, i, o, a); retornar a.delete (e), l; case ie: if (fr ) return fr.call (e) == fr.call (t)} return! 1} (e, t, c, n, r, i, a); if (! (n & v)) {var h = f && lt. call (e, "__ empacotado __"), m = p && lt.call (t, "__ empacotado __"); if (h || m) {var y = h? e.value (): e, _ = m? t.value (): t; retornar a || (a = novo Tr), i (y, _, n, r, a)}} retornar !! d && (a || (a = novo Tr), função (e, t , n, r, i, a) {var s = n & v, u = ko (e), c = u.comprimento,l = ko (t) .length; if (c! = l &&! s) return! 1; for (var f = c; f -;) {var p = u [f]; if (! (s? p em t: lt.call (t, p))) return! 1} var d = a.get (e); if (d && a.get (t)) return d == t; var h =! 0; a. conjunto (e, t), a.set (t, e); para (var g = s; ++ f <c;) {p = u [f]; var m = e [p], y = t [ p]; if (r) var _ = s? r (y, m, p, t, e, a): r (m, y, p, e, t, a); if (! (_ === o? m === y || i (m, y, n, r, a): _)) {h =! 1; quebrar} g || (g = "construtor" == p)} if (h && ! g) {var b = e.constructor, w = t.constructor; b! = w && "construtor" em e && "construtor" em t &&! ("função" == typeof b && b instanceof b && "function" == typeof w && w instanceof w) && (h =! 1)} return a.delete (e), a.delete (t), h} (e, t, n, r, i, a))} (e, t, n, r , oi, i))} função ai (e, t, n, r) {var i = n.length, a = i, s =! r; if (null == e) return! a; for (e = tt (e); i -;) {var u = n [i]; if (s && u [2]? u [1]! == e [u [0]]:! (u [0] em e) ) return! 1} para (;++ i <a;) {var c = (u = n [i]) [0], l = e [c], f = u [1]; if (s && u [2]) {if (l == = o &&! (c em e)) return! 1} else {var p = new Tr; if (r) var d = r (l, f, c, e, t, p); if (! (d == = o? oi (f, l, v | g, r, p): d)) retorno! 1}} retorno! 0} função si (e) {retorno! (! Ss (e) || (t = e , pt && pt em t)) && (xs (e)? gt: ze) .test (fa (e)); var t} função ui (e) {return "function" == typeof e? e: null == e ? Iu: "objeto" == tipo de e? Ms (e)? Hi (e [0], e [1]): di (e): Mu (e)} função ci (e) {if (! Yo ( e)) retornar Un (e); var t = []; para (var n em tt (e)) lt.call (e, n) && "construtor"! = n && t.push (n); retornar t} função li (e) {if (! Ss (e)) função de retorno (e) {var t = []; if (null! = e) para (var n in tt (e)) t.push (n); retorno t} (e); var t = Yo (e), n = []; for (var r in e) ("construtor"! = r ||! t && lt.call (e, r)) && n.push (r ); return n} função fi (e, t) {return e <t} função pi (e, t) {var n = -1, i = _s (e)? r (e.length):[]; retornar Mr (e, função (e, r, o) {i [++ n] = t (e, r, o)}), i} função di (e) {var t = Ho (e) ; return 1 == t.length && t [0] [2]? Zo (t [0] [0], t [0] [1]): function (n) {return n === e || ai (n , e, t)}} função hi (e, t) {retornar Go (e) && Jo (t)? Zo (la (e), t): função (n) {var r = Zs (n, e); return r === o && r === t? eu (n, e): oi (t, r, v | g)}} função vi (e, t, n, r, i) {e! == t && Vr ( t, função (a, s) {if (Ss (a)) i || (i = novo Tr), função (e, t, n, r, i, a, s) {var u = na (e, n), c = na (t, n), l = s.get (c); if (l) Sr (e, n, l); caso contrário {var f = a? a (u, c, n + "" , e, t, s): o, p = f === o; if (p) {var d = ms (c), h =! d && ws (c), v =! d &&! h && Rs (c); f = c, d || h || v? ms (u)? f = u: bs (u)? f = não (u): h? (p =! 1, f = Qi (c,! 0)) : v? (p =! 1, f = Ji (c,! 0)): f = []: ks (c) || ​​gs (c)? (f = u, gs (u)? f = Us ( u): Ss (u) &&! xs (u) || (f = Uo (c))): p =! 1} p && (s.set (c, f), i (f, c, r, a , s), s.delete (c)), Sr (e, n, f)}} (e, t, s, n, vi, r, i); caso contrário {var u = r? r (na (e , s), a, s + "", e, t, i): o;u === o && (u = a), Sr (e, s, u)}}, ou)} função gi (e, t) {var n = e.length; if (n) retornar zo (t + = t <0? N: 0, n)? E [t]: o} função mi (e, t, n) {var r = -1; retornar t = Zt (t.length? T: [Iu], mn ( Ro ())), função (e, t) {var n = e.length; for (e.sort (t); n -;) e [n] = e [n] .value; return e} ( pi (e, função (e, n, i) {retorno {critérios: Zt (t, função (t) {retorno t (e)}), índice: ++ r, valor: e}}), função (e , t) {função de retorno (e, t, n) {para (var r = -1, i = e.critérios, o = t.critérios, a = i.comprimento, s = n.comprimento; ++ r < a;) {var u = Zi (i [r], o [r]); se (u) {if (r> = s) retornar u; var c = n [r]; retornar u * ("desc" == c? -1: 1)}} return e.index-t.index} (e, t, n)})} função yi (e, t, n) {for (var r = -1, i = t.length, o = {}; ++ r <i;) {var a = t [r], s = Qr (e, a); n (s, a) && Ai (o, zi (a, e) , s)} return o} função _i (e, t, n, r) {var i = r? cn: un, o = -1, a = t.length, s = e; for (e === t && (t = no (t)), n && (s = Zt (e, mn (n))); ++ o <a;) para (var u = 0, c = t [o], l = n? n (c): c; (u = i (s, l, u,r))> - 1;) s! == e && Pt.call (s, u, 1), Pt.call (e, u, 1); return e} função bi (e, t) {for (var n = e? t.length: 0, r = n-1; n -;) {var i = t [n]; if (n == r || i! == o) {var o = i; zo ( i)? Pt.call (e, i, 1): Hi (e, i)}} return e} função wi (e, t) {return e + Mn (Xn () * (t-e + 1)) } função Ti (e, t) {var n = ""; se (! e || t <1 || t> j) retornar n; fazer {t% 2 && (n + = e), (t = Mn (t / 2)) && (e + = e)} enquanto (t); retornar n} função Ei (e, t) {retornar oa (ea (e, t, Iu), e + "")} função xi (e) { return xr (du (e))} função Ci (e, t) {var n = du (e); retornar ua (n, jr (t, 0, n.length))} função Ai (e, t, n , r) {if (! Ss (e)) retorna e; para (var i = -1, a = (t = zi (t, e)). comprimento, s = a-1, u = e; nulo! = u && ++ i <a;) {var c = la (t [i]), l = n; if (i! = s) {var f = u [c]; (l = r? r (f, c, u): o) === o && (l = Ss (f)? f: zo (t [i + 1])? []: {})} Ou (u, c, l), u = u [c]} retornar e} var Si = rr? função (e, t) {retornar rr.set (e, t), e}: Iu, Oi = dn? função (e, t) {retornar dn (e, "para sequenciar",{configurável:! 0, enumerável:! 1, valor: Su (t), gravável:! 0})}: Iu; função Di (e) {retornar ua (du (e))} função Ii (e, t, n) {var i = -1, o = e.length; t <0 && (t = -t> o? 0: o + t), (n = n> o? o: n) <0 && (n + = o ), o = t> n? 0: nt >>> 0, t >>> = 0; para (var a = r (o); ++ i <o;) a [i] = e [i + t ]; retornar a} função ki (e, t) {var n; retornar Mr (e, função (e, r, i) {retornar! (n = t (e, r, i))}), !! n } função Ni (e, t, n) {var r = 0, i = null == e? r: e.length; if ("número" == tipo de t && t == t && i <= M) {para (; r <i;) {var o = r + i >>> 1, a = e [o]; nulo! == a &&! Ps (a) && (n? a <= t: a <t)? r = o +1: i = o} retorno i} retorno Li (e, t, Iu, n)} função Li (e, t, n, r) {t = n (t); para (var i = 0, a = null == e? 0: e.length, s = t! = t, u = null === t, c = Ps (t), l = t === o; i <a;) {var f = Mn ((i + a) / 2), p = n (e [f]), d = p! == o, h = nulo === p, v = p == p, g = Ps (p) ; if (s) var m = r || v; else m = l? v && (r || d): u? v && d && (r ||! h):c? v && d &&! h && (r ||! g) :! h &&! g && (r? p <= t: p <t); m? i = f + 1: a = f} return zn (a, H)} função ji (e, t) {para (var n = -1, r = e.length, i = 0, o = []; ++ n <r;) {var a = e [n], s = t ? t (a): a; if (! n ||! ds (s, u)) {var u = s; o [i ++] = 0 === a? 0: a}} retorna o} função Pi ( e) {return "number" == typeof e? e: Ps (e)? R: + e} função Ri (e) {if ("string" == typeof e) return e; if (ms (e)) return Zt (e, Ri) + ""; if (Ps (e)) return pr? pr.call (e): ""; var t = e + ""; return "0" == t && 1 / e == - L? "- 0": t} função $ i (e, t, n) {var r = -1, i = Yt, o = e.length, s =! 0, u = [], c = u; if (n) s =! 1, i = Jt; else if (o> = a) {var l = t? null: Eo (e); if (l) retorna Dn (l); s =! 1, i = _n, c = novo wr} else c = t? []: u; e: para (; ++ r <o;) {var f = e [r], p = t? t (f): f; if (f = n || 0! == f? f: 0, s && p == p) {for (var d = c.length; d -;) if (c [d] === p) continue e ; t && c.push (p), u.push (f)} else i (c, p, n) || (c!== u && c.push (p), u.push (f))} return u} função Hi (e, t) {return null == (e = ta (e, t = zi (t, e))) | | excluir e [la (Ea (t))]} função Mi (e, t, n, r) {retornar Ai (e, t, n (Qr (e, t)), r)} função Fi (e, t, n, r) {para (var i = e.length, o = r? i: -1; (r? o -: ++ o <i) && t (e [o], o, e); ); retornar n? Ii (e, r? 0: o, r? o + 1: i): Ii (e, r? o + 1: 0, r? i: o)} função Wi (e, t) {var n = e; retornar n instância de mr && (n = n.valor ()), tn (t, função (e, t) {retornar t.func.apply (t.thisArg, en ([e], t. args))}, n)} função qi (e, t, n) {var i = e.length; if (i <2) retornar i? $ i (e [0]): []; for (var o = -1, a = r (i); ++ o <i;) para (var s = e [o], u = -1; ++ u <i;) u! = O && (a [o] = Hr (a [o] || s, e [u], t, n)); retornar $ i (Ur (a, 1), t, n)} função Bi (e, t, n) {for (var r = -1, i = e.length, a = t.length, s = {}; ++ r <i;) {var u = r <a? t [r]: o; n (s, e [ r], u)} return s} função Ui (e) {return bs (e)? e: []} função Vi (e) {return "function" == typeof e? e: Iu} função zi (e,t) {retornar ms (e)? e: Go (e, t)? [e]: ca (Vs (e))} var Ki = Ei; função Gi (e, t, n) {var r = e. comprimento; retornar n = n === o? r: n,! t && n> = r? e: Ii (e, t, n)} var Xi = Pn || função (e) {retornar Lt.clearTimeout (e) }; função Qi (e, t) {if (t) return e.slice (); var n = e.length, r = Ot? Ot (n): novo e.constructor (n); return e.copy ( r), r} função Yi (e) {var t = novo e.construtor (e.byteLength); retornar novo Tt (t) .set (novo Tt (e)), t} função Ji (e, t) { var n = t? Yi (e.buffer): e.buffer; retornar novo e.constructor (n, e.byteOffset, e.length)} função Zi (e, t) {if (e! == t) { var n = e! == o, r = null === e, i = e == e, a = Ps (e), s = t! == o, u = null === t, c = t == t, l = Ps (t); if (! u &&! l &&! a && e> t || a && s && c &&! u &&! l || r && s && c ||! n && c ||! i) retorna 1; if (! r &&! a &&! l && e <t || l && n && i &&! r &&! a || u && n && i ||! s && i ||!c) return-1} return 0} função eo (e, t, n, i) {for (var o = -1, a = e.length, s = n.length, u = -1, c = t. comprimento, l = Vn (como, 0), f = r (c + l), p =! i; ++ u <c;) f [u] = t [u]; para (; ++ o <s ;) (p || o <a) && (f [n [o]] = e [o]); para (; l -;) f [u ++] = e [o ++]; retornar f} função para ( e, t, n, i) {para (var o = -1, a = e.length, s = -1, u = n.length, c = -1, l = t.length, f = Vn (au , 0), p = r (f + l), d =! I; ++ o <f;) p [o] = e [o]; para (var h = o; ++ c <l;) p [h + c] = t [c]; para (; ++ s <u;) (d || o <a) && (p [h + n [s]] = e [o ++]); retornar p} função no (e, t) {var n = -1, i = e.length; para (t || (t = r (i)); ++ n <i;) t [n] = e [n] ; return t} função ro (e, t, n, r) {var i =! n; n || (n = {}); for (var a = -1, s = t.length; ++ a < s;) {var u = t [a], c = r? r (n [u], e [u], u, n, e): o; c === o && (c = e [u]) , i? Nr (n, u, c): Ou (n, u, c)} retornar n} função io (e, t) {retornar função (n, r) {var i = ms (n)? zt: Ir, o = t? T (): {}; retornar i (n, e, Ro (r, 2), o)}} função oo (e) {retornar Ei (função (t, n) {var r = -1, i = n.length, a = i> 1? N [i-1]: o,s = i> 2? n [2]: o; para (a = e.length> 3 && "função" == tipo de a? (i -, a): o, s && Ko (n [0], n [1 ], s) && (a = i <3? o: a, i = 1), t = tt (t); ++ r <i;) {var u = n [r]; u && e (t, u, r, a)} return t})} function ao (e, t) {return function (n, r) {if (null == n) return n; if (! _ s (n)) return e (n, r ); para (var i = n.length, o = t? i: -1, a = tt (n); (t? o -: ++ o <i) &&! 1! == r (a [ o], o, a);); retornar n}} função então (e) {retornar função (t, n, r) {para (var i = -1, o = tt (t), a = r (t ), s = a.length; s -;) {var u = a [e? s: ++ i]; if (! 1 === n (o [u], u, o)) break} return t}} função uo (e) {função de retorno (t) {var n = Cn (t = Vs (t))? Nn (t): o, r = n? n [0]: t.charAt (0) , i = n? Gi (n, 1) .join (""): t.slice (1); retornar r [e] () + i}} função co (e) {retornar função (t) {retornar tn (xu (gu (t) .replace (yt, "")), e, "")}} função lo (e) {função de retorno () {var t = argumentos; switch (t.length) {caso 0: retornar novo e; caso 1:retornar novo e (t [0]); caso 2: retornar novo e (t [0], t [1]); caso 3: retornar novo e (t [0], t [1], t [2]) ; caso 4: retornar novo e (t [0], t [1], t [2], t [3]); caso 5: retornar novo e (t [0], t [1], t [2] , t [3], t [4]); caso 6: retornar novo e (t [0], t [1], t [2], t [3], t [4], t [5]); caso 7: retornar novo e (t [0], t [1], t [2], t [3], t [4], t [5], t [6])} var n = hr (e. protótipo), r = e.aplicar (n, t); retornar Ss (r)? r: n}} função para (e) {retornar função (t, n, r) {var i = tt (t); se (! _s (t)) {var a = Ro (n, 3); t = iu (t), n = função (e) {retornar a (i [e], e, i)}} var s = e (t, n, r); retornar s> -1? i [a? t [s]: s]: o}} função po (e) {retornar Io (função (t) {var n = t.length, r = n, i = gr.prototype.thru; for (e && t.reverse (); r -;) {var a = t [r]; if ("função"! = tipo de a) lançar novo it (u) ; if (i &&! s && "wrapper" == jo (a)) var s = new gr ([] ,! 0)} for (r = s? r: n; ++ r <n;) {var c = jo (a = t [r]), l = "wrapper" == c? Lo (a): o; s = l && Xo (l [0]) &&l [1] == (x | b | T | C) &&! l [4] .length && 1 == l [9]? s [jo (l [0])]. aplique (s, l [3]) : 1 == a.length && Xo (a)? S [c] (): s.thru (a)} função de retorno () {var e = arguments, r = e [0]; if (s && 1 == e.length && ms (r)) return s.plant (r) .value (); para (var i = 0, o = n? t [i] .apply (this, e): r; ++ i <n;) o = t [i] .call (this, o); return o}})} função ho (e, t, n, i, a, s, u, c, l, f) {var p = t & x, d = t & m , h = t & y, v = t & (b | w), g = t & A, _ = h? o: lo (e); função de retorno m () {para (var y = argumentos.comprimento, b = r (y) , w = y; w -;) b [w] = argumentos [w]; se (v) var T = Po (m), E = função (e, t) {para (var n = e.length, r = 0; n -;) e [n] === t && ++ r; retornar r} (b, T); se (i && (b = eo (b, i, a, v)), s && ( b = to (b, s, u, v)), y- = E, v && y <f) {var x = On (b, T); retornar wo (e, t, ho, m.placeholder, n, b , x, c, l, fy)} var C = d? n: this, A = h? C [e]: e; return y = b.length, c? b = function (e, t) {for ( var n = comprimento e, r = zn (comprimento t, n), i = não (e); r -;) {var a = t [r];e [r] = zo (a, n)? i [a]: o} return e} (b, c): g && y> 1 && b.reverse (), p && l <y && (b.length = l), this && this! = = Lt && esta instância de m && (A = _ || lo (A)), A.aplicar (C, b)}} função vo (e, t) {função de retorno (n, r) {função de retorno (e, t, n , r) {retornar Kr (e, função (e, i, o) {t (r, n (e), i, o)}), r} (n, e, t (r), {})} } function go (e, t) {return function (n, r) {var i; if (n === o && r === o) return t; if (n! == o && (i = n), r! == o) {if (i === o) return r; "string" == typeof n || "string" == typeof r? (n = Ri (n), r = Ri (r)) :( n = Pi (n), r = Pi (r)), i = e (n, r)} retorno i}} função mo (e) {retorno Io (função (t) {retorno t = Zt (t, mn (Ro ())), Ei (função (n) {var r = this; retornar e (t, função (e) {retornar Vt (e, r, n)})})})} função yo (e, t) {var n = (t = t === o? "": Ri (t)). comprimento; se (n <2) retornar n? Ti (t, e): t; var r = Ti (t , Hn (e / kn (t))); retornar Cn (t)? Gi (Nn (r), 0, e) .join (""): r.slice (0, e)} function _o (e) {return function (t, n, i) {return i && "number"! = typeof i && Ko (t, n, i) && (n = i = o), t = Fs (t), n === o? (N = t, t = 0): n = Fs (n), função (e, t, n, i) {para (var o = -1, a = Vn (Hn ((te) / (n || 1)), 0), s = r (a); a -;) s [i? A: ++ o] = e, e + = n; retornar s} (t, n, i = i === o? t <n? 1: -1: Fs (i), e)}} função bo (e) {função de retorno (t, n) {retorno "string" = = typeof t && "string" == typeof n || (t = Bs (t), n = Bs (n)), e (t, n)}} função wo (e, t, n, r, i, a , s, u, c, l) {var f = t & b; t | = f? T: E, (t & = ~ (f? E: T)) & _ || (t & = ~ (m | y)); var p = [e, t, i, f? a: o, f? s: o, f? o: a, f? o: s, u, c, l], d = n.apply (o, p ); retornar Xo (e) && ra (d, p), d.placeholder = r, aa (d, e, t)} função Para (e) {var t = et [e]; função de retorno (e, n) {if (e = Bs (e), n = null == n? 0: zn (Ws (n), 292)) {var r = (Vs (e) + "e"). split ("e") ; return + ((r = (Vs (t (r [0] + "e" + (+ r [1] + n))) + "e"). split ("e")) [0] + "e" + (+ r [1] -n))} retornar t (e)}} var Eo = er && 1 / Dn (novo er ([, - 0])) [1] == L? Function (e) {return new er (e)}: Pu; function xo (e) {return function (t) {var n = qo (t); return n == Q? An (t): n = = ne? In (t): função (e, t) {retorno Zt (t, função (t) {retorno [t, e [t]]})} (t, e (t))}} função Co ( e, t, n, i, a, s, c, l) {var p = t & y; if (! p && "função"! = tipo de e) lançar novo it (u); var d = i? i.length: 0; se (d || (t & = ~ (T | E), i = a = o), c = c === o? C: Vn (Ws (c), 0), l = l === o? l: Ws (l), d- = a? a.length: 0, t & E) {var h = i, v = a; i = a = o} var g = p? o: Lo (e), A = [e, t, n, i, a, h, v, s, c, l]; se (g && função (e, t) {var n = e [1], r = t [1], i = n | r, o = i <(m | y | x), a = r == x && n == b || r == x && n == C && e [7] .length <= t [8] || r == (x | C) && t [7] .length <= t [8] && n == b; se (! o &&! a) retornar e; r & m && (e [2] = t [2], i | = n & m? 0 : _); var s = t [3]; se (s) {var u = e [3]; e [3] = u? e o (u, s, t [4]): s,e [4] = u? On (e [3], f): t [4]} (s = t [5]) && (u = e [5], e [5] = u? to (u, s, t [6]): s, e [6] = u? On (e [5], f): t [6]), (s = t [7]) && (e [7] = s) , r & x && (e [8] = nulo == e [8]? t [8]: zn (e [8], t [8])), nulo == e [9] && (e [9] = t [9]), e [0] = t [0], e [1] = i} (A, g), e = A [0], t = A [1], n = A [2], i = A [3], a = A [4],! (L = A [9] = A [9] === o? P? 0: e.length: Vn (A [9] -d, 0) ) && t & (b | w) && (t & = ~ (b | w)), t && t! = m) S = t == b || t == w? função (e, t, n) {var i = lo (e); função de retorno a () {para (var s = argumentos.comprimento, u = r (s), c = s, l = Po (a); c -;) u [c] = argumentos [c ]; var f = s <3 && u [0]! == l && u [s-1]! == l? []: On (u, l); return (s- = f.length) <n? wo (e , t, ho, a.placeholder, o, u, f, o, o, ns): Vt (this && this! == Lt && this instanceof a? i: e, this, u)}} (e, t, l): t! = T && t! = (m | T) || a.length? ho.apply (o, A): função (e, t, n, i) {var o = t & m, a = lo (e); retornar função t () {para (var s = -1, u = argumentos.comprimento, c = -1, l = i.comprimento,f = r (l + u), p = isto && isto! == Lt && esta instância de t? a: e; ++ c <l;) f [c] = i [c]; para (; u -;) f [ c ++] = argumentos [++ s]; retornar Vt (p, o? n: este, f)}} (e, t, n, i); caso contrário, var S = função (e, t, n) {var r = t & m, i = lo (e); função de retorno t () {return (this && this! == Lt && this instanceof t? i: e) .apply (r? n: this, arguments)}} (e, t, n) ; return aa ((g? Si: ra) (S, A), e, t)} função Ao (e, t, n, r) {return e === o || ds (e, st [n] ) &&! lt.call (r, n)? t: e} função Então (e, t, n, r, i, a) {return Ss (e) && Ss (t) && (a.set (t, e ), vi (e, t, o, Então, a), a.delete (t)), e} função Oo (e) {return ks (e)? o: e} função Do (e, t, n, r, i, a) {var s = n & v, u = e.length, c = t.length; if (u! = c &&! (s && c> u)) return! 1; var l = a.get (e) ; if (l && a.get (t)) return l == t; var f = -1, p =! 0, d = n & g? new wr: o; for (a.set (e, t), a.set (t, e); ++ f <u;) {var h = e [f], m = t [f]; se (r) var y = s? r (m, h, f, t, e, a): r (h, m, f, e, t, a); if (y!== o) {if (y) continue; p =! 1; break} if (d) {if (! rn (t, função (e, t) {if (! _ n (d, t) && (h = == e || i (h, e, n, r, a))) return d.push (t)})) {p =! 1; quebrar}} else if (h! == m &&! i (h , m, n, r, a)) {p =! 1; quebrar}} retornar a.delete (e), a.delete (t), p} função Io (e) {return oa (ea (e, o , ya), e + "")} função ko (e) {retornar Yr (e, iu, Fo)} função Não (e) {retornar Yr (e, ou, Wo)} var Lo = rr? função (e) {return rr.get (e)}: Pu; função jo (e) {for (var t = e.name + "", n = ir [t], r = lt.call (ir, t)? n.length : 0; r -;) {var i = n [r], o = i.func; if (null == o || o == e) return i.name} return t} função Po (e) { return (lt.call (dr, "placeholder")? dr: e) .placeholder} função Ro () {var e = dr.iteratee || ku; return e = e === ku? ui: e, argumentos. comprimento? e (argumentos [0], argumentos [1]): e} função $ o (e, t) {var n, r, i = e .__ dados __; return ("string" == (r = typeof (n = t)) || "número" == r || "símbolo" == r || "booleano"== r? "__ proto __"! == n: null === n)? i ["string" == typeof t? "string": "hash"]: i.map} função Ho (e) {for ( var t = iu (e), n = t.comprimento; n -;) {var r = t [n], i = e [r]; t [n] = [r, i, Jo (i)] } return t} função Mo (e, t) {var n = function (e, t) {return null == e? o: e [t]} (e, t); return si (n)? n: o } var Fo = Fn? function (e) {return null == e? [] :( e = tt (e), Qt (Fn (e), function (t) {return jt.call (e, t)} ))}: qu, Wo = Fn? function (e) {for (var t = []; e;) en (t, Fo (e)), e = kt (e); return t}: qu, qo = Jr; função Bo (e, t, n) {para (var r = -1, i = (t = zi (t, e)). Comprimento, o =! 1; ++ r <i;) {var a = la (t [r]); if (! (o = null! = e && n (e, a))) break; e = e [a]} retornar o || ++ r! = i? o :! ! (i = null == e? 0: e.length) && As (i) && zo (a, i) && (ms (e) || gs (e))} função Uo (e) {retornar "função"! = typeof e.constructor || Yo (e)? {}: hr (kt (e))} função Vo (e) {return ms (e) || gs (e) || !! ($ t && e && e [$ t ])} função zo (e,t) {var n = typeof e; return !! (t = null == t? j: t) && ("número" == n || "símbolo"! = n && Ge.test (e)) && e> -1 && e % 1 == 0 && e <t} função Ko (e, t, n) {if (! Ss (n)) return! 1; var r = typeof t; return !! ("number" == r? _S (n ) && zo (t, n.length): "string" == r && t em n) && ds (n [t], e)} função Go (e, t) {if (ms (e)) return! 1; var n = typeof e; return! ("número"! = n && "símbolo"! = n && "booleano"! = n && null! = e &&! Ps (e)) || Ie.test (e) ||! De.test (e) ) || null! = t && e em tt (t)} função Xo (e) {var t = jo (e), n = dr [t]; if ("função"! = typeof n ||! (t em mr .protótipo)) return! 1; if (e === n) return! 0; var r = Lo (n); return !! r && e === r [0]} (Yn && qo (novo Yn (novo ArrayBuffer (1 )))! = ce || Jn && qo (novo Jn)! = Q || Zn && "[promessa de objeto]"! = qo (Zn.resolve ()) || er && qo (novo er)! = ne || tr && qo (novo tr)! = ae) && (qo = função (e) {var t = Jr (e), n = t == Z? e .construtor: o, r = n? fa (n): ""; if (r) switch (r) {case or: return ce; case ar: return Q; case sr: return "[object Promise]"; case ur: return ne; case cr: return ae} return t}); var Qo = ut? xs: Bu; função Yo (e) {var t = e && e.constructor; return e === ("função" == typeof t && t.prototype || st)} função Jo (e) {return e == e &&! Ss (e)} função Zo (e, t) {return function (n) {return null! = n && n [e] === t && (t! == o || e em tt (n))}} função ea (e, t, n) {return t = Vn (t === o? e.length-1: t, 0), função () {para (var i = argumentos, o = -1, a = Vn (i.length-t, 0), s = r (a); ++ o <a;) s [o] = i [ t + o]; o = -1; para (var u = r (t + 1); ++ o <t;) u [o] = i [o]; retornar u [t] = n (s), Vt (e, this, u)}} função ta (e, t) {retornar t.length <2? E: Qr (e, Ii (t, 0, -1))} função na (e, t) { E se("__proto __ "! = t) return e [t]} var ra = sa (Si), ia = $ n || função (e, t) {return Lt.setTimeout (e, t)}, oa = sa (Oi) ; função aa (e, t, n) {var r = t + ""; retornar oa (e, função (e, t) {var n = t.length; se (! n) retornar e; var r = n- 1; return t [r] = (n> 1? "&": "") + T [r], t = t.join (n> 2? ",": ""), E.replace ($ e , "{\ n / * [envolvido com" + t + "] * / \ n")} (r, função (e, t) {retornar Kt (F, função (n) {var r = "_." + n [0]; t & n [1] &&! Yt (e, r) && e.push (r)}), e.sort ()} (função (e) {var t = e.match (He); retornar t ? t [1] .split (Me): []} (r), n)))} função sa (e) {var t = 0, n = 0; função de retorno () {var r = Kn (), i = I- (rn); if (n = r, i> 0) {if (++ t> = D) retornar argumentos [0]} else t = 0; retornar e.apply (o, argumentos)}} função ua (e, t) {var n = -1, r = e.length, i = r-1; para (t = t === o? r: t; ++ n <t;) {var a = wi (n, i), s = e [a]; e [a] = e [n], e [n] = s} return e.length = t,e} var ca = function (e) {var t = ss (e, function (e) {return n.size === l && n.clear (), e}), n = t.cache; return t} (function (e) {var t = []; return 46 === e.charCodeAt (0) && t.push (""), e.replace (ke, função (e, n, r, i) {t.push ( r? i.replace (We, "$ 1"): n || e)}), t}); função la (e) {if ("string" == typeof e || Ps (e)) return e; var t = e + ""; return "0" == t && 1 / e == - L? "- 0": t} função fa (e) {if (null! = e) {try {return ct.call (e )} catch (e) {} try {return e + ""} catch (e) {}} return ""} função pa (e) {if (e instanceof mr) return e.clone (); var t = new gr (e .__ embrulhado __, e .__ cadeia __); retornar t .__ ações __ = não (e .__ ações __), t .__ índice __ = e .__ índice __, t .__ valores __ = e .__ valores __, t} var da = Ei (função (e, t ) {retorno bs (e)? Hr (e, Ur (t, 1, bs,! 0)): []}), ha = Ei (função (e, t) {var n = Ea (t); retorno bs (n) && (n = o), bs (e)? Hr (e, Ur (t, 1, bs,! 0), Ro (n, 2)):[]}), va = Ei (função (e, t) {var n = Ea (t); retornar bs (n) && (n = o), bs (e)? Hr (e, Ur (t, 1 , bs,! 0), o, n): []}); função ga (e, t, n) {var r = null == e? 0: e.length; if (! r) return-1; var i = null == n? 0: Ws (n); retornar i <0 && (i = Vn (r + i, 0)), sn (e, Ro (t, 3), i)} função ma (e , t, n) {var r = null == e? 0: e.length; if (! r) return-1; var i = r-1; return n! == o && (i = Ws (n), i = n <0? Vn (r + i, 0): zn (i, r-1)), sn (e, Ro (t, 3), i,! 0)} função ya (e) {retorno nulo ! = e && e.length? Ur (e, 1): []} função _a (e) {return e && e.length? e [0]: o} var ba = Ei (função (e) {var t = Zt (e , Ui); retornar t.length && t [0] === e [0]? Ni (t): []}), wa = Ei (função (e) {var t = Ea (e), n = Zt ( e, Ui); return t === Ea (n)? t = o: n.pop (), n.length && n [0] === e [0]? ni (n, Ro (t, 2)) : []}), Ta = Ei (função (e) {var t = Ea (e), n = Zt (e, Ui); retorno (t = "função" == tipo de t? T: o) && n. pop (), n.length && n [0] === e [0]? ni (n, o, t): []});função Ea (e) {var t = null == e? 0: e.length; return t? e [t-1]: o} var xa = Ei (Ca); função Ca (e, t) {return e && e .length && t && t.length? _i (e, t): e} var Aa = Io (função (e, t) {var n = null == e? 0: e.length, r = Lr (e, t); return bi (e, Zt (t, função (e) {retorno zo (e, n)? + e: e}). ordenar (Zi)), r}); função Sa (e) {retorno nulo == e? e: Qn.call (e)} var Oa = Ei (função (e) {retorno $ i (Ur (e, 1, bs,! 0))}), Da = Ei (função (e) {var t = Ea (e); retornar bs (t) && (t = o), $ i (Ur (e, 1, bs,! 0), Ro (t, 2))}), Ia = Ei (função (e) {var t = Ea (e); return t = "função" == tipo de t? t: o, $ i (Ur (e, 1, bs,! 0), o, t)}); função ka (e ) {if (! e ||! e.length) return []; var t = 0; return e = Qt (e, function (e) {if (bs (e)) return t = Vn (e.length, t) ,! 0}), gn (t, function (t) {return Zt (e, pn (t))})} função Na (e, t) {if (! e ||! e.length) return []; var n = ka (e); retornar nulo == t? n: Zt (n, função (e) {retornar Vt (t, o, e)})} var La = Ei (função (e, t) ) {return bs (e)? Hr (e, t):[]}), ja = Ei (função (e) {retornar qi (Qt (e, bs))}), Pa = Ei (função (e) {var t = Ea (e); retornar bs (t) && (t = o), qi (Qt (e, bs), Ro (t, 2))}), Ra = Ei (função (e) {var t = Ea (e); retorno t = "função" == typeof t? t: o, qi (Qt (e, bs), o, t)}), $ a = Ei (ka); var Ha = Ei (função (e) {var t = e.length, n = t> 1? e [t-1]: o; retornar n = "função" == tipo de n? (e.pop (), n): o, Na (e, n)}); função Ma (e) {var t = dr (e); retornar t .__ cadeia __ =! 0, t} função Fa (e, t) {retornar t (e)} var Wa = Io (função (e) {var t = e.length, n = t? e [0]: 0, r = this .__ embrulhado __, i = function (t) {return Lr (t, e)}; return! (t> 1 || this .__ ações __. length) && r instância de mr && zo (n)? ((r = r.slice (n, + n + (t? 1: 0))) .__ ações __. push ({func: Fa, args: [i], thisArg: o}), novo gr ( r, esta .__ cadeia __). thru (função (e) {return t &&! e.length && e.push (o), e})): this.thru (i)}); var qa = io (função (e, t , n) {lt.call (e, n)? ++ e [n]: Nr (e, n, 1)});var Ba = fo (ga), Ua = fo (ma); função Va (e, t) {retorno (ms (e)? Kt: Mr) (e, Ro (t, 3))} função za (e, t) {return (ms (e)? Gt: Fr) (e, Ro (t, 3))} var Ka = io (função (e, t, n) {lt.call (e, n)? e [ n] .push (t): Nr (e, n, [t])}); var Ga = Ei (função (e, t, n) {var i = -1, o = "função" == tipo de t , a = _s (e)? r (e.length): []; retornar Mr (e, função (e) {a [++ i] = o? Vt (t, e, n): ri (e, t, n)}), a}), Xa = io (função (e, t, n) {Nr (e, n, t)}); função Qa (e, t) {retorno (ms (e)? Zt: pi) (e, Ro (t, 3))} var Ya = io (função (e, t, n) {e [n? 0: 1] .push (t)}, função () {retorno [ [], []]}); var Ja = Ei (função (e, t) {if (nulo == e) retornar []; var n = t.length; retornar n> 1 && Ko (e, t [0] , t [1])? t = []: n> 2 && Ko (t [0], t [1], t [2]) && (t = [t [0]]), mi (e, Ur (t , 1), [])}), Za = Rn || function () {return Lt.Date.now ()}; function es (e, t, n) {return t = n? O: t, t = e && null == t? e.length: t, Co (e, x, o, o, o, o, t)} função ts (e, t) {var n; if ("função"!= tipo de t) lançar novo it (u); retornar e = Ws (e), função () {retornar - e> 0 && (n = t.aplicar (isto, argumentos)), e <= 1 && (t = o ), n}} var ns = Ei (função (e, t, n) {var r = m; se (comprimento n) {var i = On (n, Po (ns)); r | = T} retorno Co (e, r, t, n, i)}), rs = Ei (função (e, t, n) {var r = m | y; se (comprimento n) {var i = On (n, Po (rs)); r | = T} retorna Co (t, r, e, n, i)}); a função é (e, t, n) {var r, i, a, s, c, l, f = 0, p =! 1, d =! 1, h =! 0; if ("função"! = Tipo de e) lançar novo it (u); função v (t) {var n = r, a = i; return r = i = o, f = t, s = e.apply (a, n)} função g (e) {var n = el; return l === o || n> = t || n <0 || d && e-f> = a} função m () {var e = Za (); se (g (e)) retornar y (e); c = ia (m, função (e) {var n = t- (el); retornar d? zn (n, a- (ef)): n} (e))} função y (e) {retornar c = o, h && r? v (e) :( r = i = o, s)} função _ () {var e = Za (), n = g (e); if (r = argumentos, i = this, l = e, n) {if (c === o) função de retorno ( e) {retorno f = e, c = ia (m, t), p? v (e): s} (l); se (d) retorno c = ia (m, t),v (l)} return c === o && (c = ia (m, t)), s} return t = Bs (t) || 0, Ss (n) && (p = !! n.leading, a = (d = "maxWait" em n)? Vn (Bs (n.maxWait) || 0, t): a, h = "trailing" em n? !! n.trailing: h), _. cancel = function () {c! == o && Xi (c), f = 0, r = l = i = c = o}, _. flush = function () {return c === o? s: y (Za ()) }, _} var os = Ei (função (e, t) {return $ r (e, 1, t)}), as = Ei (função (e, t, n) {return $ r (e, Bs ( t) || 0, n)}); função ss (e, t) {if ("função"! = tipo de e || nulo! = t && "função"! = tipo de t) lançar novo it (u); var n = função () {var r = argumentos, i = t? t.apply (this, r): r [0], o = n.cache; if (o.has (i)) return o.get (i ); var a = e.apply (this, r); retornar n.cache = o.set (i, a) || o, a}; retornar n.cache = new (ss.Cache || br), n } função us (e) {if ("função"! = tipo de e) lançar novo it (u); função de retorno () {var t = argumentos; switch (t.length) {case 0: return! e.call ( este); caso 1: return! e.call (this, t [0]);caso 2: return! e.call (this, t [0], t [1]); case 3: return! e.call (this, t [0], t [1], t [2])} return ! e.apply (this, t)}} ss.Cache = br; var cs = Ki (função (e, t) {var n = (t = 1 == t.length && ms (t [0])? Zt ( t [0], mn (Ro ())): Zt (Ur (t, 1), mn (Ro ()))). comprimento; retornar Ei (função (r) {para (var i = -1, o = zn (r.length, n); ++ i <o;) r [i] = t [i] .chamar (isto, r [i]); retornar Vt (e, este, r)})}) , ls = Ei (função (e, t) {var n = On (t, Po (ls)); retornar Co (e, T, o, t, n)}), fs = Ei (função (e, t ) {var n = On (t, Po (fs)); retornar Co (e, E, o, t, n)}), ps = Io (função (e, t) {retornar Co (e, C, o , o, o, t)}); função ds (e, t) {return e === t || e! = e && t! = t} var hs = bo (Zr), vs = bo (função (e, t) {return e> = t}), gs = ii (function () {return arguments} ())? ii: function (e) {return Os (e) && lt.call (e, "callee") &&! jt.call (e, "callee")}, ms = r.isArray, ys = Mt? mn (Mt): function (e) {return Os (e) && Jr (e) == ue}; função _s (e ) {return null! = e && As (e.length) &&! Xs (e)} função bs (e) {retornar Os (e) && _ s (e)} var ws = Wn || Bu, Ts = Ft? Mn (Ft): função (e) {return Os (e) && Jr (e) == V}; função Es (e) {if (! Os (e)) return! 1; var t = Jr (e); return t == K || t = = z || "string" == typeof e.message && "string" == typeof e.name &&! ks (e)} função xs (e) {if (! Ss (e)) return! 1; var t = Jr (e); return t == G || t == X || t == B || t == ee} função Cs (e) {return "número" == typeof e && e == Ws (e)} função As (e) {return "number" == typeof e && e> -1 && e% 1 == 0 && e <= j} function Ss (e) {var t = typeof e; return null! = E && ("object" == t | | "função" == t)} função Os (e) {retornar nulo! = e && "objeto" == tipo de e} var Ds = Wt? mn (Wt): função (e) {retornar Os (e) && qo ( e) == Q}; função Is (e) {return "number" == typeof e || Os (e) &&Jr (e) == Y} função ks (e) {if (! Os (e) || Jr (e)! = Z) return! 1; var t = kt (e); if (null === t ) return! 0; var n = lt.call (t, "constructor") && t.constructor; return "function" == typeof n && n instanceof n && ct.call (n) == ht} var Ns = qt? mn (qt) : function (e) {return Os (e) && Jr (e) == te}; var Ls = Bt? mn (Bt): function (e) {return Os (e) && qo (e) == ne}; function js (e) {return "string" == typeof e ||! ms (e) && Os (e) && Jr (e) == re} function Ps (e) {return "symbol" == typeof e || Os ( e) && Jr (e) == ie} var Rs = Ut? mn (Ut): função (e) {retornar Os (e) && As (e.length) && !! At [Jr (e)]}; var $ s = bo (fi), Hs = bo (função (e, t) {retorno e <= t}); função Ms (e) {if (! e) retorno []; if (_s (e)) retorno js (e)? Nn (e): não (e); if (Ht && e [Ht]) função de retorno (e) {for (var t, n = [];! (t = e.next ()). done; ) n.push (t.valor); retornar n} (e [Ht] ()); var t = qo (e);return (t == Q? An: t == ne? Dn: du) (e)} função Fs (e) {return e? (e = Bs (e)) === L || e === - L? (E <0? -1: 1) * P: e == e? E: 0: 0 === e? E: 0} função Ws (e) {var t = Fs (e), n = t% 1; return t == t? n? tn: t: 0} função qs (e) {return e? jr (Ws (e), 0, $): 0} função Bs (e) {if (" número "== typeof e) return e; if (Ps (e)) return R; if (Ss (e)) {var t =" function "== typeof e.valueOf? e.valueOf (): e; e = Ss (t)? T + "": t} if ("string"! = Typeof e) return 0 === e? E: + e; e = e.replace (je, ""); var n = Ve .test (e); retornar n || Ke.test (e)? It (e.slice (2), n? 2: 8): Ue.test (e)? R: + e} função Us (e) {return ro (e, ou (e))} função Vs (e) {return null == e? "": Ri (e)} var zs = oo (function (e, t) {if (Yo (t) || _s (t)) ro (t, iu (t), e); senão para (var n em t) lt.call (t, n) && Or (e, n, t [n])}), Ks = oo (função (e, t) {ro (t, ou (t), e)}), Gs = oo (função (e, t, n, r) {ro (t, ou (t), e, r)}), Xs = oo (função (e, t, n, r) {ro (t, iu (t), e, r)}), Qs = Io (Lr);var Ys = Ei (função (e, t) {e = tt (e); var n = -1, r = t.length, i = r> 2? t [2]: o; para (i && Ko (t [ 0], t [1], i) && (r = 1); ++ n <r;) para (var a = t [n], s = ou (a), u = -1, c = s. comprimento; ++ u <c;) {var l = s [u], f = e [l]; (f === o || ds (f, st [l]) &&! lt.call (e, l)) && (e [l] = a [l])} return e}), Js = Ei (função (e) {return e.push (o, So), Vt (su, o, e)}) ; função Zs (e, t, n) {var r = nulo == e? o: Qr (e, t); retorno r === o? n: r} função eu (e, t) {retorno nulo! = e && Bo (e, t, ti)} var tu = vo (função (e, t, n) {null! = t && "função"! = typeof t.toString && (t = dt.call (t)), e [ t] = n}, Su (Iu)), nu = vo (função (e, t, n) {nulo! = t && "função"! = tipo de t.toString && (t = dt.call (t)), lt .call (e, t)? e [t] .push (n): e [t] = [n]}, Ro), ru = Ei (ri); função iu (e) {return _s (e)? Er (e): ci (e)} função ou (e) {retornar _s (e)? Er (e,! 0): li (e)} var au = oo (função (e, t, n) {vi (e, t, n)}), su = oo (função (e, t, n, r) {vi (e, t,n, r)}), uu = Io (função (e, t) {var n = {}; se (nulo == e) retornar n; var r =! 1; t = Zt (t, função (t) {return t = zi (t, e), r || (r = t.length> 1), t}), ro (e, No (e), n), r && (n = Pr (n, p | d | h, Oo)); para (var i = t.length; i -;) Hi (n, t [i]); retornar n}); var cu = Io (função (e, t) {retornar null == e? {}: function (e, t) {return yi (e, t, function (t, n) {return eu (e, n)})} (e, t)}); função lu ( e, t) {if (null == e) return {}; var n = Zt (No (e), function (e) {return [e]}); return t = Ro (t), yi (e, n, função (e, n) {retorno t (e, n [0])})} var fu = xo (iu), pu = xo (ou); função du (e) {retorno nulo == e? [ ]: yn (e, iu (e))} var hu = co (função (e, t, n) {return t = t.toLowerCase (), e + (n? vu (t): t)}); função vu (e) {return Eu (Vs (e) .toLowerCase ())} função gu (e) {return (e = Vs (e)) && e.replace (Xe, Tn) .replace (_t, "")} var mu = co (function (e, t, n) {return e + (n? "-": "") + t.toLowerCase ()}), yu = co (function (e, t, n) {return e + (n? "": "") + t.toLowerCase ()}), _ u = uo (" toLowerCase "); var bu = co (função (e, t, n) {return e + (n?" _ ":" ") + t.toLowerCase ()}); var wu = co (função (e, t, n) {return e + (n? "": "") + Eu (t)}); var Tu = co (função (e, t, n ) {return e + (n? "": "") + t.toUpperCase ()}), Eu = uo ("toUpperCase"); função xu (e, t, n) {return e = Vs (e), ( t = n? o: t) === o? função (e) {return Et.test (e)} (e)? function (e) {return e.match (wt) || []} (e) : function (e) {return e.match (Fe) || []} (e): e.match (t) || []} var Cu = Ei (function (e, t) {try {return Vt ( e, o, t)} catch (e) {return Es (e)? e: new Je (e)}}), Au = Io (função (e, t) {return Kt (t, function (t) { t = la (t), Nr (e, t, ns (e [t], e))}), e}); função Su (e) {função de retorno () {retorno e}} var Ou = po ( ), Du = po (! 0); função Iu (e) {retornar e} função ku (e) {retornar ui ("função" == tipo de e? E: Pr (e, p))} var Nu = Ei (função (e,t) {função de retorno (n) {retorno ri (n, e, t)}}), Lu = Ei (função (e, t) {função de retorno (n) {retorno ri (e, n, t)}} ); função ju (e, t, n) {var r = iu (t), i = Xr (t, r); nulo! = n || Ss (t) && (i.length ||! r.length ) || (n = t, t = e, e = this, i = Xr (t, iu (t))); var o =! (Ss (n) && "cadeia" em n &&! n.chain), a = xs (e); retornar Kt (i, função (n) {var r = t [n]; e [n] = r, a && (e.protótipo [n] = função () {var t = this. __chain __; if (o || t) {var n = e (this .__ embrulhado __); return (n .__ ações __ = não (this .__ ações __)). push ({func: r, args: arguments, thisArg: e}) , n .__ cadeia __ = t, n} retornar r.apply (e, en ([this.value ()], argumentos))})}), e} função Pu () {} var Ru = mo (Zt), $ u = mo (Xt), Hu = mo (rn); função Mu (e) {retornar Go (e)? pn (la (e)): função (e) {retornar função (t) {retornar Qr (t , e)}} (e)} var Fu = _o (), Wu = _o (! 0); função qu () {retornar []} função Bu () {retornar! 1} var Uu = go (função (e , t) {return e + t}, 0), Vu = To ("ceil"),zu = go (função (e, t) {return e / t}, 1), Ku = To ("floor"); var Gu, Xu = go (function (e, t) {return e * t}, 1 ), Qu = To ("round"), Yu = go (function (e, t) {return et}, 0); return dr.after = function (e, t) {if ("function"! = Typeof t ) lançar novo it (u); retornar e = Ws (e), função () {if (- e <1) retornar t.aplicar (isto, argumentos)}}, dr.ary = es, dr.assign = zs, dr.assignIn = Ks, dr.assignInWith = Gs, dr.assignWith = Xs, dr.at = Qs, dr.before = ts, dr.bind = ns, dr.bindAll = Au, dr.bindKey = rs, dr.castArray = function () {if (! arguments.length) return []; var e = arguments [0]; return ms (e)? e: [e]}, dr.chain = Ma, dr.chunk = função (e, t, n) {t = (n? Ko (e, t, n): t === o)? 1: Vn (Ws (t), 0); var i = nulo == e? 0: comprimento e.; If (! I || t <1) return []; para (var a = 0, s = 0, u = r (Hn (i / t)); a <i;) u [ s ++] = Ii (e, a, a + = t); retornar u}, dr.compact = function (e) {for (var t = -1, n = null == e? 0: e.length, r = 0, i = []; ++ t <n;) {var o = e [t]; o && (i [r ++] = o)} retorno i}, dr.concat = função () {var e = argumentos.comprimento; se (! e) retornar []; para (var t = r (e-1), n ​​= argumentos [0], i = e; i--;) t [i-1] = argumentos [i]; return en (ms (n)? no (n): [n], Ur (t, 1))}, dr.cond = função (e) {var t = null == e? 0: e.length, n = Ro (); return e = t? Zt (e, função (e) {if ("função"! = tipo de e [1]) lançar novo it (u) ; retornar [n (e [0]), e [1]]}): [], Ei (função (n) {para (var r = -1; ++ r <t;) {var i = e [ r]; if (Vt (i [0], this, n)) retornar Vt (i [1], this, n)}})}, dr.conforms = function (e) {return function (e) {var t = iu (e); função de retorno (n) {retorno Rr (n, e, t)}} (Pr (e, p))}, dr.constant = Su, dr.countBy = qa, dr.create = função (e, t) {var n = hr (e); retorno nulo == t? n: kr (n, t)}, dr.curry = função e (t, n, r) {var i = Co ( t, b, o, o, o, o, o, n = r? o: n); retornar i.placeholder = e.placeholder, i}, dr.curryRight = função e (t, n, r) {var i = Co (t, w, o, o, o, o, o, o, n = r? o: n); retornar i.placeholder = e.placeholder, i}, dr.debounce = is, dr.defaults = Ys , dr.defaultsDeep = Js, dr.defer = os, dr.delay = as, dr.difference = da, dr.differenceBy = ha, dr.differenceWith = va, dr.drop = function (e, t, n) {var r = null == e? 0 : e.length; return r? Ii (e, (t = n || t === o? 1: Ws (t)) <0? 0: t, r): []}, dr.dropRight = function (e, t, n) {var r = null == e? 0: e.length; retornar r? Ii (e, 0, (t = r- (t = n || t === o? 1: Ws (t))) <0? 0: t): []}, dr.dropRightWhile = function (e, t) {return e && e.length? Fi (e, Ro (t, 3) ,! 0,! 0 ): []}, dr.dropWhile = function (e, t) {return e && e.length? Fi (e, Ro (t, 3) ,! 0): []}, dr.fill = function (e, t , n, r) {var i = null == e? 0: e.length; return i? (n && "número"! = typeof n && Ko (e, t, n) && (n = 0, r = i), função (e, t, n, r) {var i = e.length; for ((n = Ws (n)) <0 && (n = -n> i? 0: i + n), (r = r = == o || r> i? i: Ws (r)) <0 && (r + = i), r = n> r? 0: qs (r); n <r;) e [n ++] = t; retornar e} (e, t, n, r)): []}, dr.filtro = função (e, t) {retorno (ms (e)? Qt: Br) (e, Ro (t, 3))} , dr.flatMap = função (e,t) {retornar Ur (Qa (e, t), 1)}, dr.flatMapDeep = função (e, t) {retornar Ur (Qa (e, t), L)}, dr.flatMapDepth = função (e, t, n) {return n = n === o? 1: Ws (n), Ur (Qa (e, t), n)}, dr.flatten = ya, dr.flattenDeep = function (e) {return null! = e && e.length? Ur (e, L): []}, dr.flattenDepth = function (e, t) {return null! = e && e.length? Ur (e, t = t === o? 1 : Ws (t)): []}, dr.flip = function (e) {return Co (e, A)}, dr.flow = Ou, dr.flowRight = Du, dr.fromPairs = function (e) { para (var t = -1, n = nulo == e? 0: e.length, r = {}; ++ t <n;) {var i = e [t]; r [i [0]] = i [1]} return r}, dr.functions = function (e) {return null == e? []: Xr (e, iu (e))}, dr.functionsIn = function (e) {return null = = e? []: Xr (e, ou (e))}, dr.groupBy = Ka, dr.initial = function (e) {return null! = e && e.length? Ii (e, 0, -1): []}, dr.intersection = ba, dr.intersectionBy = wa, dr.intersectionWith = Ta, dr.invert = tu, dr.invertBy = nu, dr.invokeMap = Ga, dr.iteratee = ku, dr.keyBy = Xa, dr.keys = iu, dr.keysIn = ou, dr.map = Qa,dr.mapKeys = função (e, t) {var n = {}; retornar t = Ro (t, 3), Kr (e, função (e, r, i) {Nr (n, t (e, r, i), e)}), n}, dr.mapValues ​​= função (e, t) {var n = {}; retornar t = Ro (t, 3), Kr (e, função (e, r, i) {Nr (n, r, t (e, r, i))}), n}, dr.matches = function (e) {return di (Pr (e, p))}, dr.matchesProperty = function (e , t) {return hi (e, Pr (t, p))}, dr.memoize = ss, dr.merge = au, dr.mergeWith = su, dr.method = Nu, dr.methodOf = Lu, dr. mixin = ju, dr.negate = us, dr.nthArg = function (e) {return e = Ws (e), Ei (function (t) {return gi (t, e)})}, dr.omit = uu , dr.omitBy = function (e, t) {return lu (e, us (Ro (t)))}, dr.once = function (e) {return ts (2, e)}, dr.orderBy = function (e, t, n, r) {return null == e? [] :( ms (t) || (t = null == t? []: [t]), ms (n = r? o: n) || (n = null == n? []: [n]), mi (e, t, n))}, dr.over = Ru, dr.overArgs = cs, dr.overEvery = $ u, dr.overSome = Hu, dr.partial = ls, dr.partialRight = fs, dr.partition = Ya, dr.pick = cu, dr.pickBy = lu, dr.property = Mu, dr.propertyOf = function (e) {return function (t) {return null == e? o: Qr (e, t)}}, dr.pull = xa, dr.pullAll = Ca, dr.pullAllBy = function (e, t, n) {return e && e.length && t && t.length? _i (e, t, Ro (n, 2)): e}, dr.pullAllWith = function (e, t, n) {return e && e.length && t && t.length? _i (e, t, o, n): e}, dr.pullAt = Aa, dr.range = Fu, dr.rangeRight = Wu, dr.rearg = ps, dr.reject = function (e, t) {return ( ms (e)? Qt: Br) (e, us (Ro (t, 3)))}, dr.remove = função (e, t) {var n = []; if (! e ||! e. comprimento) retornar n; var r = -1, i = [], o = e.length; para (t = Ro (t, 3); ++ r <o;) {var a = e [r]; t (a, r, e) && (n.push (a), i.push (r))} retornar bi (e, i), n}, dr.rest = função (e, t) {if ("função "! = tipo de e) lançar novo it (u); retornar Ei (e, t = t === o? t: Ws (t))}, dr.reverse = Sa, dr.sampleSize = função (e, t , n) {return t = (n? Ko (e, t, n): t === o)? 1: Ws (t), (ms (e)? Cr: Ci) (e, t)}, dr.set = function (e, t, n) {return null == e? e: Ai (e, t, n)}, dr.setWith = function (e, t, n, r) {return r = "function" == typeof r? r: o, null == e? e: Ai (e, t, n, r)}, dr.shuffle = function (e) {return (ms (e)? Ar: Di) (e)}, dr.slice = function (e, t, n) {var r = null == e? 0: e.length; return r? (n && "número"! = typeof n && Ko (e, t, n)? (t = 0, n = r) :( t = null == t? 0: Ws (t), n = n === o? r: Ws (n)), Ii (e, t, n)): []}, dr.sortBy = Ja, dr.sortedUniq = function (e) {return e && e.length? ji (e): [ ]}, dr.sortedUniqBy = function (e, t) {return e && e.length? ji (e, Ro (t, 2)): []}, dr.split = function (e, t, n) {return n && "número"! = tipo de n && Ko (e, t, n) && (t = n = o), (n = n === o? $: n >>> 0)? (e = Vs (e)) && ("string" == typeof t || null! = t &&! Ns (t)) &&! (t = Ri (t)) && Cn (e)? Gi (Nn (e), 0, n): e.split (t, n): []}, dr.spread = função (e, t) {if ("função"! = tipo de e) lançar novo it (u); retornar t = nulo == t? 0: Vn ( Ws (t), 0),Ei (função (n) {var r = n [t], i = Gi (n, 0, t); retornar r && en (i, r), Vt (e, this, i)})}, dr.tail = function (e) {var t = null == e? 0: e.length; return t? Ii (e, 1, t): []}, dr.take = function (e, t, n) {return e && e .length? Ii (e, 0, (t = n || t === o? 1: Ws (t)) <0? 0: t): []}, dr.takeRight = função (e, t, n) {var r = null == e? 0: e.length; retornar r? Ii (e, (t = r- (t = n || t === o? 1: Ws (t))) < 0? 0: t, r): []}, dr.takeRightWhile = function (e, t) {return e && e.length? Fi (e, Ro (t, 3) ,! 1,! 0): []} , dr.takeWhile = function (e, t) {return e && e.length? Fi (e, Ro (t, 3)): []}, dr.tap = function (e, t) {return t (e), e}, dr.throttle = função (e, t, n) {var r =! 0, i =! 0; if ("função"! = tipo de e) lançar novo it (u); retornar Ss (n) && (r = "líder" em n? !! n.liderando: r, i = "final" em n? !! n.trailing: i), é (e, t, {principal: r, maxWait: t, final : i})}, dr.thru = Fa, dr.toArray = Ms, dr.toPairs = fu, dr.toPairsIn = pu, dr.toPath = function (e) {return ms (e)? Zt (e, la): Ps (e)? [e]: no (ca (Vs (e)))}, dr.toPlainObject = Us, dr.transform = função (e, t, n) {var r = ms (e), i = r || ws (e) || Rs (e); se (t = Ro (t, 4), nulo == n) {var o = e && e.constructor; n = i? r? new o: []: Ss (e) && xs (o)? hr (kt (e)): {}} return (i? Kt: Kr) (e , function (e, r, i) {return t (n, e, r, i)}), n}, dr.unary = function (e) {return es (e, 1)}, dr.union = Oa , dr.unionBy = Da, dr.unionWith = Ia, dr.uniq = function (e) {return e && e.length? $ i (e): []}, dr.uniqBy = function (e, t) {return e && e .length? $ i (e, Ro (t, 2)): []}, dr.uniqCom = função (e, t) {return t = "função" == typeof t? t: o, e && e.length? $ i (e, o, t): []}, dr.unset = function (e, t) {return null == e || Hi (e, t)}, dr.unzip = ka, dr.unzipWith = Na, dr.update = function (e, t, n) {return null == e? E: Mi (e, t, Vi (n))}, dr.updateWith = function (e, t, n, r) {return r = "function" == typeof r? r: o, null == e? e: Mi (e, t, Vi (n), r)}, dr.valores = du, dr.valuesIn = function (e) {return null == e? []: yn (e, ou (e))}, dr.without = La, dr.words = xu, dr.wrap = function (e, t) {return ls (Vi (t), e)}, dr.xor = ja, dr.xorBy = Pa, dr.xorWith = Ra, dr.zip = $ a, dr.zipObject = function (e , t) {return Bi (e || [], t || [], Or)}, dr.zipObjectDeep = function (e, t) {return Bi (e || [], t || [], Ai )}, dr.zipWith = Ha, dr.entries = fu, dr.entriesIn = pu, dr.extend = Ks, dr.extendWith = Gs, ju (dr, dr), dr.add = Uu, dr.attempt = Cu, dr.camelCase = hu, dr.capitalize = vu, dr.ceil = Vu, dr.clamp = function (e, t, n) {return n === o && (n = t, t = o), n ! == o && (n = (n = Bs (n)) == n? n: 0), t! == o && (t = (t = Bs (t)) == t? t: 0), jr (Bs (e), t, n)}, dr.clone = function (e) {return Pr (e, h)}, dr.cloneDeep = function (e) {return Pr (e, p | h)}, dr.cloneDeepWith = function (e, t) {return Pr (e, p | h, t = "function" == typeof t? t: o)}, dr.cloneWith = function (e, t) {return Pr ( e, h, t = "função" == tipo de t? t: o)}, dr.conformsTo = função (e,t) {return null == t || Rr (e, t, iu (t))}, dr.deburr = gu, dr.defaultTo = function (e, t) {return null == e || e! = e? t: e}, dr.divide = zu, dr.endsWith = function (e, t, n) {e = Vs (e), t = Ri (t); var r = e.length, i = n = n === o? r: jr (Ws (n), 0, r); return (n- = t.length)> = 0 && e.slice (n, i) == t}, dr.eq = ds , dr.escape = function (e) {return (e = Vs (e)) && Ce.test (e)? e.replace (Ee, En): e}, dr.escapeRegExp = function (e) {return (e) = Vs (e)) && Le.test (e)? E.replace (Ne, "\\ $ &"): e}, dr.every = função (e, t, n) {var r = ms (e) ? Xt: Wr; retornar n && Ko (e, t, n) && (t = o), r (e, Ro (t, 3))}, dr.find = Ba, dr.findIndex = ga, dr.findKey = function (e, t) {return an (e, Ro (t, 3), Kr)}, dr.findLast = Ua, dr.findLastIndex = ma, dr.findLastKey = function (e, t) {return an (e , Ro (t, 3), Gr)}, dr.floor = Ku, dr.forEach = Va, dr.forEachRight = za, dr.forIn = function (e, t) {return null == e? E: Vr (e, Ro (t, 3), ou)}, dr.forInRight = function (e, t) {return null == e? e: zr (e,Ro (t, 3), ou)}, dr.forOwn = function (e, t) {return e && Kr (e, Ro (t, 3))}, dr.forOwnRight = function (e, t) {return e && Gr ( e, Ro (t, 3))}, dr.get = Zs, dr.gt = hs, dr.gte = vs, dr.has = função (e, t) {return null! = e && Bo (e, t, ei)}, dr.hasIn = eu, dr.head = _a, dr.identity = Iu, dr.includes = function (e, t, n, r) {e = _s (e)? e: du (e) , n = n &&! r? Ws (n): 0; var i = e.length; retornar n <0 && (n = Vn (i + n, 0)), js (e)? n <= i && e.indexOf ( t, n)> - 1: !! i && un (e, t, n)> - 1}, dr.indexOf = função (e, t, n) {var r = null == e? 0: e.length; if (! r) return-1; var i = null == n? 0: Ws (n); return i <0 && (i = Vn (r + i, 0)), un (e, t, i)} , dr.inRange = function (e, t, n) {return t = Fs (t), n === o? (n = t, t = 0): n = Fs (n), function (e, t , n) {return e> = zn (t, n) && e <Vn (t, n)} (e = Bs (e), t, n)}, dr.invoke = ru, dr.isArguments = gs, dr .isArray = ms, dr.isArrayBuffer = ys, dr.isArrayLike = _s, dr.isArrayLikeObject = bs, dr.isBoolean = function (e) {return! 0 === e ||! 1 === e || Os (e) && Jr (e) == U}, dr.isBuffer = ws, dr.isDate = Ts, dr .isElement = function (e) {return Os (e) && 1 === e.nodeType &&! ks (e)}, dr.isEmpty = function (e) {if (null == e) return! 0; if (_s (e) && (ms (e) || "string" == typeof e || "função" == typeof e.splice || ws (e) || Rs (e) || gs (e))) return ! e.length; var t = qo (e); if (t == Q || t == ne) return! e.size; if (Yo (e)) return! ci (e) .length; for ( var n em e) if (lt.call (e, n)) return! 1; return! 0}, dr.isEqual = function (e, t) {return oi (e, t)}, dr.isEqualWith = function (e, t, n) {var r = (n = "função" == typeof n? n: o)? n (e, t): o; return r === o? oi (e, t, o , n): !! r}, dr.isError = Es, dr.isFinite = function (e) {return "number" == typeof e && qn (e)}, dr.isFunction = xs, dr.isInteger = Cs, dr .isLength = As, dr.isMap = Ds, dr.isMatch = function (e, t) {return e === t || ai (e, t, Ho (t))}, dr.isMatchWith = function (e , t,n) {return n = "function" == typeof n? n: o, ai (e, t, Ho (t), n)}, dr.isNaN = function (e) {return Is (e) && e! = + e}, dr.isNativo = função (e) {if (Qo (e)) lançar novo Je (s); retornar si (e)}, dr.isNil = função (e) {retornar nulo == e}, dr.isNull = function (e) {return null === e}, dr.isNumber = Is, dr.isObject = Ss, dr.isObjectLike = Os, dr.isPlainObject = ks, dr.isRegExp = Ns, dr.isSafeInteger = function (e) {return Cs (e) && e> = - j && e <= j}, dr.isSet = Ls, dr.isString = js, dr.isSymbol = Ps, dr.isTypedArray = Rs, dr.isUndefined = function (e) {return e === o}, dr.isWeakMap = function (e) {return Os (e) && qo (e) == ae}, dr.isWeakSet = function (e) {return Os (e) && Jr (e) == se}, dr.join = function (e, t) {return null == e? "": Bn.call (e, t)}, dr.kebabCase = mu, dr.last = Ea, dr.lastIndexOf = function (e, t, n) {var r = null == e? 0: e.length; if (! r) return-1; var i = r; return n! == o && (i = (i = Ws (n)) <0? Vn (r + i, 0): zn (i,r-1)), t == t? função (e, t, n) {para (var r = n + 1; r -;) if (e [r] === t) retornar r; retornar r } (e, t, i): sn (e, ln, i,! 0)}, dr.lowerCase = yu, dr.lowerFirst = _u, dr.lt = $ s, dr.lte = Hs, dr.max = function (e) {return e && e.length? qr (e, Iu, Zr): o}, dr.maxBy = function (e, t) {return e && e.length? qr (e, Ro (t, 2), Zr): o}, dr.mean = function (e) {return fn (e, Iu)}, dr.meanBy = function (e, t) {return fn (e, Ro (t, 2))}, dr .min = função (e) {return e && e.length? qr (e, Iu, fi): o}, dr.minBy = function (e, t) {return e && e.length? qr (e, Ro (t, 2 ), fi): o}, dr.stubArray = qu, dr.stubFalse = Bu, dr.stubObject = function () {return {}}, dr.stubString = function () {return ""}, dr.stubTrue = function () {return! 0}, dr.multiply = Xu, dr.nth = function (e, t) {return e && e.length? gi (e, Ws (t)): o}, dr.noConflict = function ( ) {return Lt ._ === this && (Lt ._ = vt), this}, dr.noop = Pu, dr.now = Za, dr.pad = function (e, t, n) {e = Vs ( e);var r = (t = Ws (t))? kn (e): 0; se (! t || r> = t) retornar e; var i = (tr) / 2; retornar yo (Mn (i), n) + e + yo (Hn (i), n)}, dr.padEnd = função (e, t, n) {e = Vs (e); var r = (t = Ws (t))? kn ( e): 0; retornar t && r <t? e + yo (tr, n): e}, dr.padStart = função (e, t, n) {e = Vs (e); var r = (t = Ws ( t))? kn (e): 0; retornar t && r <t? yo (tr, n) + e: e}, dr.parseInt = função (e, t, n) {retornar n || nulo == t? t = 0: t && (t = + t), Gn (Vs (e) .substituir (Pe, ""), t || 0)}, dr.random = função (e, t, n) {if (n && "boolean"! = typeof n && Ko (e, t, n) && (t = n = o), n === o && ("boolean" == typeof t? (n = t, t = o): "boolean" == tipo de e && (n = e, e = o)), e === o && t === o? (e = 0, t = 1) :( e = Fs (e), t === o? ( t = e, e = 0): t = Fs (t)), e> t) {var r = e; e = t, t = r} se (n || e% 1 || t% 1) { var i = Xn (); retornar zn (e + i * (t-e + Dt ("1e -" + ((i + ""). comprimento-1))), t)} retornar wi (e, t) }, dr.reduce = function (e, t, n) {var r = ms (e)? tn:hn, i = argumentos. comprimento <3; retornar r (e, Ro (t, 4), n, i, Mr)}, dr.reduceRight = função (e, t, n) {var r = ms (e) ? nn: hn, i = argumentos. comprimento <3; retornar r (e, Ro (t, 4), n, i, Fr)}, dr.repetir = função (e, t, n) {retorno t = ( n? Ko (e, t, n): t === o)? 1: Ws (t), Ti (Vs (e), t)}, dr.substituir = função () {var e = argumentos, t = Vs (e [0]); retornar e.length <3? T: t.replace (e [1], e [2])}, dr.result = função (e, t, n) {var r = -1, i = (t = zi (t, e)). Comprimento; para (i || (i = 1, e = o); ++ r <i;) {var a = null == e? O : e [la (t [r])]; a === o && (r = i, a = n), e = xs (a)? a.call (e): a} return e}, dr.round = Qu, dr.runInContext = e, dr.sample = function (e) {return (ms (e)? Xr: xi) (e)}, dr.size = function (e) {if (null == e) return 0; if (_s (e)) return js (e)? kn (e): e.length; var t = qo (e); return t == Q || t == ne? e.size: ci (e) .comprimento}, dr.snakeCase = bu, dr.some = função (e, t, n) {var r = ms (e)? rn: ki; retornar n && Ko (e, t, n) && (t = o), r (e, Ro (t, 3))}, dr.sortedIndex = function (e, t) {retornar Ni (e, t)},dr.sortedIndexBy = function (e, t, n) {return Li (e, t, Ro (n, 2))}, dr.sortedIndexOf = function (e, t) {var n = null == e? 0: e.length; if (n) {var r = Ni (e, t); if (r <n && ds (e [r], t)) return r} return-1}, dr.sortedLastIndex = function (e, t ) {return Ni (e, t,! 0)}, dr.sortedLastIndexBy = function (e, t, n) {return Li (e, t, Ro (n, 2) ,! 0)}, dr.sortedLastIndexOf = function (e, t) {if (null! = e && e.length) {var n = Ni (e, t,! 0) -1; if (ds (e [n], t)) return n} return-1 }, dr.startCase = wu, dr.startsWith = function (e, t, n) {return e = Vs (e), n = null == n? 0: jr (Ws (n), 0, e.length ), t = Ri (t), e.slice (n, n + t.length) == t}, dr.subtract = Yu, dr.sum = função (e) {return e && e.length? vn (e, Iu): 0}, dr.sumBy = function (e, t) {return e && e.length? Vn (e, Ro (t, 2)): 0}, dr.template = function (e, t, n) { var r = dr.templateSettings; n && Ko (e, t, n) && (t = o), e = Vs (e), t = Gs ({}, t, r, Ao); var i, a, s = Gs ({}, t.imports, r.imports, Ao), u = iu (s), c = yn (s, u), l = 0,f = t.interpolar || Qe, p = "__ p + = '", d = nt ((t.escape || Qe) .source + "|" + f.source + "|" + (f === Oe? qe: Qe) .source + "|" + (t.avaluate || Qe) .source + "| $", "g"), h = "// # sourceURL =" + ("sourceURL" em t? t.sourceURL : "lodash.templateSources [" + ++ Ct + "]") + "\ n"; e.replace (d, função (t, n, r, o, s, u) {return r || (r = o ), p + = e.slice (l, u) .substitua (Ye, xn), n && (i =! 0, p + = "'+ \ n__e (" + n + ") + \ n'"), s && (a =! 0, p + = "'; \ n" + s + "; \ n__p + ='"), r && (p + = "'+ \ n ((__ t = (" + r + ")) == nulo?' ' : __t) + \ n '"), l = u + t.length, t}), p + ="'; \ n "; var v = t.variable; v || (p =" with (obj) { \ n "+ p +" \ n} \ n "), p = (a? p.replace (_e," "): p) .replace (be," $ 1 "). replace (we,"$ 1; "), p =" function ("+ (v ||" obj ") +") {\ n "+ (v?" ":" Obj || (obj = {}); \ n ") + "var __t, __p = ''" + (i? ", __e = _.escape": "") + (a? ", __j = Array.prototype.join; \ nfunction print () {__p + = __j. chamar (argumentos, '')} \ n ":"; \ n ") + p +" retornar __p \ n} "; var g = Cu (função () {retornar Ze (u, h +" retornar "+ p). aplicar (o, c)}); if (g.source = p, Es (g)) lançar g; retornar g}, dr.times = função (e, t) {if ((e = Ws (e)) <1 || e> j) return []; var n = $, r = zn (e, $); t = Ro (t), e - = $; for (var i = gn (r, t); ++ n <e;) t (n); return i}, dr.toFinite = Fs, dr.toInteger = Ws, dr.toLength = qs, dr.toLower = function (e) {return Vs (e) .toLowerCase ()}, dr.toNumber = Bs, dr.toSafeInteger = function (e) {return e? jr (Ws (e), - j, j): 0 === e? e: 0}, dr.toString = Vs, dr.toUpper = function (e) {return Vs (e) .toUpperCase ()}, dr.trim = função (e, t, n) {if ((e = Vs (e)) && (n || t === o)) return e.replace (je, ""); if (! e || ! (t = Ri (t))) retornar e; var r = Nn (e), i = Nn (t); retornar Gi (r, bn (r, i), wn (r, i) +1). join ("")}, dr.trimEnd = function (e, t, n) {if ((e = Vs (e)) && (n || t === o)) return e.replace (Re, " "); se (! e ||! (t = Ri (t))) retornar e; var r = Nn (e); retornar Gi (r, 0, wn (r, Nn (t)) + 1). join ("")}, dr.trimStart = function (e, t, n) {if ((e = Vs (e)) && (n || t === o)) return e.replace (Pe, " "); if (! e ||! (t = Ri (t))) retornar e; var r = Nn (e); retornar Gi (r, bn (r, Nn (t))). join (" " )}, dr.truncate = function (e, t) {var n = S, r = O; if (Ss (t)) {var i = "separador" em t? t.separador: i; n = "comprimento "em t? Ws (t.length): n, r =" omissão "em t? Ri (t.omissão): r} var a = (e = Vs (e)). comprimento; if (Cn (e) ) {var s = Nn (e); a = s.length} se (n> = a) retornar e; var u = n-kn (r); se (u <1) retornar r; var c = s? Gi (s, 0, u).join (""): e.slice (0, u); if (i === o) retorna c + r; if (s && (u + = c.length-u), Ns (i)) {if (e .slice (u) .search (i)) {var l, f = c; for (i.global || (i = nt (i.source, Vs (Be.exec (i)) + "g")) , i.lastIndex = 0; l = i.exec (f);) var p = l.index; c = c.slice (0, p === o? u: p)}} else if (e.indexOf (Ri (i), u)! = U) {var d = c.lastIndexOf (i); d> -1 && (c = c.slice (0, d))} return c + r}, dr.unescape = function (e) {return (e = Vs (e)) && xe.test (e)? e.replace (Te, Ln): e}, dr.uniqueId = function (e) {var t = ++ ft; return Vs (e) + t}, dr.upperCase = Tu, dr.upperFirst = Eu, dr.each = Va, dr.eachRight = za, dr.first = _a, ju (dr, (Gu = {}, Kr ( dr, função (e, t) {lt.call (dr.protótipo, t) || (Gu [t] = e)}), Gu), {cadeia:! 1}), dr.VERSION = "4.17. 11 ", Kt ([" bind "," bindKey "," curry "," curryRight "," partial "," partialRight "], function (e) {dr [e] .placeholder = dr}), Kt ([ "solta","pegue "], função (e, t) {mr.protótipo [e] = função (n) {n = n === o? 1: Vn (Ws (n), 0); var r = this .__ filtrado __ &&! t? new mr (this): this.clone (); return r .__ filtrado __? r .__ takeCount __ = zn (n, r .__ takeCount __): r .__ views __. push ({size: zn (n, $), digite: e + (r .__ dir __ <0? "Right": "")}), r}, mr.prototype [e + "Right"] = function (t) {return this.reverse () [e] (t) .reverse ()}}), Kt (["filtro", "mapa", "takeWhile"], função (e, t) {var n = t + 1, r = n == k || 3 == n; mr .protótipo [e] = função (e) {var t = this.clone (); retornar t .__ iteratees __. push ({iteratee: Ro (e, 3), tipo: n}), t .__ filtrado __ = t .__ filtrado__ || r, t}}), Kt (["head", "last"], function (e, t) {var n = "take" + (t? "Right": ""); mr.prototype [ e] = function () {return this [n] (1) .value () [0]}}), Kt (["inicial", "cauda"], função (e, t) {var n = "drop "+ (t?" ":" Certo "); mr.prototype [e] = function () {return this .__ filtrado __? new mr (this): this [n] (1)}}), mr.prototype .compact = functiatorElement (h); var y = e.Event (f.SLID, {relatedTarget: h, direction: o, from: c, to: v}); if (e (this._element) .hasClass (p.SLIDE) ) {e (h) .addClass (i), s.reflow (h), e (u) .addClass (r), e (h) .addClass (r); var _ = s.getTransitionDurationFromElement (u); e (u) .one (s.TRANSITION_END, function () {e (h) .removeClass (r + "" + i) .addClass (p.ACTIVE), e (u) .removeClass (p.ACTIVE + "" + i + " "+ r), a._isSliding =! 1, setTimeout (function () {return e (a._element) .trigger (y)}, 0)}). emulateTransitionEnd (_)} else e (u) .removeClass ( p.ACTIVE), e (h) .addClass (p.ACTIVE), this._isSliding =! 1, e (this._element) .trigger (y); g && this.cycle ()}}}, o._jQueryInterface = function (t) {return this.each (function () {var r = e (this) .data (n), i = a ({}, u, e (this) .data ()); "objeto" == typeof t && (i = a ({}, i, t)); var s = "string" == typeof t? t: i.slide; if (r || (r = new o (this, i), e (este) .data (n, r)), "número "== typeof t) r.to (t); else if (" string "== typeof s) {if (void 0 === r [s]) lance novo TypeError ('Nenhum método denominado"' + s + '"'); r [s] ()} else i.interval && (r.pause (), r.cycle ())})}, o._dataApiClickHandler = function (t) {var r = s.getSelectorFromElement (this ); if (r) {var i = e (r) [0]; if (i && e (i) .hasClass (p.CAROSEL)) {var u = a ({}, e (i) .data (), e (this) .data ()), c = this.getAttribute ("data-slide-to"); c && (u.interval =! 1), o._jQueryInterface.call (e (i), u), c && e (i) .data (n) .to (c), t.preventDefault ()}}}, i (o, null, [{key: "VERSION", get: function () {return "4.1.3"} }, {chave: "Padrão", obter: função () {retornar u}}]), o} (); retornar e (documento) .on (f.CLICK_DATA_API, d.DATA_SLIDE, h._dataApiClickHandler), e ( janela) .on (f.LOAD_DATA_API, function () {for (var t = []. slice.call (document.querySelectorAll (d.DATA_RIDE)),n = 0, r = t.length; n <r; n ++) {var i = e (t [n]); h._jQueryInterface.call (i, i.data ())}}), e.fn [ t] = h._jQueryInterface, e.fn [t] .Constructor = h, e.fn [t] .noConflict = function () {return e.fn [t] = o, h._jQueryInterface}, h} (t ), f = função (e) {var t = "recolher", n = "bs.collapse", r = e.fn [t], o = {alternar:! 0, pai: ""}, u = { alternar: "booleano", pai: "(string | elemento)"}, c = {MOSTRAR: "show.bs.collapse", MOSTRAR: "mostrado.bs.collapse", OCULTAR: "ocultar.bs.collapse", OCULTO: "hidden.bs.collapse", CLICK_DATA_API: "click.bs.collapse.data-api"}, l = {MOSTRAR: "show", COLLAPSE: "recolher", COLLAPSE: "recolher", COLLAPSED: "recolhido "}, f = {WIDTH:" width ", HEIGHT:" height "}, p = {ACTIVES:". show, .collapsing ", DATA_TOGGLE: '[data-toggle =" collapse "]'},d = function () {function r (t, n) {this._isTransitioning =! 1, this._element = t, this._config = this._getConfig (n), this._triggerArray = e.makeArray (document.querySelectorAll ( '[data-toggle = "collapse"] [href = "#' + t.id + '"], [data-toggle = "collapse"] [data-target = "#' + t.id + '"]') ); para (var r = []. slice.call (document.querySelectorAll (p.DATA_TOGGLE)), i = 0, o = r.length; i <o; i ++) {var a = r [i], u = s.getSelectorFromElement (a), c = []. slice.call (document.querySelectorAll (u)). filter (function (e) {return e === t}); null! == u && c.length> 0 && (this._selector = u, this._triggerArray.push (a))} this._parent = this._config.parent? this._getParent (): null, this._config.parent || this._addAriaAndCollapsedClass (this._element, this._triggerArray), this._config.toggle && this.toggle ()} var d = r.prototype; return d.toggle = function () {e (this._elemento) .hasClass (l.SHOW)? this.hide (): this.show ()}, d.show = function () {var t, i, o = this; if (! (this._isTransitioning || e (this._element) .hasClass (l.SHOW) || (this._parent && 0 === (t = []. slice.call (this._parent.querySelectorAll (p.ACTIVES)). filter (function (e) { return e.getAttribute ("data-parent") === o._config.parent})). length && (t = null), t && (i = e (t) .not (this._selector) .data (n) ) && i._isTransitioning))) {var a = e.Event (c.SHOW); if (e (this._element) .trigger (a) ,! a.isDefaultPrevented ()) {t && (r._jQueryInterface.call ( e (t) .not (this._selector), "ocultar"), i || e (t) .data (n, null)); var u = this._getDimension (); e (this._element) .removeClass (l.COLLAPSE) .addClass (l.COLLAPSING), this._element.style [u] = 0, this._triggerArray.length && e (this._triggerArray) .removeClass (l.COLLAPSED) .attr ("ária expandida", ! 0), isso.setTransitioning (! 0); var f = u [0] .toUpperCase () + u.slice (1), d = "rolar" + f, h = s.getTransitionDurationFromElement (this._element); e (this._element) .one (s.TRANSITION_END, function () {e (o._element) .removeClass (l.COLLAPSING) .addClass (l.COLLAPSE) .addClass (l.SHOW), o._element.style [u] = "" , o.setTransitioning (! 1), e (o._element) .trigger (c.SHOWN)}). emulateTransitionEnd (h), this._element.style [u] = this._element [d] + "px"} }}, d.hide = function () {var t = this; if (! this._isTransitioning && e (this._element) .hasClass (l.SHOW)) {var n = e.Event (c.HIDE); if ( e (this._element) .trigger (n) ,! n.isDefaultPrevented ()) {var r = this._getDimension (); this._element.style [r] = this._element.getBoundingClientRect () [r] + " px ", s.reflow (this._element), e (this._element) .addClass (l.COLLAPSING) .removeClass (l.COLLAPSE) .removeClass (l.SHOW); var i = this._triggerArray.length;if (i> 0) for (var o = 0; o <i; o ++) {var a = this._triggerArray [o], u = s.getSelectorFromElement (a); if (null! == u) {var f = e ([]. slice.call (document.querySelectorAll (u))); f.hasClass (l.SHOW) || e (a) .addClass (l.COLLAPSED) .attr ("ária-expandida" ,! 1)}} this.setTransitioning (! 0), this._element.style [r] = ""; var p = s.getTransitionDurationFromElement (this._element); e (this._element) .one (s.TRANSITION_END, function () {t.setTransitioning (! 1), e (t._element) .removeClass (l.COLLAPSING) .addClass (l.COLLAPSE) .trigger (c.HIDDEN)}). emulateTransitionEnd (p)}}}, d .setTransitioning = function (e) {this._isTransitioning = e}, d.dispose = function () {e.removeData (this._element, n), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null}, d._getConfig = function (e) {return (e = a ({}, o, e)). toggle = Boolean (e.toggle), s. typeCheckConfig (t, e, u), e}, d._getDimension = function () {var t = e (this._element) .hasClass (f.WIDTH); return t? f.WIDTH: f.HEIGHT}, d._getParent = function () {var t = this, n = null; s.isElement (this._config.parent)? (n = this._config.parent, void 0! == this._config.parent.jquery && (n = this._config.parent [0])): n = document.querySelector (this._config.parent); var i = '[data-toggle = "collapse"] [data-parent = "' + this._config.parent + '"]', o = []. slice.call (n.querySelectorAll (i)); retornar e (o) .each (function (e, n) {t._addAriaAndCollapsedClass (r._getTargetFromElement (n), [n])}), n}, d._addAriaAndCollapsedClass = function (t, n) {if (t) {var r = e (t) .hasClass (l.SHOW); n.length && e (n) .toggleClass (l.COLLAPSED,! r) .attr ("ária-expandida" , r)}}, r._getTargetFromElement = function (e) {var t = s.getSelectorFromElement (e); retornar t? document.querySelector (t): null}, r._jQueryInterface = function (t) {return this.each (function () {var i = e (this), s = i.data (n), u = a ({}, o, i.data (), "objeto "== typeof t && t? t: {}); if (! s && u.toggle && / show | ocultar / .test (t) && (u.toggle =! 1), s || (s = new r (this, u ), i.data (n, s)), "string" == typeof t) {if (void 0 === s [t]) throw new TypeError ('Nenhum método denominado "' + t + '"'); s [t] ()}})}, i (r, null, [{key: "VERSION", get: function () {return "4.1.3"}}, {key: "Default", get: function () {return o}}]), r} (); return e (documento) .on (c.CLICK_DATA_API, p.DATA_TOGGLE, function (t) {"A" === t.currentTarget.tagName && t.preventDefault ( ); var r = e (this), i = s.getSelectorFromElement (this), o = []. slice.call (document.querySelectorAll (i)); e (o) .each (function () {var t = e (this), i = t.data (n), o = i? "alternar": r.data (); d._jQueryInterface.call (t, o)})}),e.fn [t] = d._jQueryInterface, e.fn [t] .Constructor = d, e.fn [t] .noConflict = function () {return e.fn [t] = r, d._jQueryInterface}, d} (t), p = função (e) {var t = "dropdown", r = "bs.dropdown", o = "." + r, u = e.fn [t], c = new RegExp ( "38 | 40 | 27"), l = {OCULTAR: "ocultar" + o, OCULTAR: "oculto" + o, MOSTRAR: "mostrar" + o, MOSTRAR: "mostrado" + o, CLIQUE: "clique" + o, CLICK_DATA_API: "click.bs.dropdown.data-api", KEYDOWN_DATA_API: "keydown.bs.dropdown.data-api", KEYUP_DATA_API: "keyup.bs.dropdown.data-api"}, f = {DISABLED: "disabled", SHOW: "show", DROPUP: "dropup", DROPRIGHT: "dropright", DROPLEFT: "dropleft", MENURIGHT: "dropdown-menu-right", MENULEFT: "dropdown-menu-left", POSITION_STATIC: "position-static"}, p = {DATA_TOGGLE: '[data-toggle = "dropdown "] ', FORM_CHILD:". formulário suspenso ", MENU:". dropdown-menu ", NAVBAR_NAV:". navbar-nav ", VISIBLE_ITEMS:". dropdown-menu .dropdown-item: not (.disabled): not (: desativado) "}, d = {TOPO:" início superior ", SUPERIOR:" início superior ", INFERIOR:" início inferior ", FUNDO:" início inferior ", DIREITA:" início à direita ", RIGHTEND: "right-end", LEFT: "left-start", LEFTEND: "left-end"}, h = {offset: 0, flip:! 0, limite: "scrollParent", referência: "toggle", display : "dinâmico"}, v = {deslocamento: "(número | string | função)", inverter: "booleano", limite: "(string | elemento)", referência: "(string | elemento)", exibir: " string "}, g = function () {function u (e, t) {this._element = e, this._popper = null, this._config = this._getConfig (t), this._menu = this._getMenuElement (), this._inNavbar = this._detectNavbar (), this._addEventListeners ()} var g = u.prototype; return g.toggle = function () {if (! this._element.disabled &&! e (this._element ) .hasClass (f.DISABLED)) {var t = u._getParentFromElement (this._element), r = e (this._menu) .hasClass (f.SHOW); if (u._clearMenus () ,! r) { var i = {relatedTarget: this._element}, o = e.Event (l.SHOW, i); if (e (t) .trigger (o) ,! o.isDefaultPrevented ()) {if (! this._inNavbar ) {if (void 0 === n) lançar novo TypeError ("menu suspenso Bootstrap requer Popper.js (https://popper.js.org)"); var a = this._element; "pai" === isto ._config.reference? a = t: s.isElement (this._config.reference) && (a = this._config.reference, void 0! == this._config.reference.jquery && (a = this._config.reference [ 0])), "scrollParent"! == this._config.boundary && e (t) .addClass (f.POSITION_STATIC), this._popper = new n (a,this._menu, this._getPopperConfig ())} "ontouchstart" em document.documentElement && 0 === e (t) .closest (p.NAVBAR_NAV) .length && e (document.body) .children (). on ("mouseover", null, e.noop), this._element.focus (), this._element.setAttribute ("ária-expandido",! 0), e (this._menu) .toggleClass (f.SHOW), e (t). toggleClass (f.SHOW) .trigger (e.Event (l.SHOWN, i))}}}}, g.dispose = function () {e.removeData (this._element, r), e (this._element) .off (o), this._element = null, this._menu = null, null! == this._popper && (this._popper.destroy (), this._popper = null)}, g.update = function () { this._inNavbar = this._detectNavbar (), null! == this._popper && this._popper.scheduleUpdate ()}, g._addEventListeners = function () {var t = this; e (this._element) .on (l.CLICK , function (e) {e.preventDefault (), e.stopPropagation (), t.toggle ()})}, g._getConfig = function (n) {return n = a ({}, this.construtor.Default, e (this._element) .data (), n), s.typeCheckConfig (t, n, this.constructor.DefaultType), n}, g._getMenuElement = function () {if (! this._menu ) {var e = u._getParentFromElement (this._element); e && (this._menu = e.querySelector (p.MENU))} return this._menu}, g._getPlacement = function () {var t = e (this ._element.parentNode), n = d.BOTTOM; retornar t.hasClass (f.DROPUP)? (n = d.TOP, e (this._menu) .hasClass (f.MENURIGHT) && (n = d.TOPEND) ): t.hasClass (f.DROPRIGHT)? n = d.RIGHT: t.hasClass (f.DROPLEFT)? n = d.LEFT: e (this._menu) .hasClass (f.MENURIGHT) && (n = d .BOTTOMEND), n}, g._detectNavbar = function () {return e (this._element) .closest (". Navbar"). Length> 0}, g._getPopperConfig = function () {var e = this, t = {}; "função" == typeof this._config.offset? t.fn = function (t) {return t.offsets = a ({}, t.offsets, e._config.offset (t.offsets) | | {}), t}: t.offset = this._config.offset;var n = {placement: this._getPlacement (), modificadores: {offset: t, flip: {enabled: this._config.flip}, preventOverflow: {boundariesElement: this._config.boundary}}}; return "static" = == this._config.display && (n.modifiers.applyStyle = {enabled:! 1}), n}, u._jQueryInterface = function (t) {return this.each (function () {var n = e (this) .data (r), i = "objeto" == typeof t? t: null; if (n || (n = new u (this, i), e (this) .data (r, n)), " string "== typeof t) {if (void 0 === n [t]) throw new TypeError ('Nenhum método chamado"' + t + '"'); n [t] ()}})}, u. _clearMenus = function (t) {if (! t || 3! == t.which && ("keyup"! == t.type || 9 === t.which)) para (var n = []. slice .call (document.querySelectorAll (p.DATA_TOGGLE)), i = 0, o = n.length; i <o; i ++) {var a = u._getParentFromElement (n [i]), s = e (n [i ]). data (r), c = {relatedTarget: n [i]}; if (t && "click" === t.type && (c.clickEvent = t), s) {var d = s._menu; if (e (a) .hasClass (f.SHOW) &&! (t && ("click" === t.type && / input | textarea / i.test (t.target.tagName) || "keyup" === t.type && 9 === t.which) && e.contains (a, t.target))) {var h = e.Event (l.HIDE, c ); e (a) .trigger (h), h.isDefaultPrevented () || ("ontouchstart" em document.documentElement && e (document.body) .children (). off ("mouseover", null, e.noop), n [i] .setAttribute ("ária-expandido", "falso"), e (d) .removeClass (f.SHOW), e (a) .removeClass (f.SHOW) .trigger (e.Event (l. HIDDEN, c)))}}}}, u._getParentFromElement = function (e) {var t, n = s.getSelectorFromElement (e); return n && (t = document.querySelector (n)), t || e. parentNode}, u._dataApiKeydownHandler = function (t) {if ((/ input | textarea / i.test (t.target.tagName)?! (32 === t.which || 27! == t.which && ( 40! == t.which &&38! == t.which || e (t.target) .closest (p.MENU) .length)): c.test (t.which)) && (t.preventDefault (), t.stopPropagation (), ! this.disabled &&! e (this) .hasClass (f.DISABLED))) {var n = u._getParentFromElement (this), r = e (n) .hasClass (f.SHOW); if ((r || 27 === t.which && 32 === t.which) && (! r || 27! == t.which && 32! == t.which)) {var i = []. slice.call (n.querySelectorAll (p .VISIBLE_ITEMS)); if (0! == i.length) {var o = i.indexOf (t.target); 38 === t.which && o> 0 && o -, 40 === t.which && o <i. comprimento-1 && o ++, o <0 && (o = 0), i [o] .focus ()}} else {if (27 === t.which) {var a = n.querySelector (p.DATA_TOGGLE); e ( a) .trigger ("focus")} e (this) .trigger ("click")}}}, i (u, null, [{key: "VERSION", get: function () {return "4.1.3 "}}, {key:" Default ", get: function () {return h}}, {key:" DefaultType ", get:function () {return v}}]), u} (); return e (document) .on (l.KEYDOWN_DATA_API, p.DATA_TOGGLE, g._dataApiKeydownHandler) .on (l.KEYDOWN_DATA_API, p.MENU, g._dataApiKeydownHandler). ) .on (l.CLICK_DATA_API + "" + l.KEYUP_DATA_API, g._clearMenus) .on (l.CLICK_DATA_API, p.DATA_TOGGLE, função (t) {t.preventDefault (), t.stopPropagation (), g._jQueryInterface. call (e (this), "toggle")}). on (l.CLICK_DATA_API, p.FORM_CHILD, function (e) {e.stopPropagation ()}), e.fn [t] = g._jQueryInterface, e. fn [t] .Constructor = g, e.fn [t] .noConflict = function () {return e.fn [t] = u, g._jQueryInterface}, g} (t), d = function (e) { var t = "modal", n = ". bs.modal", r = e.fn.modal, o = {pano de fundo:! 0, teclado:! 0, foco:! 0, mostrar:! 0}, u = {pano de fundo: "(boolean | string)", teclado: "boolean", focus: "boolean", show: "boolean"}, c = {HIDE: "hide.bs.modal", HIDDEN: "hidden.bs.modal ", MOSTRAR:" show.bs.modal ", MOSTRAR:" mostrado.bs.modal ", FOCUSIN:" focusin.bs.modal ", REDIMENSIONAR:" resize.bs.modal ", CLICK_DISMISS:" click.dismiss. bs.modal ", KEYDOWN_DISMISS:" keydown.dismiss.bs.modal ", MOUSEUP_DISMISS:" mouseup.dismiss.bs.modal ", MOUSEDOWN_DISMISS:" mousedown.dismiss.bs.modal ", CLICK_DATA_API:" click.bs.modal. data-api "}, l = {SCROLLBAR_MEASURER:" modal-scrollbar-measure ", BACKDROP:" modal-backdrop ", OPEN:" modal-open ", FADE:" fade ", SHOW:" show "}, f = {DIALOG: ". Modal-dialog", DATA_TOGGLE: '[data-toggle = "modal"]', DATA_DISMISS: '[data-despedir = "modal"]', FIXED_CONTENT: ". Fixed-top, .fixed-bottom , .is-fixed, .sticky-top ", STICKY_CONTENT:". sticky-top "},p = function () {function r (e, t) {this._config = this._getConfig (t), this._element = e, this._dialog = e.querySelector (f.DIALOG), this._backdrop = null, this._isShown =! 1, this._isBodyOverflowing =! 1, this._ignoreBackdropClick =! 1, this._scrollbarWidth = 0} var p = r.prototype; return p.toggle = function (e) {return this._isShown? this .hide (): this.show (e)}, p.show = function (t) {var n = this; if (! this._isTransitioning &&! this._isShown) {e (this._element) .hasClass (l. FADE) && (this._isTransitioning =! 0); var r = e.Event (c.SHOW, {relatedTarget: t}); e (this._element) .trigger (r), this._isShown || r.isDefaultPrevented () || (this._isShown =! 0, this._checkScrollbar (), this._setScrollbar (), this._adjustDialog (), e (document.body) .addClass (l.OPEN), this._setEscapeEvent (), this._setResizeEvent (), e (this._element) .on (c.CLICK_DISMISS, f.DATA_DISMISS, função (e) {return n.hide (e)}), e (this._dialog) .on (c.MOUSEDOWN_DISMISS, function () {e (n._element) .one (c.MOUSEUP_DISMISS, function (t) {e (t.target) .is (n._element) && (n._ignoreBackdropClick =! 0)})}) , this._showBackdrop (function () {return n._showElement (t)}))}}, p.hide = function (t) {var n = this; if (t && t.preventDefault () ,! this._isTransitioning && this._isShown ) {var r = e.Event (c.HIDE); if (e (this._element) .trigger (r), this._isShown &&! r.isDefaultPrevented ()) {this._isShown =! 1; var i = e (this._element) .hasClass (l.FADE); if (i && (this._isTransitioning =! 0), this._setEscapeEvent (), this._setResizeEvent (), e (documento) .off (c.FOCUSIN), e (this._element) .removeClass (l.SHOW), e (this._element) .off (c.CLICK_DISMISS), e (this._dialog) .off (c.MOUSEDOWN_DISMISS), i) {var o = s.getTransitionDurationFromElement (this._element); e (this._element) .one (s.TRANSITION_END, function (e) {return n._hideModal (e)}).emulateTransitionEnd (o)} else this._hideModal ()}}}, p.dispose = function () {e.removeData (this._element, "bs.modal"), e (janela, documento, this._element, this. _backdrop) .off (n), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._scrollbarWidth = null}, p.handleUpdate = function () {this._adjustDialog ()}, p._getConfig = function (e) {return e = a ({}, o, e), s.typeCheckConfig (t, e, u), e}, p._showElement = function (t) {var n = this, r = e (this._element) .hasClass (l.FADE); this._element.parentNode && this._element.parentNode.nodeType = == Node.ELEMENT_NODE || document.body.appendChild (this._element), this._element.style.display = "bloquear", this._element.removeAttribute ("aria-hidden"), this._element.scrollTop = 0 , r && s.reflow (this._element), e (this._element).addClass (l.SHOW), this._config.focus && this._enforceFocus (); var i = e.Event (c.SHOWN, {relatedTarget: t}), o = function () {n._config.focus && n._element.focus (), n._isTransitioning =! 1, e (n._element) .trigger (i)}; if (r) {var a = s.getTransitionDurationFromElement (this._element); e (this._dialog) .one (s) .TRANSITION_END, o) .emulateTransitionEnd (a)} else o ()}, p._enforceFocus = function () {var t = this; e (document) .off (c.FOCUSIN) .on (c.FOCUSIN, function ( n) {document! == n.target && t._element! == n.target && 0 === e (t._element) .has (n.target) .length && t._element.focus ()})}, p._setEscapeEvent = function () {var t = this; this._isShown && this._config.keyboard? e (this._element) .on (c.KEYDOWN_DISMISS, function (e) {27 === e.which && (e.preventDefault (), t .hide ())}): this._isShown || e (this._element) .off (c.KEYDOWN_DISMISS)}, p._setResizeEvent = function () {var t = this; this._ismostrado? e (janela) .on (c.RESIZE, função (e) {return t.handleUpdate (e)}): e (janela) .off (c.RESIZE)}, p._hideModal = function () {var t = this; this._element.style.display = "none", this._element.setAttribute ("aria-hidden",! 0), this._isTransitioning =! 1, this._showBackdrop (function () {e (document .body) .removeClass (l.OPEN), t._resetAdjustments (), t._resetScrollbar (), e (t._element) .trigger (c.HIDDEN)})}, p._removeBackdrop = function () {this. _backdrop && (e (this._backdrop) .remove (), this._backdrop = null)}, p._showBackdrop = function (t) {var n = this, r = e (this._element) .hasClass (l.FADE) ? l.FADE: ""; if (this._isShown && this._config.backdrop) {if (this._backdrop = document.createElement ("div"), this._backdrop.className = l.BACKDROP, r && this._backdrop.classList. add (r), e (this._backdrop) .appendTo (document.body), e (this._element) .on (c.CLICK_DISMISS, function (e) {n._ignoreBackdropClick? N._ignoreBackdropClick =! 1: e.target === e.currentTarget && ("static" === n._config.backdrop? N._element.focus (): n. hide ())}), r && s.reflow (this._backdrop), e (this._backdrop) .addClass (l.SHOW) ,! t) return; if (! r) return void t (); var i = s .getTransitionDurationFromElement (this._backdrop); e (this._backdrop) .one (s.TRANSITION_END, t) .emulateTransitionEnd (i)} else if (! this._isShown && this._backdrop) {e (this._backdrop) .removeClass (l .SHOW); var o = function () {n._removeBackdrop (), t && t ()}; if (e (this._element) .hasClass (l.FADE)) {var a = s.getTransitionDurationFromElement (this._backdrop) ; e (this._backdrop) .one (s.TRANSITION_END, o) .emulateTransitionEnd (a)} else o ()} else t && t ()}, p._adjustDialog = function () {var e = this._element.scrollHeight> document.documentElement.clientHeight;! this._isBodyOverflowing && e && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), this._isBodyOverflowing &&! e && (this._element.style.paddingRight = this._scrollbarWidth + "px")}, {this._resetAdjust = função () ._element.style.paddingLeft = "", this._element.style.paddingRight = ""}, p._checkScrollbar = function () {var e = document.body.getBoundingClientRect (); this._isBodyOverflowing = e.left + e .right <window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth ()}, p._setScrollbar = function () {var t = this; if (this._isBodyOverflowing) {var n = []. slice.call (document. querySelectorAll (f.FIXED_CONTENT)), r = []. slice.call (document.querySelectorAll (f.STICKY_CONTENT)); e (n) .each (function (n, r) {var i = r.style.paddingRight, o = e (r) .css ("padding-right"); e (r) .data ("padding-right", i) .css ("padding-right ", parseFloat (o) + t._scrollbarWidth +" px ")}), e (r) .each (função (n, r) {var i = r.style.marginRight, o = e (r). css ("margin-right"); e (r) .data ("margin-right", i) .css ("margin-right", parseFloat (o) -t._scrollbarWidth + "px")}); var i = document.body.style.paddingRight, o = e (document.body) .css ("padding-right"); e (document.body) .data ("padding-right", i) .css ("padding- right ", parseFloat (o) + this._scrollbarWidth +" px ")}}, p._resetScrollbar = function () {var t = []. slice.call (document.querySelectorAll (f.FIXED_CONTENT)); e (t) .each (função (t, n) {var r = e (n) .data ("padding-right"); e (n) .removeData ("padding-right"), n.style.paddingRight = r || ""}); var n = []. slice.call (document.querySelectorAll ("" + f.STICKY_CONTENT)); e (n) .each (função (t, n) {var r = e (n).data ("margin-right"); void 0! == r && e (n) .css ("margin-right", r) .removeData ("margin-right")}); var r = e (document.body) .data ("padding-right"); e (document.body) .removeData ("padding-right"), document.body.style.paddingRight = r || ""}, p._getScrollbarWidth = function () {var e = document.createElement ("div"); e.className = l.SCROLLBAR_MEASURER, document.body.appendChild (e); var t = e.getBoundingClientRect (). width-e.clientWidth; retornar document.body.removeChild ( e), t}, r._jQueryInterface = function (t, n) {return this.each (function () {var i = e (this) .data ("bs.modal"), s = a ({}, o, e (this) .data (), "object" == typeof t && t? t: {}); if (i || (i = new r (this, s), e (this) .data ("bs .modal ", i))," string "== typeof t) {if (void 0 === i [t]) throw new TypeError ('Nenhum método chamado"' + t + '"'); i [t] (n)} else s.show && i.show (n)})}, i (r, null, [{key:" VERSION ", get: function () {return" 4.1.3 "}}, {chave:" Padrão ", get: function () {return o}}]), r} (); return e (document) .on (c.CLICK_DATA_API, f.DATA_TOGGLE, function (t) { var n, r = this, i = s.getSelectorFromElement (this); i && (n = document.querySelector (i)); var o = e (n) .data ("bs.modal")? "alternar": a ({}, e (n) .data (), e (this) .data ()); "A"! == this.tagName && "AREA"! == this.tagName || t.preventDefault (); var u = e (n) .one (c.SHOW, function (t) {t.isDefaultPrevented () || u.one (c.HIDDEN, function () {e (r) .is (": visible") && r .focus ()})}); p._jQueryInterface.call (e (n), o, this)}), e.fn.modal = p._jQueryInterface, e.fn.modal.Constructor = p, e.fn .modal.noConflict = function () {return e.fn.modal = r, p._jQueryInterface}, p} (t), h = function (e) {var t = "tooltip ", r =". bs.tooltip ", o = e.fn [t], u = new RegExp (" (^ | \\ s) bs-tooltip \\ S + "," g "), c = { animação: "booleano", modelo: "string", título: "(string | elemento | função)", gatilho: "string", atraso: "(número | objeto)", html: "booleano", seletor: "( string | boolean) ", colocação:" (string | função) ", deslocamento:" (número | string) ", contêiner:" (string | elemento | booleano) ", fallbackPlacement:" (string | array) ", limite: "(string | elemento)"}, l = {AUTO: "auto", TOP: "top", RIGHT: "right", BOTTOM: "bottom", LEFT: "left"}, f = {animação:! 0 , template: '<div class = "tooltip" role = "tooltip"> <div class = "arrow"> </div> <div class = "tooltip-inner"> </div></div> ', trigger: "hover focus", title: "", delay: 0, html:! 1, selector:! 1, placement: "top", offset: 0, container:! 1, fallbackPlacement: " inverter ", limite:" scrollParent "}, p = {MOSTRAR:" mostrar ", SAIR:" fora "}, d = {OCULTAR:" ocultar "+ r, OCULTAR:" oculto "+ r, MOSTRAR:" mostrar " + r, MOSTRADO: "mostrado" + r, INSERIDO: "inserido" + r, CLIQUE: "clique" + r, FOCUSIN: "focusin" + r, FOCUSOUT: "focusout" + r, MOUSEENTER: "mouseenter" + r , MOUSELEAVE: "mouseleave" + r}, h = {FADE: "fade", SHOW: "show"}, v = {TOOLTIP: ". Tooltip", TOOLTIP_INNER: ". Tooltip-inner", SETA: ". "}, g = {HOVER:" hover ", FOCUS:" focus ", CLICK:" click ", MANUAL:" manual "}, m = function () {function o (e,t) {if (void 0 === n) throw new TypeError ("Dicas de bootstrap requerem Popper.js (https://popper.js.org)"); this._isEnabled =! 0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this.element = e, this.config = this._getConfig (t), this.tip = null, this._setListeners ()} var m = o.prototype; return m.enable = function () {this._isEnabled =! 0}, m.disable = function () {this._isEnabled =! 1}, m.toggleEnabled = function () {this._isEnabled =! this._isEnabled}, m.toggle = function (t) {if (this._isEnabled) if (t) {var n = this.constructor.DATA_KEY, r = e (t.currentTarget) .data (n); r || (r = novo this.constructor (t.currentTarget, this._getDelegateConfig ()), e (t.currentTarget) .data (n, r)), r._activeTrigger.click =! r._activeTrigger.click, r._isWithActiveTrigger ()? r._enter (null, r): r._leave (null, r)} else {if (e (this.getTipElement ()). hasClass (h.SHOW)) return void this._leave ( nulo,this); this._enter (null, this)}}, m.dispose = function () {clearTimeout (this._timeout), e.removeData (this.element, this.constructor.DATA_KEY), e (this.element) .off (this.constructor.EVENT_KEY), e (this.element) .closest (". modal"). off ("hide.bs.modal"), this.tip && e (this.tip) .remove (), this ._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, null! == this._popper && this._popper.destroy (), this._popper = null, this.element = null, este .config = null, this.tip = null}, m.show = function () {var t = this; if ("none" === e (this.element) .css ("display")) lança novo erro ("Use mostrar nos elementos visíveis"); var r = e.Event (this.constructor.Event.SHOW); if (this.isWithContent () && this._isEnabled) {e (this.element) .trigger (r) ; var i = e.contains (this.element.ownerDocument.documentElement, this.element); if (r.isDefaultPrevented () ||! i) return; var o = this.getTipElement (), a = s.getUID (this.constructor.NAME); o.setAttribute ("id", a), this.element.setAttribute (" aria-coveredby ", a), this.setContent (), this.config.animation && e (o) .addClass (h.FADE); var u =" function "== typeof this.config.placement? this.config.placement .call (this, o, this.element): this.config.placement, c = this._getAttachment (u); this.addAttachmentClass (c); var l =! 1 === this.config.container? document. corpo: e (documento) .find (this.config.container); e (o) .data (this.constructor.DATA_KEY, this), e.contains (this.element.ownerDocument.documentElement, this.tip) || e (o) .appendTo (l), e (this.element) .trigger (this.constructor.Event.INSERTED), this._popper = new n (this.element, o, {placement: c, modifiers: {offset : {offset: this.config.offset}, flip: {behavior: this.config.fallbackPlacement}, arrow: {element: v.ARROW}, preventOverflow: {boundariesElement: this.config.boundary}}, onCreate: function (e) {e.originalPlacement! == e.placement && t._handlePopperPlacementChange (e)}, onUpdate: function (e) {t._handlePopperPlacementChange ( e)}}), e (o) .addClass (h.SHOW), "ontouchstart" em document.documentElement && e (document.body) .children (). on ("mouseover", null, e.noop); var f = function () {t.config.animation && t._fixTransition (); var n = t._hoverState; t._hoverState = null, e (t.element) .trigger (t.constructor.Event.SHOWN), n === p.OUT && t._leave (null, t)}; if (e (this.tip) .hasClass (h.FADE)) {var d = s.getTransitionDurationFromElement (this.tip); e (this.tip) .one ( s.TRANSITION_END, f) .emulateTransitionEnd (d)} else f ()}}, m.hide = function (t) {var n = this, r = this.getTipElement (), i = e.Event (this.constructor .Event.HIDE), o = function () {n._hoverState! == p.SHOW && r.parentNode && r.parentNode.removeChild (r), n._cleanTipClass (), n.element.removeAttribute ("aria-describeby"), e (n.element) .trigger (n.constructor.Event.HIDDEN), null! == n._popper && n._popper.destroy (), t && t ()}; if (e (this.element) .trigger (i) ,! i.isDefaultPrevented ()) {if (e (r) .removeClass (h.SHOW) , "ontouchstart" em document.documentElement && e (document.body) .children (). off ("mouseover", null, e.noop), this._activeTrigger [g.CLICK] =! 1, this._activeTrigger [g.FOCUS ] =! 1, this._activeTrigger [g.HOVER] =! 1, e (this.tip) .hasClass (h.FADE)) {var a = s.getTransitionDurationFromElement (r); e (r) .one (s .TRANSITION_END, o) .emulateTransitionEnd (a)} else o (); this._hoverState = ""}}, m.update = function () {null! == this._popper && this._popper.scheduleUpdate ()}, m. isWithContent = function () {return Boolean (this.getTitle ())}, m.addAttachmentClass = function (t) {e (this.getTipElement ()). addClass ("bs-tooltip -" + t)}, m.getTipElement = function () {return this.tip = this.tip || e (this .config.template) [0], this.tip}, m.setContent = function () {var t = this.getTipElement (); this.setElementContent (e (t.querySelectorAll (v.TOOLTIP_INNER)), this.getTitle ()), e (t) .removeClass (h.FADE + "" + h.SHOW)}, m.setElementContent = function (t, n) {var r = this.config.html; "object" == typeof n && (n.nodeType || n.jquery)? r? e (n) .parent (). is (t) || t.empty (). append (n): t.text (e (n) .text ( )): t [r? "html": "text"] (n)}, m.getTitle = function () {var e = this.element.getAttribute ("data-original-title"); return e || (e = "função" == typeof this.config.title? this.config.title.call (this.element): this.config.title), e}, m._getAttachment = function (e) {return l [ e.toUpperCase ()]}, m._setListeners = function () {var t = this, n = this.config.trigger.split (""); n.forEach (function (n) {if ("click" === n) e (t.element) .on (t.constructor.Event.CLICK, t.config.selector, function (e) {return t.toggle (e)}); else if (n! == g.MANUAL) {var r = n == = g.HOVER? t.constructor.Event.MOUSEENTER: t.constructor.Event.FOCUSIN, i = n === g.HOVER? t.constructor.Event.MOUSELEAVE: t.constructor.Event.FOCUSOUT; e (t .element) .on (r, t.config.selector, function (e) {return t._enter (e)}). on (i, t.config.selector, function (e) {return t._leave (e )})} e (t.elemento) .closest (". modal"). on ("hide.bs.modal", function () {return t.hide ()})}), this.config.selector? this.config = a ({}, this.config, {trigger: "manual", seletor: ""}): this._fixTitle ()}, m._fixTitle = function () {var e = typeof this.element. getAttribute ("data-original-title"); (this.element.getAttribute ("title") || "string"! == e) && (this.element.setAttribute ("data-original-title", this.element.getAttribute ("title") || ""), this. element.setAttribute ("title", ""))}, m._enter = function (t, n) {var r = this.constructor.DATA_KEY; (n = n || e (t.currentTarget) .data (r )) || (n = new this.constructor (t.currentTarget, this._getDelegateConfig ()), e (t.currentTarget) .data (r, n)), t && (n._activeTrigger ["focusin" === t.type? g.FOCUS: g.HOVER] =! 0), e (n.getTipElement ()). hasClass (h.SHOW) || n._hoverState === p.SHOW?n._hoverState=p. MOSTRAR: (clearTimeout (n._timeout), n._hoverState = p.SHOW, n.config.delay && n.config.delay.show? N._timeout = setTimeout (function () {n._hoverState === p.SHOW && n. show ()}, n.config.delay.show): n.show ())}, m._leave = function (t, n) {var r = this.constructor.DATA_KEY; (n = n || e ( t.currentTarget) .data (r)) || (n = new this.constructor (t.currentTarget, this._getDelegateConfig ()), e (t.currentTarget) .data (r, n)), t && (n._activeTrigger [ "focusout" === t.type? g.FOCUS: g.HOVER] =! 1), n._isWithActiveTrigger () || (clearTimeout (n._timeout), n._hoverState = p.OUT, n.config. delay && n.config.delay.hide? n._timeout = setTimeout (function () {n._hoverState === p.OUT && n.hide ()}, n.config.delay.hide): n.hide ())}, m._isWithActiveTrigger = function () {para (var e in this._activeTrigger) if (this._activeTrigger [e]) return! 0; return! 1}, m._getConfig = function (n) {return "number" == typeof (n = a ({}, this.constructor.Default, e (this.element) .data (), "object" == typeof n && n? n: {})). delay && (n.delay = {show: n.delay, ocultar: n.delay}), "número" == typeof n.title && (n.title = n.title.toString ()), "number" == typeof n.conteúdo && (n.content = n.content.toString ()), s.typeCheckConfig (t, n, this.constructor.DefaultType), n}, m._getDelegateConfig = function () {var e = {}; if (this .config) para (var t in this.config) this.constructor.Default [t]! == this.config [t] && (e [t] = this.config [t]); return e}, m. _cleanTipClass = function () {var t = e (this.getTipElement ()), n = t.attr ("classe"). match (u); null! == n && n.length && t.removeClass (n.join ("" ))}, m._handlePopperPlacementChange = function (e) {var t = e.instance; this.tip = t.popper, this._cleanTipClass (), this.addAttachmentClass (this._getAttachment (e.placement))}, m ._fixTransition = function () {var t = this.getTipElement (), n = this.config.animation; null === t.getAttribute ("x-placement") && (e (t) .removeClass (h.FADE ), this.config.animation =! 1, this.hide (), this.show (), this.config.animation = n)}, o._jQueryInterface = function (t) {return this.each (function () {var n = e (this) .data ("bs.tooltip"), r = "object" == typeof t && t; if ((n ||! /dispose|hide/.test(t))&&(n||(n=new o (this, r), e (this) .data ("bs.tooltip", n)), "string" == typeof t)) {if (void 0 === n [t]) throw new TypeError ('Nenhum método chamado "' + t + '"'); n [t] ()}})}, i (o, nulo, [{key: "VERSION", get: function () {return "4.1.3"}}, {key: "Default", get: function () {return f}}, {key: "NAME", get: function () {return t}}, {key: "DATA_KEY", get: function () {return "bs.tooltip"}}, {key: "Event", get: function () {return d}}, { tecla: "EVENT_KEY", get: function () {return r}}, {key: "DefaultType", get: function () {return c}}]), o} (); return e.fn [t] = m._jQueryInterface, e.fn [t] .Constructor = m, e.fn [t].noConflict = function () {return e.fn [t] = o, m._jQueryInterface}, m} (t), v = function (e) {var t = "popover", n = ". bs.popover", r = e.fn [t], o = novo RegExp ("(^ | \\ s) bs-popover \\ S +", "g"), s = a ({}, h. Padrão, {colocação: " right ", trigger:" click ", content:" ", template: '<div class =" popover "role =" tooltip "> <div class =" arrow "> </div> <h3 class =" popover-header "> </h3> <div class =" popover-body "> </div> </div> '}), u = a ({}, h.DefaultType, {content:" (string | elemento | função) "}), c = {FADE:" fade ", MOSTRAR:" show "}, l = {TÍTULO:". popover-header ", CONTEÚDO:". popover-body "}, f = {HIDE:" ocultar " + n, OCULTO: "oculto" + n, MOSTRAR: "mostrar" + n, MOSTRAR: "mostrado" + n, INSERIDO: "inserido "+ n, CLIQUE:" click "+ n, FOCUSIN:" focusin "+ n, FOCUSOUT:" focusout "+ n, MOUSEENTER:" mouseenter "+ n, MOUSELEAVE:" mouseleave "+ n}, p = função ( r) {var a, p; função d () {retornar r.apply (isto, argumentos) || este} p = r, (a = d) .protótipo = Object.create (p.protótipo), a.protótipo .constructor = a, a .__ proto __ = p; var h = d.prototype; return h.isWithContent = function () {return this.getTitle () || this._getContent ()}, h.addAttachmentClass = function (t) {e (this.getTipElement ()). addClass ("bs-popover -" + t)}, h.getTipElement = function () {return this.tip = this.tip || e (this.config.template) [ 0], this.tip}, h.setContent = function () {var t = e (this.getTipElement ()); this.setElementContent (t.find (l.TITLE), this.getTitle ()); var n = this._getContent (); "função" == typeof n && (n = n.call (this.element)), this.setElementContent (t.find (l.CONTENT),n), t.removeClass (c.FADE + "" + c.SHOW)}, h._getContent = function () {return this.element.getAttribute ("data-content") || this.config.content}, h ._cleanTipClass = function () {var t = e (this.getTipElement ()), n = t.attr ("classe"). match (o); null! == n && n.length> 0 && t.removeClass (n.join (""))}, d._jQueryInterface = function (t) {return this.each (function () {var n = e (this) .data ("bs.popover"), r = "object" == typeof t? t: null; if ((n ||! / destruir | ocultar / .teste (t)) && (n || (n = novo d (este, r), e (este) .data ("bs. popover ", n))," string "== typeof t)) {if (void 0 === n [t]) throw new TypeError ('Nenhum método chamado"' + t + '"'); n [t] ()}})}, i (d, null, [{key: "VERSION", get: function () {return "4.1.3"}}, {key: "Default", get: function () {return s}}, {chave: "NOME", obtenha:function () {return t}}, {key: "DATA_KEY", get: function () {return "bs.popover"}}, {key: "Event", get: function () {return f}}, { tecla: "EVENT_KEY", get: function () {return n}}, {key: "DefaultType", get: function () {return u}}]), d} (h); return e.fn [t] = p._jQueryInterface, e.fn [t] .Constructor = p, e.fn [t] .noConflict = function () {return e.fn [t] = r, p._jQueryInterface}, p} (t), g = função (e) {var t = "scrollspy", n = e.fn [t], r = {deslocamento: 10, método: "auto", destino: ""}, o = {deslocamento: "número" , método: "string", destino: "(string | elemento)"}, u = {ATIVAR: "activate.bs.scrollspy", SCROLL: "scroll.bs.scrollspy", LOAD_DATA_API: "load.bs.scrollspy. data-api "}, c = {DROPDOWN_ITEM:" dropdown-item ", DROPDOWN_MENU:" dropdown-menu ", ACTIVE:" active "}, l = {DATA_SPY: '[data-spy = "scroll"] ', ACTIVE: ". active", NAV_LIST_GROUP: ". nav, .list-group", NAV_LINKS: ". nav-link", NAV_ITEMS: ". nav-item", LIST_ITEMS: ".list-group-item", DROPDOWN: ". dropdown", DROPDOWN_ITEMS: ". dropdown-item", DROPDOWN_TOGGLE: ". dropdown-toggle"}, f = {OFFSET: "offset", POSITION: "position"} , p = function () {function n (t, n) {var r = this; this._element = t, this._scrollElement = "BODY" === t.tagName? window: t, this._config = this. _getConfig (n), this._selector = this._config.target + "" + l.NAV_LINKS + "," + this._config.target + "" + l.LIST_ITEMS + "," + this._config.target + "" + l.DROPDOWN_ITEMS , this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, e (this._scrollElement) .on (u.SCROLL, function (e) {return r._process (e)}), this.refresh (), this._process ()} var p = n.prototype; return p.refresh = function () {var t = this, n = this._scrollElement === this. _scrollElement.window? f.OFFSET: f.POSITION, r = "auto" === this._config.method? n: this._config.method, i = r === f.POSITION? this._getScrollTop (): 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight (); var o = []. Slice.call (document.querySelectorAll (this._selector)); o.map ( função (t) {var n, o = s.getSelectorFromElement (t); if (o && (n = document.querySelector (o)), n) {var a = n.getBoundingClientRect (); if (a.width || a.height) return [e (n) [r] (). top + i, o]} return null}). filter (function (e) {return e}). sort (function (e, t) {return e [0] -t [0]}). forEach (function (e) {t._offsets.push (e [0]), t._targets.push (e [1])})}, p.dispose = function () {e.removeData (this._element, "bs.scrollspy"), e (this._scrollElement) .off (". bs.scrollspy "), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null}, p._getConfig = function (n) {if ("string"! = typeof (n = a ({}, r, "object" == typeof n && n? n: {})). target) {var i = e (n.target) .attr ("id"); i || (i = s.getUID (t), e (n.target) .attr ("id", i)), n.target = " # "+ i} return s.typeCheckConfig (t, n, o), n}, p._getScrollTop = function () {return this._scrollElement === window? this._scrollElement.pageYOffset: this._scrollElement.scrollTop}, p._getScrollHeight = function () {return this._scrollElement.scrollHeight || Math.max (document.body.scrollHeight, document.documentElement.scrollHeight)}, p._getOffsetHeight = function () {return this._scrollElement === window ? window.innerHeight: this._scrollElement.getBoundingClientRect ().height}, p._process = function () {var e = this._getScrollTop () + this._config.offset, t = this._getScrollHeight (), n = this._config.offset + t-this._getOffsetHeight (); if (this._scrollHeight! == t && this.refresh (), e> = n) {var r = this._targets [this._targets.length-1]; this._activeTarget! == r && this._activate (r)} else {if (this._activeTarget && e <this._offsets [0] && this._offsets [0]> 0) return this._activeTarget = null, void this._clear (); for (var i = this._offsets.length, o = i ; o -;) {var a = this._activeTarget! == this._targets [o] && e> = this._offsets [o] && (void 0 === this._offsets [o + 1] || e < this._offsets [o + 1]); a && this._activate (this._targets [o])}}}, p._activate = function (t) {this._activeTarget = t, this._clear (); var n = this ._selector.split (","); n = n.map (função (e) {return e + '[data-target = "' + t + '"],' + e + '[href = "'+ t +'"] '}); var r = e ([]. slice.call (document.querySelectorAll (n.join (","))))); r.hasClass (c.DROPDOWN_ITEM) ? (r.closest (l.DROPDOWN) .find (l.DROPDOWN_TOGGLE) .addClass (c.ACTIVE), r.addClass (c.ACTIVE)) :( r.addClass (c.ACTIVE), r.parents (l .NAV_LIST_GROUP) .prev (l.NAV_LINKS + "," + l.LIST_ITEMS) .addClass (c.ACTIVE), r.parents (l.NAV_LIST_GROUP) .prev (l.NAV_ITEMS) .children (l.NAV_LINKS) .addClass ( c.ACTIVE)), e (this._scrollElement) .trigger (u.ACTIVATE, {relatedTarget: t})}, p._clear = function () {var t = []. slice.call (document.querySelectorAll (this ._selector)); e (t) .filter (l.ACTIVE) .removeClass (c.ACTIVE)}, n._jQueryInterface = function (t) {return this.each (function () {var r = e (this) .data ("bs.scrollspy"), i = "object" == typeof t && t; if (r || (r = new n (this, i), e (this) .data ("bs.scrollspy", r )),"corda"== typeof t) {if (void 0 === r [t]) throw new TypeError ('Nenhum método chamado "' + t + '"'); r [t] ()}})}, i (n, nulo, [{chave: "VERSÃO", obter: função () {retornar "4.1.3"}}, {chave: "Padrão", obter: função () {retornar r}}]), n} (); return e (window) .on (u.LOAD_DATA_API, function () {for (var t = []. slice.call (document.querySelectorAll (l.DATA_SPY)), n = t.length, r = n; r- -;) {var i = e (t [r]); p._jQueryInterface.call (i, i.data ())}}), e.fn [t] = p._jQueryInterface, e.fn [t] .Constructor = p, e.fn [t] .noConflict = function () {return e.fn [t] = n, p._jQueryInterface}, p} (t), m = function (e) {var t = e .fn.tab, n = {OCULTAR: "hide.bs.tab", OCULTAR: "hidden.bs.tab", MOSTRAR: "show.bs.tab", MOSTRAR: "mostrado.bs.tab", CLICK_DATA_API: "click.bs.tab.data-api"}, r = {DROPDOWN_MENU: "menu suspenso", ATIVO: "ativo", DESATIVADO: "desativado",FADE: "fade", SHOW: "show"}, o = {DROPDOWN: ". Dropdown", NAV_LIST_GROUP: ". Nav, .list-group", ACTIVE: ". Active", ACTIVE_UL: "> li> .active ", DATA_TOGGLE: '[data-toggle =" tab "], [data-toggle =" pill "], [data-toggle =" list "]', DROPDOWN_TOGGLE:". Dropdown-toggle ", DROPDOWN_ACTIVE_CHILD:">. menu suspenso .active "}, a = função () {função t (e) {this._element = e} var a = t.prototype; return a.show = function () {var t = this; if (! (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && e (this._element) .hasClass (r.ACTIVE) || e (this._element) .hasClass (r.DISABLED))) {var i , a, u = e (this._element) .closest (o.NAV_LIST_GROUP) [0], c = s.getSelectorFromElement (this._element); if (u) {var l = "UL" === u.nodeName ? o.ACTIVE_UL: o.ACTIVE; a = (a = e.makeArray (e (u) .find (l))) [a.length-1]} var f = e.Event (n.HIDE, {relatedTarget: this._element}), p = e.Event (n.SHOW , {relatedTarget: a}); if (a && e (a) .trigger (f), e (this._element) .trigger (p) ,! p.isDefaultPrevented () &&! f.isDefaultPrevented ()) {c && (i = document.querySelector (c)), this._activate (this._element, u); var d = function () {var r = e.Event (n.HIDDEN, {relatedTarget: t._element}), i = e .Event (n.SHOWN, {relatedTarget: a}); e (a) .trigger (r), e (t._element) .trigger (i)}; i? This._activate (i, i.parentNode, d ): d ()}}}, a.dispose = function () {e.removeData (this._element, "bs.tab"), this._element = null}, a._activate = function (t, n, i ) {var a = this, u = ("UL" === n.nome do nó? e (n) .find (o.ACTIVE_UL): e (n) .children (o.ACTIVE)) [0], c = i && u && e (u) .hasClass (r.FADE), l = function () {return a._transitionComplete (t, u, i)}; if (u && c) {var f = s.getTransitionDurationFromElement (u); e (u) .one (s.TRANSITION_END, l) .emulateTransitionEnd (f)} else l ()}, a._transitionComplete = function (t, n, i) {if (n) {e ( n) .removeClass (r.SHOW + "" + r.ACTIVE); var a = e (n.parentNode) .find (o.DROPDOWN_ACTIVE_CHILD) [0]; a && e (a) .removeClass (r.ACTIVE), "tab "=== n.getAttribute (" role ") && n.setAttribute (" aria-selected ",! 1)} if (e (t) .addClass (r.ACTIVE)," tab "=== t.getAttribute ( "papel") && t.setAttribute ("aria-selected",! 0), s.reflow (t), e (t) .addClass (r.SHOW), t.parentNode && e (t.parentNode) .hasClass (r. DROPDOWN_MENU)) {var u = e (t) .mais próximo (o.DROPDOWN) [0]; if (u) {var c = []. Slice.call (u.querySelectorAll (o.DROPDOWN_TOGGLE)); e (c ) .addClass (r.ACTIVE)} t.setAttribute ("aria-extended",! 0)} i && i ()}, t._jQueryInterface = function (n) {return this.each (function () {var r = e (this), i = r.data ("bs.tab"); if (i || (i = new t (this), r.data ("bs.tab") , i)), "string" == typeof n) {if (void 0 === i [n]) throw new TypeError ('Nenhum método chamado "' + n + '"'); i [n] ()} })}, i (t, null, [{chave: "VERSÃO", obter: função () {retornar "4.1.3"}}]), t} (); retornar e (documento) .on (n. CLICK_DATA_API, o.DATA_TOGGLE, function (t) {t.preventDefault (), a._jQueryInterface.call (e (this), "show")}), e.fn.tab = a._jQueryInterface, e.fn.tab .Constructor = a, e.fn.tab.noConflict = function () {return e.fn.tab = t, a._jQueryInterface}, a} (t); (function (e) {if (void 0 === e) lançar um novo TypeError ("O JavaScript do Bootstrap requer jQuery. jQuery deve ser incluído antes do JavaScript do Bootstrap."); var t = e.fn.jquery.split ("") [0] .split ("."); if ( t [0] <2 && t [1] <9 || 1 === t [0] && 9 === t [1] && t [2] <1 || t [0]> = 4) lançar novo erro ("JavaScript do Bootstrap requer pelo menos jQuery v1.9.1, mas menos que v4.0.0")}) (t ), e.Util = s, e.Alert = u, e.Button = c, e.Carrossel = l, e.Colapso = f, e.Dropdown = p, e.Modal = d, e.Popover = v, e.Scrollspy = g, e.Tab = m, e.Tooltip = h, Object.defineProperty (e, "__ esModule", {value:! 0})} (t, n (4), n (3))} , função (e, t, n) {e.exportações = n (18)}, função (e, t, n) {"usar estrito"; var r = n (0), i = n (5), o = n (20), a = n (2); função s (e) {var t = novo o (e), n = i (o.protótipo.request, t); retornar r.extend (n, o. protótipo, t), r.extend (n, t), n} var u = s (a); u.Axios = o, u.create = função (e) {return s (r.merge (a, e) )}, u.Cancelar = n (10), u.CancelarToken = n (34), u.isCancelar = n (9), u.all = função (e) {retornar Promessa.all (e)}, u. spread = n (35), e.exports = u, e.exports.default = u}, function (e, t) {function n (e) {return !! e.constructor && "function"== typeof e.constructor.isBuffer && e.constructor.isBuffer (e)} e.exports = function (e) {return null! = e && (n (e) || function (e) {return "function" == typeof e .readFloatLE && "function" == typeof e.slice && n (e.slice (0,0))} (e) || !! e._isBuffer)}}, function (e, t, n) {"use strict"; var r = n (2), i = n (0), o = n (29), a = n (30); função s (e) {this.defaults = e, this.interceptors = {request: new o , resposta: novo o}} s.prototype.request = função (e) {"string" == tipo de e && (e = i.merge ({url: argumentos [0]}, argumentos [1])), (e = i.merge (r, {method: "get"}, this.defaults, e)). method = e.method.toLowerCase (); var t = [a, void 0], n = Promise.resolve (e ); para (this.interceptors.request.forEach (function (e) {t.unshift (e.fulfilled, e.rejected)}), this.interceptors.response.forEach (function (e) {t.push (e .realizado, e.rejeitado)}); t.length;) n = n.então (t.shift (),t.shift ()); return n}, i.forEach (["delete", "get", "head", "options"], function (e) {s.prototype [e] = function (t, n ) {return this.request (i.merge (n || {}, {method: e, url: t}))}}), i.forEach (["post", "put", "patch"], function (e) {s.prototype [e] = function (t, n, r) {return this.request (i.merge (r || {}, {method: e, url: t, data: n}) )}}), e.exports = s}, function (e, t, n) {"use strict"; var r = n (0); e.exports = function (e, t) {r.forEach (e , função (n, r) {r! == t && r.toUpperCase () === t.toUpperCase () && (e [t] = n, excluir e [r])})}}, função (e, t , n) {"use strict"; var r = n (8); e.exports = function (e, t, n) {var i = n.config.validateStatus; n.status && i &&! i (n.status)? t (r ("Solicitação falhou com o código de status" + n.status, n.config, null, n.request, n)): e (n)}}, função (e, t, n) {"usar estrito" ; e.exportações = função (e, t, n, r, i) {return e.config = t, n && (e.code = n), e.request = r, e.response = i, e}}, função (e , t, n) {"use strict"; var r = n (0); função i (e) {retornar encodeURIComponent (e) .replace (/% 40 / gi, "@"). replace (/% 3A / gi, ":"). substituir (/% 24 / g, "$"). substituir (/% 2C / gi, ","). substituir (/% 20 / g, "+"). substituir (/% 5B / gi, "["). Substituir (/% 5D / gi, "]")} e.exportações = função (e, t, n) {if (! T) return e; var o; if (n) o = n (t); else if (r.isURLSearchParams (t)) o = t.toString (); else {var a = []; r.forEach (t, function (e, t) {null! = e && (r.isArray (e)? t + = "[]": e = [e], r.forEach (e, função (e) {r.isDate (e)? e = e.toISOString (): r.isObject (e) && (e = JSON.stringify (e)), a.push (i (t) + "=" + i (e))}))}), o = a.join ("&")} return o && (e + = (- 1 === e.indexOf ("?")? "?": "&") + o),e}}, função (e, t, n) {"usar estrito"; var r = n (0), i = ["idade", "autorização", "comprimento do conteúdo", "tipo de conteúdo", " etag "," expira "," de "," host "," se-modificado-desde "," se-não modificado-desde "," última modificação "," localização "," max-encaminhamento "," proxy- autorização "," referenciador "," tentar novamente "," agente do usuário "]; e.exportações = função (e) {var t, n, o, a = {}; retornar e? (r.paraEach (e .split ("\ n"), function (e) {if (o = e.indexOf (":"), t = r.trim (e.substr (0, o)). toLowerCase (), n = r .trim (e.substr (o + 1)), t) {if (a [t] && i.indexOf (t)> = 0) return; a [t] = "set-cookie" === t? ( a [t]? a [t]: []). concat ([n]): a [t]? a [t] + "," + n: n}}), a): a}}, função (e, t, n) {"usar estrito"; var r = n (0); e.exportações = r.isStandardBrowserEnv ()? function () {var e, t = / (msie | trident) /i.test (navigator.userAgent), n = document.createElement ("a"); função i (e) {var r = e ; return t && (n.setAttribute ("href", r), r = n.href), n.setAttribute ("href", r), {href: n.href, protocolo: n.protocol? n.protocol. substituir (/: $ /, ""): "", host: n.host, pesquisar: n.search? n.search.replace (/ ^ \? /, ""): "", hash: n.hash ? n.hash.replace (/ ^ # /, ""): "", hostname: n.hostname, porta: n.port, pathname: "/" === n.pathname.charAt (0)? n. pathname: "/" + n.pathname}} return e = i (window.location.href), function (t) {var n = r.isString (t)? i (t): t; return n.protocol = == e.protocol && n.host === e.host}} (): function () {return! 0}}, function (e, t, n) {"use strict"; var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123" = "=" ;function i () {this.message = "String contém um caractere inválido"} i.prototype = new Error, i.prototype.code = 5, i.prototype.name = "InvalidCharacterError", e.exports = function (e) {para (var t, n, o = String (e), a = "", s = 0, u = r; o.charAt (0 | s) || (u = "=", s% 1); a + = u.charAt (63 & t >> 8-s% 1 * 8)) {if ((n = o.charCodeAt (s + =. 75))> 255) lançar novo i; t = t << 8 | n} retornar a}}, função (e, t, n) {"usar estrito"; var r = n (0); e.exports = r.isStandardBrowserEnv ()? {escrever: função (e, t, n, i, o, a) {var s = []; s.push (e + "=" + encodeURIComponent (t)), r.isNumber (n) && s.push ("expira =" + nova Data (n) .toGMTString () ), r.isString (i) && s.push ("caminho =" + i), r.isString (o) && s.push ("domínio =" + o) ,! 0 === a && s.push ("seguro" ), document.cookie = s.join (";")}, leia: função (e) {var t = document.cookie.match (new RegExp ("(^ |; \\ s *) (" + e + ") = ([^;] *)")); retornar t? decodeURIComponent (t [3]): null}, remover: função (e) {this.write (e, "", Date.now () - 864e5)}}: {escrever: função () {}, ler: função () {retornar nulo}, remover: função () {} }}, função (e, t, n) {"usar estrito"; var r = n (0); função i () {this.handlers = []} i.protótipo.use = função (e, t) { retornar this.handlers.push ({preenchido: e, rejeitado: t}), this.handlers.length-1}, i.prototype.eject = function (e) {this.handlers [e] && (this.handlers [ e] = null)}, i.prototype.forEach = function (e) {r.forEach (this.handlers, function (t) {null! == t && e (t)})}, e.exports = i}, função (e, t, n) {"usar estrito"; var r = n (0), i = n (31), o = n (9), a = n (2), s = n (32), u = n (33); função c (e) {e.cancelToken && e.cancelToken.throwIfRequested ()} e.exports = function (e) {return c (e), e.baseURL &&! s (e.url) && ( e.url = u (e.baseURL, e.url)), e.headers = e.headers || {}, e.data = i (e.data, e.headers, e.transformRequest), e.headers = r.merge (e.headers .common || {}, e.headers [e.method] || {}, e.headers || {}), r.forEach (["delete", "get", "head", "post", "put", "patch", "common"], function (t) {delete e.headers [t]}), (e.adapter || a.adapter) (e) .then (function (t) {return c (e), t.data = i (t.data, t.headers, e.transformResponse), t}, função (t) {return o (t) || (c (e), t && t.response && (t .response.data = i (t.response.data, t.response.headers, e.transformResponse))), Promise.reject (t)})}}, function (e, t, n) {"use estrito" ; var r = n (0); e.exports = function (e, t, n) {return r.forEach (n, function (n) {e = n (e, t)}), e}}, function (e, t, n) {"usar estrito"; e.exports = function (e) {return / ^ ([az] [az \ d \ + \ - \.] *:)? \ / \ // i .test (e)}}, função (e, t, n) {"use estrito "; e.exports = function (e, t) {return t? e.replace (/ \ / + $ /," ") +" / "+ t.replace (/ ^ \ / + /," " ): e}}, função (e, t, n) {"usar estrito"; var r = n (10); função i (e) {if ("função"! = tipo de e) lançar novo TypeError ("executor deve ser uma função. "); var t; this.promise = new Promise (function (e) {t = e}); var n = this; e (function (e) {n.reason || (n.reason = new r (e), t (n.reason))})} i.prototype.throwIfRequested = function () {if (this.reason) throw this.reason}, i.source = function () {var e; return {token: new i (function (t) {e = t}), cancelar: e}}, e.exports = i}, function (e, t, n) {"use strict"; e.exports = function (e) {return function (t) {return e.apply (null, t)}}}, function (e, t, n) {"use strict"; (function (t, n) {var r = Object. freeze ({}); função i (e) {return null == e} função o (e) {return null! = e} função a (e) {return!0 === e} função s (e) {return "string" == typeof e || "number" == typeof e || "symbol" == typeof e || "boolean" == typeof e} função u (e) {return null! == e && "object" == typeof e} var c = Object.prototype.toString; função l (e) {return "[object Object]" === c.call (e)} função f (e) {return "[object RegExp]" === c.call (e)} função p (e) {var t = parseFloat (String (e)); return t> = 0 && Math.floor (t) === t && isFinite (e)} função d (e) {return null == e? "": "object" == typeof e? JSON.stringify (e, null, 2): String (e)} função h ( e) {var t = parseFloat (e); retornar isNaN (t)? e: t} função v (e, t) {para (var n = Object.create (nulo), r = e.split ("," ), i = 0; i <r.length; i ++) n [r [i]] =! 0; return t? função (e) {return n [e.toLowerCase ()]}: function (e) {return n [e]}} var g = v ("slot, componente",! 0), m = v ("chave, ref, slot, slot-scope, is "); função y (e, t) {if (e.length) {var n = e.indexOf (t); if (n> -1) return e.splice (n, 1)}} var _ = Object.prototype.hasOwnProperty; função b (e, t) {return _.call (e, t)} função w (e) {var t = Object.create (null); função de retorno (n) {retorno t [n] || (t [n] = e (n))}} var T = / - (\ w) / g, E = w (função (e) {retorno e. substituir (T, função (e, t) {retornar t? t.toUpperCase (): ""})}), x = w (função (e) {retornar e.charAt (0) .toUpperCase () + e. fatia (1)}), C = / \ B ([AZ]) / g, A = w (função (e) {return e.replace (C, "- $ 1"). toLowerCase ()}); var S = Function.prototype.bind? Function (e, t) {return e.bind (t)}: function (e, t) {function n (n) {var r = arguments.length; return r? R> 1? e.aplicar (t, argumentos): e.call (t, n): e.call (t)} retornar n._length = e.length, n}; função O (e, t) {t = t || 0; para (var n = e.length-t, r = new Array (n); n -;) r [n] = e [n + t]; retornar r} função D (e, t) {para (var n em t) e [n] = t [n];retornar e} função I (e) {para (var t = {}, n = 0; n <e.length; n ++) e [n] && D (t, e [n]); retornar t} função k (e , t, n) {} var N = função (e, t, n) {retornar! 1}, L = função (e) {retornar e}; função j (e, t) {if (e === t ) return! 0; var n = u (e), r = u (t); if (! n ||! r) return! n &&! r && String (e) === String (t); tente {var i = Array.isArray (e), o = Array.isArray (t); if (i && o) return e.length === t.length && e.every (function (e, n) {return j (e, t [n]) }); if (e instanceof Date && t instanceof Date) return e.getTime () === t.getTime (); if (i || o) return! 1; var a = Object.keys (e), s = Object .keys (t); return a.length === s.length && a.every (function (n) {return j (e [n], t [n])})} catch (e) {return! 1}} função P (e, t) {para (var n = 0; n <e.length; n ++) if (j (e [n], t)) retorno n; retorno-1} função R (e) {var t =! 1; função de retorno () {t || (t =! 0, e.apply (isto, argumentos))}} var $ = "dados-servidor-renderizados", H = ["componente "," diretiva "," filtro "], M = [" beforeCreate "," criado "," beforeMount "," montado "," beforeUpdate "," atualizado "," beforeDestroy "," destruído "," ativado " , "deactivated", "errorCaptured"], F = {optionMergeStrategies: Object.create (null), silent:! 1, ProductionTip:! 1, devtools:! 1, performance:! 1, errorHandler: null, warnHandler: null, ignoreElements: [], keyCodes: Object.create (null), isReservedTag: N, isReservedAttr: N, isUnknownElement: N, getTagNamespace: k, parsePlatformTagName: L, mustUseProp: N, assíncrono:! 0, _lifecycleHooks: M}; função (e, t, n, r) {Object.defineProperty (e, t, {valor: n, enumerável: !! r, gravável:! 0, configurável:! 0})} var q = / [^ \ w. $] /; var B, U = "__ proto __" in {}, V = "undefined"! = typeof window, z = "undefined"!= typeof WXEnvironment && !! WXEnvironment.platform, K = z && WXEnvironment.platform.toLowerCase (), G = V && window.navigator.userAgent.toLowerCase (), X = G && / msie | trident / .test (G), Q = G && G.index ("msie 9.0")> 0, Y = G && G.indexOf ("edge /")> 0, J = (G && G.indexOf ("android"), G && / iphone | ipad | ipod | ios / .test (G) || "ios" === K), Z = (G && / chrome \ / \ d + /. test (G), {}. watch), ee =! 1; if (V) tente {var te = {} ; Object.defineProperty (te, "passive", {get: function () {ee =! 0}}), window.addEventListener ("test-passive", null, te)} catch (e) {} var ne = function () {return void 0 === B && (B =! V &&! z && void 0! == t && (t.process && "server" === t.process.env.VUE_ENV)), B}, re = V && window. __VUE_DEVTOOLS_GLOBAL_HOOK __; função ie (e) {return "função "== typeof e && / native code / .test (e.toString ())} var oe, ae =" undefined "! = typeof Symbol && ie (Symbol) &&" undefined "! = typeof Reflect && ie (Reflect.ownKeys); oe = "undefined"! = typeof Set && ie (Set)? Set: function () {function e () {this.set = Object.create (null)} return e.prototype.has = function (e) {return! 0 = == this.set [e]}, e.prototype.add = function (e) {this.set [e] =! 0}, e.prototype.clear = function () {this.set = Object.create ( null)}, e} (); var se = k, ue = 0, ce = function () {this.id = ue ++, this.subs = []}; ce.prototype.addSub = function (e) {this .subs.push (e)}, ce.prototype.removeSub = function (e) {y (this.subs, e)}, ce.prototype.depend = function () {ce.target && ce.target.addDep (this) }, ce.prototype.notify = function () {var e = this.subs.slice (); para (var t = 0, n = e.length; t <n; t ++) e [t] .update () }, ce.target = null; var le = [];função fe (e) {le.push (e), ce.target = e} função pe () {le.pop (), ce.target = le [le.length-1]} var de = função (e, t, n, r, i, o, a, s) {this.tag = e, this.data = t, this.children = n, this.text = r, this.elm = i, this.ns = void 0, this.context = o, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = t && t.key, this.componentOptions = a, this.componentInstance = void 0, this.parent = void 0, this.raw =! 1, this.isStatic =! 1, this.isRootInsert =! 0, this.isComment =! 1, this.isCloned =! 1, this.isOnce =! 1, este .asyncFactory = s, this.asyncMeta = void 0, this.isAsyncPlaceholder =! 1}, he = {filho: {configurável:! 0}}; he.child.get = function () {return this.componentInstance}, Object .defineProperties (de.prototype, he); var ve = function (e) {void 0 === e && (e = ""); var t = new de; return t.text = e, t.isComment =! 0 , t}; função ge (e) {return new de (void 0, void 0, void 0,String (e))} function me (e) {var t = new de (e.tag, e.data, e.children && e.children.slice (), e.text, e.elm, e.context, e. componentOptions, e.asyncFactory); return t.ns = e.ns, t.isStatic = e.isStatic, t.key = e.key, t.isComment = e.isComment, t.fnContext = e.fnContext, t. fnOptions = e.fnOptions, t.fnScopeId = e.fnScopeId, t.asyncMeta = e.asyncMeta, t.isCloned =! 0, t} var ye = Array.prototype, _e = Object.create (ye); ["push "," pop "," shift "," unshift "," splice "," sort "," reverse "]. forEach (function (e) {var t = ye [e]; W (_e, e, function ( ) {para (var n = [], r = argumentos.comprimento; r -;) n [r] = argumentos [r]; var i, o = t.aplicar (isto, n), a = isto .__ ob__ ; switch (e) {case "push": case "unshift": i = n; break; case "splice": i = n.slice (2)} return i && a.observeArray (i), a.dep.notify ( ), o})}); var be = Object.getOwnPropertyNames (_e), we =! 0;função Te (e) {we = e} var Ee = function (e) {var t; this.value = e, this.dep = new ce, this.vmCount = 0, W (e, "__ ob __", this) , Array.isArray (e)? (U? (T = _e, e .__ proto __ = t): função (e, t, n) {para (var r = 0, i = n.length; r <i; r ++ ) {var o = n [r]; W (e, o, t [o])}} (e, _e, ser), this.observeArray (e)): this.walk (e)}; função xe ( e, t) {var n; if (u (e) &&! (e instanceof de)) return b (e, "__ ob __") && e .__ ob__ instanceof Ee? n = e .__ ob __: we &&! ne () && ( Array.isArray (e) || l (e)) && Object.isExtensible (e) &&! E._isVue && (n = new Ee (e)), t && n && n.vmCount ++, n} função Ce (e, t, n, r , i) {var o = new ce, a = Object.getOwnPropertyDescriptor (e, t); if (! a ||! 1! == a.configurável) {var s = a && a.get, u = a && a.set; s &&! u || 2! == argumentos.length || (n = e [t]); var c =! i && xe (n); Object.defineProperty (e, t, {enumerable:! 0, configurável:! 0 ,pegue:function () {var t = s? s.call (e): n; return ce.target && (o.depend (), c && (c.dep.depend (), Array.isArray (t) && function e (t) {para (var n = void 0, r = 0, i = t.length; r <i; r ++) (n = t [r]) && n .__ ob __ && n .__ ob __. dep.depend (), Array.isArray (n ) && e (n)} (t))), t}, defina: função (t) {var r = s? s.call (e): n; t === r || t! = t && r! = r || s &&! u || (u? u.call (e, t): n = t, c =! i && xe (t), o.notify ())}})}} função Ae (e, t, n ) {if (Array.isArray (e) && p (t)) return e.length = Math.max (e.length, t), e.splice (t, 1, n), n; if (t em e &&! (t em Object.prototype)) return e [t] = n, n; var r = e .__ ob __; return e._isVue || r && r.vmCount? n: r? (Ce (r.valDeps = n, this.newDeps.length = 0}, Nt.prototype.update = function () {this.lazy? This.dirty =! 0: this.sync? This.run (): function (e) {var t = e.id; if (null == At [t]) {if (At [t] =! 0, Ot) {for (var n = xt.length-1; n> Dt && xt [n] .id> e.id;) n -; xt.splice (n + 1,0, e)} else xt.push (e); St || (St =! 0, Je (It))}} (this)} , Nt.prototype.run = function () {if (this.active) {var e = this.get (); if (e! == this.value || u (e) || this.deep) {var t = this.value; if (this.value = e, this.user) tente {this.cb.call (this.vm, e, t)} catch (e) {Fe (e, this.vm, 'callback para observador "'+ this.expression +'" ')} else this.cb.call (this.vm, e, t)}}}, Nt.prototype.evaluate = function () {this.value = this.get ( ), this.dirty =! 1}, Nt.prototype.depend = function () {for (var e = this.deps.length; e -;) this.deps [e] .depend ()}, Nt. prototype.teardown = function () {if (this.active) {this.vm._isBeingDestroyed || y (this.vm._watchers, this); for (var e = this.deps.length; e -;) this.deps [e] .removeSub (this); this.active =! 1}}; var Lt = {enumerable:! 0, configurable:! 0, get: k, set: k}; função jt (e, t, n) {Lt.get = function () {return this [t] [n]}, Lt.set = function (e) {this [t] [n] = e} , Object.defineProperty (e, n, Lt)} função Pt (e) {e._watchers = []; var t = e. $ Options; t.props && function (e, t) {var n = e. $ Options. propsData || {}, r = e._props = {}, i = e. $ options._propKeys = []; e. $ parent && Te (! 1); var o = function (o) {i.push (o) ; var a = Re (o, t, n, e); Ce (r, o, a), o em e || jt (e, "_ props", o)}; para (var a em t) o ( a); Te (! 0)} (e, t.props), t.methods && function (e, t) {e. $ options.props; for (var n in t) e [n] = "função"! = tipo de t [n]? k: S (t [n], e)} (e, t.métodos), t.data? função (e) {var t = e. $ options.data; l (t = e ._data = "função" == typeof t? function (e, t) {fe (); tente {return e.call (t, t)} catch (e) {return Fe (e, t, "data () "), {}} finalmente {pe ()}} (t,e): t || {}) || (t = {}); var n = Object.keys (t), r = e. $ options.props, i = (e. $ options.methods, n.length ); para (; i -;) {var o = n [i]; 0, r && b (r, o) || (a = vazio 0,36! == (a = (o + ""). charCodeAt ( 0)) && 95! == a && jt (e, "_ dados", o))} var a; xe (t,! 0)} (e): xe (e._data = {} ,! 0), t.computed && function (e, t) {var n = e._computedWatchers = Object.create (null), r = ne (); para (var i in t) {var o = t [i], a = "função" == typeof o? o: o.get; 0, r || (n [i] = novo Nt (e, a || k, k, Rt)), i em e || $ t (e, i, o)} } (e, t.computado), t.watch && t.watch! == Z && função (e, t) {para (var n em t) {var r = t [n]; if (Array.isArray (r)) para (var i = 0; i <r.length; i ++) Ft (e, n, r [i]); else Ft (e, n, r)}} (e, t.watch)} var Rt = {preguiçoso :! 0}; função $ t (e, t, n) {var r =! Ne (); "função" == typeof n? (Lt.get = r? Ht (t): Mt (n), Lt .set = k) :( Lt.get = n.get? r &&! 1! == n.cache? Ht (t): Mt (n.get): k, Lt.set = n.set || k) ,Objeto.defineProperty (e, t, Lt)} função Ht (e) {return function () {var t = this._computedWatchers && this._computedWatchers [e]; if (t) return t.dirty && t.evaluate (), ce.target && t.depend (), t.valor}} função Mt (e) {return function () {return e.call (this, this)}} função Ft (e, t, n, r) {return l (n) && (r = n, n = n.handler), "string" == typeof n && (n = e [n]), e. $ watch (t, n, r)} função Wt (e, t) {if (e) {for (var n = Object.create (null), r = ae? Reflect.ownKeys (e) .filter (function (t) {return Object.getOwnPropertyDescriptor (e, t) .enumerable}): Object.keys (e ), i = 0; i <r.length; i ++) {para (var o = r [i], a = e [o] .de, s = t; s;) {if (s._fornecido && b (s. _provided, a)) {n [o] = s._provided [a]; break} s = s. $ parent} if (! s) if ("default" in e [o]) {var u = e [o ] .default; n [o] = "função" == typeof u? u.call (t): u} else 0} return n}} função qt (e, t) {var n, r, i, a, s; if (Matriz.isArray (e) || "string" == typeof e) for (n = new Array (e.length), r = 0, i = e.length; r <i; r ++) n [r] = t (e [r], r); else if ("número" == tipo de e) para (n = novo Array (e), r = 0; r <e; r ++) n [r] = t (r + 1, r ); else if (u (e)) para (a = Object.keys (e), n = new Array (a.length), r = 0, i = a.length; r <i; r ++) s = a [r], n [r] = t (e [s], s, r); retornar o (n) || (n = []), n._isVList =! 0, n} função Bt (e, t , n, r) {var i, o = this. $ scopedSlots [e]; o? (n = n || {}, r && (n = D (D ({}, r), n)), i = o (n) || t): i = this. $ slots [e] || t; var a = n && n.slot; retornar a? this. $ createElement ("template", {slot: a}, i): i} função Ut (e) {return Pe (this. $ options, "filters", e) || L} função Vt (e, t) {return Array.isArray (e)? - 1 === e.indexOf (t): e! == t} função zt (e, t, n, r, i) {var o = F.keyCodes [t] || n; return i && r &&! F.keyCodes [t]? Vt (i , r): o? Vt (o, e): r? A (r)! == t: vazio 0} função Kt (e, t, n, r, i) {if (n) if (u (n )) {var o; Array.isArray (n) && (n = I (n)); var a = função (a) {if ("classe" === a || "estilo" === a || m (a)) o = e ; else {var s = e.attrs && e.attrs.type; o = r || F.mustUseProp (t, s, a)? e.domProps || (e.domProps = {}): e.attrs || ( e.attrs = {})} var u = E (a); a em o || u em o || (o [a] = n [a], i && ((e.on || (e.on = {})) ["atualizar:" + u] = função (e) {n [a] = e}))}; para (var s em n) a (s)} else; retornar e} função Gt (e , t) {var n = this._staticTrees || (this._staticTrees = []), r = n [e]; retornar r &&! t? r: (Qt (r = n [e] = this. $ options. staticRenderFns [e] .call (this._renderProxy, null, this), "__ static __" + e,! 1), r)} função Xt (e, t, n) {return Qt (e, "__ uma vez __" + t + ( n? "_" + n: "") ,! 0), e} função Qt (e, t, n) {if (Array.isArray (e)) para (var r = 0; r <e.length; r ++) e [r] && "string"! = tipo de e [r] && Yt (e [r], t + "_" + r, n); senão Yt (e, t, n)} função Yt (e, t , n) {e.isStatic =! 0, e.key = t, e.isOnce = n} função Jt (e, t) {if (t) if (l (t)) {var n = e.on = e.on? D ( {}, e.on): {}; para (var r em t) {var i = n [r], o = t [r]; n [r] = i? []. concat (i, o) : o}} else; retornar e} função Zt (e) {e._o = Xt, e._n = h, e._s = d, e._l = qt, e._t = Bt, e._q = j , e._i = P, e._m = Gt, e._f = Ut, e._k = zt, e._b = Kt, e._v = ge, e._e = ve, e._u = yt, e ._g = Jt} função en (e, t, n, i, o) {var s, u = o.options; b (i, "_ uid")? (s = Object.create (i)) ._ original = i: (s = i, i = i._original); var c = a (u._compilado), l =! c; this.data = e, this.props = t, this.children = n, this.parent = i, this.listeners = e.on || r, this.injections = Wt (u.inject, i), this.slots = function () {return gt (n, i)}, c && (this. $ options = u, isto. $ slots = this.slots (), isto. $ scopedSlots = e.scopedSlots || r), u._scopeId? this._c = function (e, t, n, r) {var o = ln (s, e, t, n, r, l); retornar o &&! Array.isArray (o) && (o.fnScopeId = u._scopeId, o.fnContext = i), o}: this._c = function (e , t, n, r) {return ln (s, e,t, n, r, l)}} função tn (e, t, n, r, i) {var o = me (e); retornar o.fnContext = n, o.fnOptions = r, t.slot && (( o.data || (o.data = {})). slot = t.slot), o} função nn (e, t) {para (var n em t) e [E (n)] = t [n ]} Zt (en.prototype); var rn = {init: function (e, t) {if (e.componentInstance &&! E.componentInstance._isDestroyed && e.data.keepAlive) {var n = e; rn.prepatch (n, n)} else {(e.componentInstance = function (e, t) {var n = {_ isComponent:! 0, _parentVnode: e, parent: t}, r = e.data.inlineTemplate; o (r) && (n .render = r.render, n.staticRenderFns = r.staticRenderFns); retornar novo e.componentOptions.Ctor (n)} (e, _t)). $ mount (t? e.elm: void 0, t)}} , prepatch: function (e, t) {var n = t.componentOptions;! function (e, t, n, i, o) {var a = !! (o || e. $ options._renderChildren || i. data.scopedSlots || e. $ scopedSlots! == r); if (e. $ options._parentVnode = i, e. $ vnode = i, e._vnode && (e._vnode.parent = i), e. $ options ._renderChildren = o, e.$ attrs = i.data.attrs || r, e. $ listeners = n || r, t && e. $ options.props) {Te (! 1); for (var s = e._props, u = e. $ options._propKeys || [], c = 0; c <u.length; c ++) {var l = u [c], f = e. $ options.props; s [l] = Re (l, f, t , e)} Te (! 0), e. $ options.propsData = t} n = n || r; var p = e. $ options._parentListeners; e. $ options._parentListeners = n, vt (e, n , p), a && (e. $ slots = gt (o, i.context), e. $ forceUpdate ())} (t.componentInstance = e.componentInstance, n.propsData, n.listeners, t, n.children )}, insira: função (e) {var t, n = e.context, r = e.componentInstance; r._isMounted || (r._isMounted =! 0, Et (r, "montado")), e. data.keepAlive && (n._isMounted? ((t = r) ._ inativo =! 1, Ct.push (t)): Tt (r,! 0))}, destruir: função (e) {var t = e. componentInstance; t._isDestroyed || (e.data.keepAlive? função e (t, n) {if (! (n && (t._directInactive =! 0, wt (t)) || t._inactive)) {t. _inativo =! 0; para (var r = 0; r <t. $ children.length; r ++) e (t.$ children [r]); Et (t, "desativado")}} (t,! 0): t. $ destroy ())}}, on = Object.keys (rn); função an (e, t, n, s, c) {if (! i (e)) {var l = n. $ options._base; if (u (e) && (e = l.extend (e)), "função" == typeof e) {var f; if (i (e.cid) && void 0 === (e = função (e, t, n) {if (a (e.error) && o (e.errorComp)) return e.errorComp ; if (o (e.resolved)) return e.resolved; if (a (e.loading) && o (e.loadingComp)) return e.loadingComp; if (! o (e.contexts)) {var r = e .contexts = [n], s =! 0, c = function (e) {for (var t = 0, n = r.length; t <n; t ++) r [t]. $ forceUpdate (); e && ( r.length = 0)}, l = R (função (n) {e.resolvido = ct (n, t), s || c (! 0)}), f = R (função (t) {o ( e.errorComp) && (e.error =! 0, c (! 0))}), p = e (l, f); retornar u (p) && ("função" == tipo de p.então? i ( e.resolvido) && p.then (l, f): o (p.component) && "função" == typeof p.component.then && (p.component.então (l, f), o (p.error) && (e.errorComp = ct (p.error, t)), o (p.loading) && (e.loadingComp = ct (p.loading, t), 0 === p.delay? E.loading =! 0: setTimeout (function () {i (e.resolved) && i (e.error) && (e.loading =! 0, c (! 1))}, p.delay || 200)), o (p.timeout) && setTimeout (function () {i (e.resolved) && f (null)}, p.timeout))), s =! 1, e.loading? e .loadingComp: e.resolved} e.contexts.push (n)} (f = e, l, n))) função de retorno (e, t, n, r, i) {var o = ve (); retornar o .asyncFactory = e, o.asyncMeta = {dados: t, contexto: n, filhos: r, tag: i}, o} (f, t, n, s, c); t = t || {}, pn (e), o (t.modelo) && função (e, t) {var n = e.modelo && e.modelo.prop || "valor", r = e.modelo && e.modelo.evento || "entrada"; (t .props || (t.props = {})) [n] = t.model.value; var i = t.on || (t.on = {}), a = i [r], s = t .model.callback; o (a)? (Array.isArray (a)? - 1 === a.indexOf (s): a! == s) && (i [r] = [s] .concat (a )): i [r] = s} (e.opções, t); var p = função (e, t, n) {var r = t.options.props; if (! i (r)) {var a = {}, s = e.attrs, u = e .props; if (o (s) || o (u)) for (var c in r) {var l = A (c); at (a, u, c, l,! 0) || at (a , s, c, l,! 1)} return a}} (t, e); if (a (e.options.functional)) função de retorno (e, t, n, i, a) {var s = e .opções, u = {}, c = s.props; if (o (c)) para (var l em c) u [l] = Re (l, c, t || r); senão o (n. attrs) && nn (u, n.attrs), o (n.props) && nn (u, n.props); var f = new en (n, u, a, i, e), p = s.render.call (null, f._c, f); if (p instanceof de) retorna tn (p, n, f.parent, s); if (Array.isArray (p)) {for (var d = st (p) | | [], h = new Array (d.length), v = 0; v <d.length; v ++) h [v] = tn (d [v], n, f.parent, s); return h} } (e, p, t, n, s); var d = t.on; if (t.on = t.nativoOn, a (e.options.abstract)) {var h = t.slot; t = { }, h && (t.slot = h)}! function (e) {for (var t = e.hook || (e.hook = {}), n = 0; n <on.length; n ++) {var r = on [n], i = t [r], o = rn [r]; i === o || i && i._merged || (t [r] = i? sn (o, i): o) }} (t);var v = e.options.name || c; return new de ("componente-vue -" + e.cid + (v? "-" + v: ""), t, vazio 0, vazio 0, vazio 0, n, {Ctor: e, propsData: p, listeners: d, tag: c, children: s}, f)}}} função sn (e, t) {var n = função (n, r) {e (n , r), t (n, r)}; retornar n._merged =! 0, n} var un = 1, cn = 2; função ln (e, t, n, r, c, l) {return (Array .isArray (n) || s (n)) && (c = r, r = n, n = vazio 0), a (l) && (c = cn), função (e, t, n, r, s ) {if (o (n) && o (n .__ ob __)) return ve (); o (n) && o (n.is) && (t = n.is); if (! t) return ve (); 0 ; Array.isArray (r) && "function" == typeof r [0] && ((n = n || {}). ScopedSlots = {default: r [0]}, r.length = 0); s = == cn? r = st (r): s === un && (r = function (e) {for (var t = 0; t <e.length; t ++) if (Array.isArray (e [t]) ) retornar Array.prototype.concat.apply ([], e); retornar e} (r)); var c, l; if ("string" == typeof t) {var f; l = e. $ vnode && e. $ vnode.ns || F.getTagNamespace (t), c = F.isReservedTag (t)? new de (F.parsePlatformTagName (t), n, r, void 0, void 0, e): n && n.pre ||! o (f = Pe (e . $ options, "components", t))? new de (t, n, r, void 0, void 0, e): an (f, n, e, r, t)} else c = an (t, n, e, r); retornar Array.isArray (c)? c: o (c)? (o (l) && função e (t, n, r) {t.ns = n; "objeto estrangeiro" === t .tag && (n = void 0, r =! 0); if (o (t.children)) para (var s = 0, u = t.children.length; s <u; s ++) {var c = t. filhos [s]; o (c.tag) && (i (c.ns) || a (r) && "svg"! == c.tag) && e (c, n, r)}} (c, l ), o (n) && função (e) {u (e.style) && et (e.style); u (e.class) && et (e.class)} (n), c): ve ()} (e , t, n, r, c)} var fn = 0; função pn (e) {var t = e.opções; if (e.super) {var n = pn (e.super); if (n! = = e.superOptions) {e.superOptions = n; var r = function (e) {var t, n = e.options, r = e.extendOptions, i = e.sealedOptions; para (var o em n) n [ o]! == i [o] &&(t || (t = {}), t [o] = dn (n [o], r [o], i [o])); retornar t} (e); r && D (e.extendOptions, r) , (t = e.options = je (n, e.extendOptions)). name && (t.components [t.name] = e)}} return t} função dn (e, t, n) {if (Array. isArray (e)) {var r = []; n = Array.isArray (n)? n: [n], t = Array.isArray (t)? t: [t]; for (var i = 0; i <e.length; i ++) (t.indexOf (e [i])> = 0 || n.indexOf (e [i]) <0) && r.push (e [i]); return r} return e} função hn (e) {this._init (e)} função vn (e) {e.cid = 0; var t = 1; e.extend = function (e) {e = e || {}; var n = this, r = n.cid, i = e._Ctor || (e._Ctor = {}); if (i [r]) retorna i [r]; var o = e.name || n.options.name ; var a = função (e) {this._init (e)}; return (a.prototype = Object.create (n.prototype)). constructor = a, a.cid = t ++, a.options = je (n .options, e), a.super = n, a.options.props && function (e) {var t = e.options.props; for (var n in t) jt (e.prototype, "_ props", n)} (a), a.options.computed &&função (e) {var t = e.options.computed; para (var n em t) $ t (e.protótipo, n, t [n])} (a), a.extend = n.extend, a. mixin = n.mixin, a.use = n.use, H.forEach (function (e) {a [e] = n [e]}), o && (a.options.components [o] = a), a .superOptions = n.options, a.extendOptions = e, a.sealedOptions = D ({}, a.options), i [r] = a, a}} função gn (e) {return e && (e.Ctor. options.name || e.tag)} function mn (e, t) {return Array.isArray (e)? e.indexOf (t)> - 1: "string" == typeof e? e.split (", ") .indexOf (t)> - 1: !! f (e) && e.test (t)} função yn (e, t) {var n = e.cache, r = e.keys, i = e._vnode ; para (var o em n) {var a = n [o]; if (a) {var s = gn (a.componentOptions); s &&! t (s) && _ n (n, o, r, i)}} } função _n (e, t, n, r) {var i = e [t] ;! i || r && i.tag === r.tag || i.componentInstance. $ destroy (), e [t] = null, y (n, t)}! function (e) {e.prototype._init = function (e) {var t = this; t._uid = fn ++, t._isVue =! 0, e && e._isComponent? function (e, t) {var n = e. $ options = Object.create (e.constructor.options), r = t._parentVnode; n.parent = t.parent, n._parentVnode = r; var i = r.componentOptions; n.propsData = i.propsData, n._parentListeners = i.listeners, n._renderChildren = i.children, n._componentTag = i.tag, t.render && (n.render = t.render, n .staticRenderFns = t.staticRenderFns)} (t, e): t. $ options = je (pn (t.constructor), e || {}, t), t._renderProxy = t, t._self = t, function (e) {var t = e. $ options, n = t.parent; if (n &&! t.abstract) {for (; n. $ options.abstract && n. $ parent;) n = n. $ parent; n. $ children.push (e)} e. $ parent = n, e. $ root = n? n. $ root: e, e. $ children = [], e. $ refs = {}, e._watcher = null , e._inactive = nulo, e._directInactive =! 1, e._isMounted =! 1, e._isDestroyed =! 1, e._isBeingDestroyed =! 1} (t), função (e) {e._events = Objeto. criar (nulo), e._hasHookEvent =! 1; var t = e. $ options._parentListeners; t && vt (e, t)} (t),function (e) {e._vnode = null, e._staticTrees = null; var t = e. $ options, n = e. $ vnode = t._parentVnode, i = n && n.context; e. $ slots = gt (t ._renderChildren, i), e. $ scopedSlots = r, e._c = function (t, n, r, i) {return ln (e, t, n, r, i,! 1)}, e. $ createElement = função (t, n, r, i) {retornar ln (e, t, n, r, i,! 0)}; var o = n && n.data; Ce (e, "$ attrs", o && o.attrs | | r, nulo,! 0), Ce (e, "$ listeners", t._parentListeners || r, nulo,! 0)} (t), Et (t, "beforeCreate"), função (e) {var t = Wt (e. $ options.inject, e); t && (Te (! 1), Object.keys (t) .forEach (function (n) {Ce (e, n, t [n])}), Te (! 0))} (t), Pt (t), função (e) {var t = e. $ Options.provide; t && (e._provided = "function" == typeof t? T.call (e ): t)} (t), Et (t, "criado"), t. $ options.el && t. $ mount (t. $ options.el)}} (hn), função (e) {var t = { get: function () {return this._data}}, n = {get: function () {return this._props}}; Objeto.defineProperty (e.prototype, "$ data", t), Object.defineProperty (e.prototype, "$ props", n), e.prototype. $ set = Ae, e.prototype. $ delete = Se, e. prototype. $ watch = function (e, t, n) {if (l (t)) return Ft (this, e, t, n); (n = n || {}). user =! 0; var r = new Nt (this, e, t, n); if (n.immediate) try {t.call (this, r.value)} catch (e) {Fe (e, this, 'callback para observador imediato "' + r.expression + '"')} return function () {r.teardown ()}}} (hn), function (e) {var t = / ^ hook: /; e.prototype. $ on = function (e , n) {var r = this; if (Array.isArray (e)) para (var i = 0, o = e.length; i <o; i ++) r. $ on (e [i], n); else (r._events [e] || (r._events [e] = [])). push (n), t.test (e) && (r._hasHookEvent =! 0); retornar r}, e. protótipo. $ uma vez = função (e, t) {var n = this; função r () {n. $ off (e, r), t.aplicar (n, argumentos)} retornar r.fn = t, n. $ on (e, r), n}, e.prototype. $ off = function (e, t) {var n = this; if (! arguments.length) return n._events = Object.create (null), n; if (Array.isArray (e)) {for (var r = 0, i = e.length; r <i; r ++) n. $ off (e [r], t); retornar n} var o = n._eventos [e]; if (! o) retornar n; se (! t) retornar n._eventos [e] = nulo, n; if (t) for (var a, s = o.length; s -;) if ((a = o [s]) === t || a.fn === t) {o.splice (s, 1); break} return n} , e.prototype. $ emit = function (e) {var t = this._events [e]; if (t) {t = t.length> 1? O (t): t; for (var n = O ( argumentos, 1), r = 0, i = t.length; r <i; r ++) try {t [r] .apply (this, n)} catch (t) {Fe (t, this, 'manipulador de eventos para "'+ e +'" ')}} retornar isso}} (hn), função (e) {e.prototype._update = função (e, t) {var n = this, r = n. $ el, i = n._vnode, o = bt (n); n._vnode = e, n. $ el = i? n .__ patch __ (i, e): n .__ patch __ (n. $ el, e, t,! 1), o (), r && (r .__ vue __ = null), n. $ el && (n. $ el .__ vue __ = n), n. $ vnode && n. $ parent && n. $ vnode === n. $ parent._vnode && (n. $ parent. $ el = n. $ el)}, e.prototype.$ forceUpdate = function () {this._watcher && this._watcher.update ()}, e.prototype. $ destroy = function () {var e = this; if (! e._isBeingDestroyed) {Et (e, "beforeDestroy") , e._isBeingDestroyed =! 0; var t = e. $ parent;! t || t._isBeingDestroyed || e. $ options.abstract || y (t. $ children, e), e._watcher && e._watcher.teardown (); for (var n = e._watchers.length; n -;) e._watchers [n] .teardown (); e._data .__ ob __ && e._data .__ ob __. vmCount -, e._isDestroyed =! 0 , e .__ patch __ (e._vnode, nulo), Et (e, "destruído"), e. $ off (), e. $ el && (e. $ el .__ vue __ = null), e. $ vnode && (e. $ vnode.parent = null)}}} (hn), function (e) {Zt (e.prototype), e.prototype. $ nextTick = function (e) {return Je (e, this)}, e.prototype ._render = function () {var e, t = this, n = t. $ options, i = n.render, o = n._parentVnode; o && (t. $ scopedSlots = o.data.scopedSlots || r), t. $ vnode = o; tente {e = i.call (t._renderProxy, t.$ createElement)} catch (n) {Fe (n, t, "render"), e = t._vnode} return e instanceof de || (e = ve ()), e.parent = o, e}} ( hn); var bn = [String, RegExp, Array], wn = {KeepAlive: {name: "keep-alive", abstract:! 0, props: {include: bn, exclude: bn, max: [String, Number ]}, criado: function () {this.cache = Object.create (null), this.keys = []}, destruído: function () {for (var e in this.cache) _n (this.cache, e , this.keys)}, montado: function () {var e = this; this. $ watch ("include", function (t) {yn (e, function (e) {return mn (t, e)}) }), isso. $ watch ("excluir", function (t) {yn (e, function (e) {return! mn (t, e)})})}, render: function () {var e = this . $ slots.default, t = ft (e), n = t && t.componentOptions; if (n) {var r = gn (n), i = this.include, o = this.exclude; if (i && (! r ||! mn (i, r)) || o && r && mn (o, r)) return t; var a = this.cache, s = this.keys, u = null == t.key? n.Ctor.cid + ( n.tag? "::" + n.tag:""): t.key; a [u]? (t.componentInstance = a [u] .componentInstance, y (s, u), s.push (u)) :( a [u] = t, s. push (u), this.max && s.length> parseInt (this.max) && _ n (a, s [0], s, this._vnode)), t.data.keepAlive =! 0} return t || e && e [0 ]}}} ;! function (e) {var t = {get: function () {return F}}; Object.defineProperty (e, "config", t), e.util = {warn: se, extend: D, mergeOptions: je, defineReactive: Ce}, e.set = Ae, e.delete = Se, e.nextTick = Je, e.options = Object.create (null), H.forEach (function (t) {e .options [t + "s"] = Object.create (null)}), e.options._base = e, D (e.options.components, wn), function (e) {e.use = function (e) {var t = this._installedPlugins || (this._installedPlugins = []); if (t.indexOf (e)> - 1) retorna isso; var n = O (argumentos, 1); retorna n.unshift (this) , "função" == typeof e.install? e.install.apply (e, n): "function" == typeof e && e.apply (null, n), t.push (e), this}} (e), function (e) {e.mixin = function (e) {return this.options = je (this.options, e), this}} (e), vn (e ), função (e) {H.paraCada (função (t) {e [t] = função (e, n) {retornar n? ("componente" === t && l (n) && (n.nome = n. nome || e, n = this.options._base.extend (n)), "diretiva" === t && "função" == typeof n && (n = {bind: n, update: n}), this.options [t + "s"] [e] = n, n): this.options [t + "s"] [e]}})} (e)} (hn), Object.defineProperty (hn.prototype, "$ isServer ", {get: ne}), Object.defineProperty (hn.prototype," $ ssrContext ", {get: function () {return this. $ vnode && this. $ vnode.ssrContext}}), Object.defineProperty (hn," FunctionalRenderContext ", {value: en}), hn.version =" 2.5.21 "; var Tn = v (" style, class "), En = v (" input, textarea, option, select, progress "), xn = função (e, t,n) {return "value" === n && En (e) && "button"! == t || "selecionado" === n && "option" === e || "verificado" === n && "input" === e || "mudo" === n && "vídeo" === e}, Cn = v ("contenteditable, draggable, spellcheck"), An = v ("allowfullscreen, async, autofocus, autoplay, verificado, compact, controls, declare, default, defaultchecked, defaultmuted, defaultselected, adiar, disabled, enabled, formnovalidate, hidden, indeterminate, inerte, ismap, itemscope, loop, multiple, mute, nohref, noresize, noshade, novalidate, nowrap, open pauseonexit, readonly, required, reversed, scoped, seamless, selected, sortable, translate, truespeed, typemustmatch, visible "), Sn =" http://www.w3.org/1999/xlink ", On = função (e) {return ":" === e.charAt (5) && "xlink" === e.slice (0,5)},Dn = function (e) {return On (e)? E.slice (6, e.length): ""}, In = function (e) {return null == e ||! 1 === e}; function kn (e) {for (var t = e.data, n = e, r = e; o (r.componentInstance);) (r = r.componentInstance._vnode) && r.data && (t = Nn (r. dados, t)); para (; o (n = n.parent);) n && n.data && (t = Nn (t, n.data)); função de retorno (e, t) {if (o (e) | | o (t)) return Ln (e, jn (t)); return ""} (t.staticClass, t.class)} função Nn (e, t) {return {staticClass: Ln (e.staticClass, t .staticClass), class: o (e.class)? [e.class, t.class]: t.class}} function Ln (e, t) {return e? t? e + "" + t: e: t || ""} função jn (e) {return Array.isArray (e)? function (e) {for (var t, n = "", r = 0, i = e.length; r <i; r ++) o (t = jn (e [r])) && ""! == t && (n && (n + = ""), n + = t); return n} (e): u (e)? função (e) { var t = ""; para (var n em e) e [n] && (t &&(t + = ""), t + = n); retornar t} (e): "string" == typeof e? e: ""} var Pn = {svg: "http://www.w3.org/2000 /svg",math:"http://www.w3.org/1998/Math/MathML"},Rn=v("html,body,base,head,link,meta,style,title,address,article, à parte, rodapé, cabeçalho, h1, h2, h3, h4, h5, h6, hgroup, nav, seção, div, dd, dl, dt, figcaption, figura, imagem, hr, img, li, main, ol, p, pre, ul, a, b, abbr, bdi, bdo, br, cite, code, data, dfn, em, i, kbd, mark, q, rp, rt, rtc, ruby, s, samp, small, span, strong, sub, sup, time, u, var, wbr, area, audio, map, track, video, embed, object, param, source, canvas, script, noscript, del, ins, caption, col, colgroup, table, thead, tbody, td, th, tr, botão, datalist, fieldset, form, input, label, legend, meter, optgroup, option, output, progress, select, textarea, details, dialog, menu, menuitem, summary, content, elemento, sombra, modelo, blockquote, iframe, tfoot "), $ n = v (" svg, animate,círculo, caminho de recorte, cursor, defs, desc, elipse, filtro, fonte, objeto estrangeiro, g, glifo, imagem, linha, marcador, máscara, glifo ausente, caminho, padrão, polígono, polilinha, ret, switch, símbolo, text, textpath, tspan, use, view ",! 0), Hn = function (e) {return Rn (e) || $ n (e)}; function Mn (e) {return $ n (e)?" svg ":" math "=== e?" math ": void 0} var Fn = Object.create (null); var Wn = v (" texto, número, senha, pesquisa, e-mail, tel, url "); função qn (e) {if ("string" == typeof e) {var t = document.querySelector (e); return t || document.createElement ("div")} return e} var Bn = Object.freeze ( {createElement: function (e, t) {var n = document.createElement (e); return "select"! == e? n: (t.data && t.data.attrs && void 0! == t.data.attrs.multiple && n .setAttribute ("multiple", "multiple"), n)}, createElementNS: function (e, t) {return document.createElementNS (Pn [e], t)}, createTextNode: function (e) {return document.createTextNode (e)}, createComment: function (e) {return document.createComment (e)}, insertBefore: function (e, t , n) {e.insertBefore (t, n)}, removeChild: function (e, t) {e.removeChild (t)}, appendChild: function (e, t) {e.appendChild (t)}, parentNode: function (e) {return e.parentNode}, nextSibling: function (e) {return e.nextSibling}, tagName: function (e) {return e.tagName}, setTextContent: function (e, t) {e.textContent = t}, setStyleScope: function (e, t) {e.setAttribute (t, "")}}), Un = {criar: função (e, t) {Vn (t)}, atualizar: função (e, t ) {e.data.ref! == t.data.ref && (Vn (e,! 0), Vn (t))}, destruir: função (e) {Vn (e,! 0)}}; função Vn (e, t) {var n = e.data.ref; if (o (n)) {var r = e.context, i = e.componentInstance || e.elm, a = r. $ refs; t? Array.isArray (a [n])? Y (a [n], i): a [n] === i && (a [n] = void 0): e.data.refInFor? Array.isArray (a [ n])? a [n].indexOf (i) <0 && a [n] .push (i): a [n] = [i]: a [n] = i}} var zn = new de ("", {}, []), Kn = ["criar", "ativar", "atualizar", "remover", "destruir"]; função Gn (e, t) {return e.key === t.key && (e.tag === t.tag && e .isComment === t.isComment && o (e.data) === o (t.data) && function (e, t) {if ("input"! == e.tag) return! 0; var n, r = o (n = e.data) && o (n = n.attrs) && n.tipo, i = o (n = t.data) && o (n = n.attrs) && n.tipo; return r === i || Wn (r) && Wn (i)} (e, t) || a (e.isAsyncPlaceholder) && e.asyncFactory === t.asyncFactory && i (t.asyncFactory.error))} função Xn (e, t, n) { var r, i, a = {}; para (r = t; r <= n; ++ r) o (i = e [r] .key) && (a [i] = r); retornar a} var Qn = {criar: Yn, atualizar: Yn, destruir: função (e) {Yn (e, zn)}}; função Yn (e, t) {(e.data.directives || t.data.directives) && função (e,t) {var n, r, i, o = e === zn, a = t === zn, s = Zn (e.data.directives, e.context), u = Zn (t.data.directives , t.contexto), c = [], l = []; para (n em u) r = s [n], i = u [n], r? (i.Valor antigo = r.valor, tr (i , "update", t, e), i.def && i.def.componentUpdated && l.push (i)) :( tr (i, "bind", t, e), i.def && i.def.inserted && c.push (i) ); if (c.length) {var f = function () {for (var n = 0; n <c.length; n ++) tr (c [n], "inserido", t, e)}; o? ot (t, "inserir", f): f ()} l.length && ot (t, "postpatch", function () {for (var n = 0; n <l.length; n ++) tr (l [n] , "componentUpdated", t, e)}); if (! o) para (n em s) u [n] || tr (s [n], "desvincular", e, e, a)} (e, t)} var Jn = Object.create (null); função Zn (e, t) {var n, r, i = Object.create (null); if (! e) return i; for (n = 0; n <e.length; n ++) (r = e [n]). modificadores || (r.modifiers = Jn), i [er (r)] = r, r.def = Pe (t. $ options, "diretivas ", r.name);return i} função er (e) {return e.rawName || e.name + "." + Object.keys (e.modifiers || {}). join (".")} função tr (e, t, n , r, i) {var o = e.def && e.def [t]; se (o) tente {o (n.elm, e, n, r, i)} catch (r) {Fe (r, n. contexto, "diretiva" + e.name + "" + t + "gancho")}} var nr = [Un, Qn]; função rr (e, t) {var n = t.componentOptions; if (! (o (n ) &&! 1 === n.Ctor.options.inheritAttrs || i (e.data.attrs) && i (t.data.attrs))) {var r, a, s = t.elm, u = e. data.attrs || {}, c = t.data.attrs || {}; para (r in o (c .__ ob __) && (c = t.data.attrs = D ({}, c)), c ) a = c [r], u [r]! == a && ir (s, r, a); para (r in (X || Y) && c.value! == u.value && ir (s, "valor", c.value), u) i (c [r]) && (On (r)? s.removeAttributeNS (Sn, Dn (r)): Cn (r) || s.removeAttribute (r))}} função ir (e, t, n) {e.tagName.indexOf ("-")> - 1? ou (e, t, n): An (t)? In (n)? e.removeAttribute (t) :( n = "allowfullscreen "=== t &&" EMBED "=== e.tagName?" true ": t, e.setAttribute (t, n)): Cn (t)? e.setAttribute (t, In (n) ||" false "=== n?" false ":" true "): On (t)? In (n)? e.removeAttributeNS (Sn, Dn (t)): e.setAttributeNS (Sn, t, n): ou (e, t, n)} função ou (e, t, n) {if (In (n)) e.removeAttribute (t); else {if (X &&! Q && ("TEXTAREA" === e.tagName | | "INPUT" === e.tagName) && "placeholder" === t &&! E .__ ieph) {var r = function (t) {t.stopImmediatePropagation (), e.removeEventListener ("input", r)} ; e.addEventListener ("input", r), e .__ ieph =! 0} e.setAttribute (t, n)}} var ar = {criar: rr, atualizar: rr}; função sr (e, t) { var n = t.elm, r = t.data, a = e.data; if (! (i (r.staticClass) && i (r.class) && (i (a) || i (a.staticClass) && i (a.class)))) {var s = kn (t), u = n._transitionClasses; o (u) &&(s = Ln (s, jn (u))), s! == n._prevClass && (n.setAttribute ("classe", s), n._prevClass = s)}} var ur, cr, lr, fr, pr, dr, hr = {criar: sr, atualizar: sr}, vr = / [\ w). + \ -_ $ \]] /; função gr (e) {var t, n, r, i, o , a =! 1, s =! 1, u =! 1, c =! 1, l = 0, f = 0, p = 0, d = 0; para (r = 0; r <e.length; r ++ ) if (n = t, t = e.charCodeAt (r), a) 39 === t && 92! == n && (a =! 1); else if (s) 34 === t && 92! == n && (s =! 1); else if (u) 96 === t && 92! == n && (u =! 1); else if (c) 47 === t && 92! == n && (c =! 1); else if ( 124! == t || 124 === e.charCodeAt (r + 1) || 124 === e.charCodeAt (r-1) || l || f || p) {switch (t) {case 34: s =! 0; quebra; caso 39: a =! 0; quebra; caso 96: u =! 0; quebra; caso 40: p ++; quebra; caso 41: p -; quebra; caso 91: f ++; break; case 93: f -; break; case 123: l ++; break; case 125: l -} if (47 === t) {for (var h = r-1, v = void 0; h> = 0 && "" === (v = e.charAt (h)); h -); v && vr.test (v) || (c =! 0)}} else vazio 0 === i? (D = r + 1, i = e.fatia (0, r) .trim ()): g (); função g () {(o || (o = [])). push (e.slice (d, r) .trim ()), d = r + 1} if (void 0 === i? i = e.slice (0, r) .trim (): 0! == d && g (), o) for (r = 0; r <o.length ; r ++) i = mr (i, o [r]); retornar i} função mr (e, t) {var n = t.indexOf ("("); if (n <0) return'_f ("' + t + '") (' + e +") "; var r = t.slice (0, n), i = t.slice (n + 1); return'_f (" '+ r +' ") ('+ e + (")"! == i? "," + i: i)} função yr (e) {console.error ("[compilador Vue]:" + e)} função _r (e, t) {retornar e ? e.map (function (e) {return e [t]}). filter (function (e) {return e}): []} function br (e, t, n) {(e.props || ( e.props = [])). push ({nome: t, valor: n}), e.plain =! 1} função wr (e, t, n) {(e.attrs || (e.attrs = [])). push ({nome: t, valor: n}), e.plain =! 1} função Tr (e, t, n) {e.attrsMap [t] = n, e.attrsList.push ( {nome: t, valor: n})} função Er (e, t, n, r, i, o) {(e.diretivos || (e.directives = [])). push ({name: t, rawName: n, value: r, arg: i, modifiers: o}), e.plain =! 1} função xr (e, t, n, i, o, a) {var s; i = i || r, "click" === t && (i.right? (t = "contextmenu", deletar i.right): i.middle && (t = "mouseup") ), i.capture && (delete i.capture, t = "!" + t), i.once && (delete i.once, t = "~" + t), i.passive && (delete i.passive, t = " & "+ t), i.native? (excluir i.native, s = e.nativeEvents || (e.nativeEvents = {})): s = e.events || (e.events = {}); var u = {valor: n.trim ()}; i! == r && (u.modificadores = i); var c = s [t]; Array.isArray (c)? o? c.unshift (u): c .push (u): s [t] = c? o? [u, c]: [c, u]: u, e.plain =! 1} função Cr (e, t, n) {var r = Ar (e, ":" + t) || Ar (e, "v-bind:" + t); if (null! = r) return gr (r); if (! 1! == n) {var i = Ar (e, t); if (null! = I) return JSON.stringify (i)}} função Ar (e, t, n) {var r; if (null! = (R = e.AttrsMap [t])) para (var i = e.attrsList, o = 0, a = i.length; o <a; o ++) if (i [o] .name === t) {i.splice (o , 1); quebrar} retornar n && excluir e.attrsMap [t], r} função Sr (e, t, n) {var r = n || {}, i = r.number, o = "$$ v"; r.trim && (o = "(typeof $$ v === 'string'? $$ v.trim (): $$ v)"), i && (o = "_ n (" + o + ")"); var a = Or (t, o); e.model = {value: "(" + t + ")", expressão: JSON.stringify (t), callback: "function ($$ v) {" + a + "}" }} função Ou (e, t) {var n = função (e) {if (e = e.trim (), ur = e.length, e.indexOf ("[") <0 || e.lastIndexOf ( "]") <ur-1) return (fr = e.lastIndexOf ("."))> - 1? {exp: e.slice (0, fr), chave: '"' + e.slice (fr + 1) + '"'}: {exp: e, chave: nulo}; cr = e, fr = pr = dr = 0; para (;! Ir ();) kr (lr = Dr ())? Lr ( lr): 91 === lr && Nr (lr); return {exp: e.slice (0, pr), tecla: e.slice (pr + 1, dr)}} (e);return null === n.key? e + "=" + t: "$ set (" + n.exp + "," + n.key + "," + t + ")"} função Dr () {return cr.charCodeAt (++ fr)} função Ir () {return fr> = ur} função kr (e) {return 34 === e || 39 === e} função Nr (e) {var t = 1; for ( pr = fr;! Ir ();) if (kr (e = Dr ())) Lr (e); else if (91 === e && t ++, 93 === e && t -, 0 === t) { dr = fr; quebrar}} função Lr (e) {for (var t = e;! Ir () && (e = Dr ())! == t;);} var jr, Pr = "__ r", Rr = "__ c"; função $ r (e, t, n) {var r = jr; função de retorno i () {null! == t.apply (null, argumentos) && Mr (e, i, n, r)} } function Hr (e, t, n, r) {var i; t = (i = t) ._ withTask || (i._withTask = function () {Ge =! 0; try {return i.apply (null, argumentos)} finalmente {Ge =! 1}}), jr.addEventListener (e, t, ee? {captura: n, passivo: r}: n)} função Mr (e, t, n, r) {(r || jr) .removeEventListener (e, t._withTask || t, n)} função Fr (e, t) {if (! i (e.data.on) ||! i (t.data.on)) {var n = t.data.on || {}, r = e.data.on || {}; jr = t.elm, função (e) {if (o (e [Pr])) {var t = X? "alterar": "entrada"; e [t] = []. concat (e [Pr], e [t] || []), exclua e [Pr]} o (e [Rr ]) && (e.change = []. concat (e [Rr], e.change || []), excluir e [Rr])} (n), it (n, r, Hr, Mr, $ r , t.context), jr = void 0}} var Wr = {criar: Fr, atualizar: Fr}; função qr (e, t) {if (! i (e.data.domProps) ||! i (t .data.domProps)) {var n, r, a = t.elm, s = e.data.domProps || {}, u = t.data.domProps || {}; para (n em o (u. __ob __) && (u = t.data.domProps = D ({}, u)), s) i (u [n]) && (a [n] = ""); para (n em u) {if ( r = u [n], "textContent" === n || "innerHTML" === n) {if (t.children && (t.children.length = 0), r === s [n]) continuar ; 1 === a.childNodes.length && a.removeChild (a.childNodes [0])} if ("valor" === n) {a._value = r; var c = i (r)? "": String (r); Br (a, c) && (a.valor = c)} else a [n] = r}}} função Br (e,t) {return! e.composing && ("OPTION" === e.tagName || function (e, t) {var n =! 0; try {n = document.activeElement! == e} catch (e) { } return n && e.value! == t} (e, t) || função (e, t) {var n = e.value, r = e._vModifiers; if (o (r)) {if (r.lazy ) return! 1; if (r.number) return h (n)! == h (t); if (r.trim) return n.trim ()! == t.trim ()} return n! == t} (e, t))} var Ur = {criar: qr, atualizar: qr}, Vr = w (função (e) {var t = {}, n = /: (. +) /; retornar e. split (/; (?! [^ (] * \)) / g) .forEach (function (e) {if (e) {var r = e.split (n); r.length> 1 && (t [r [0] .trim ()] = r [1] .trim ())}}), t}); função zr (e) {var t = Kr (e.style); retornar e.staticStyle? D (e .staticStyle, t): t} função Kr (e) {return Array.isArray (e)? I (e): "string" == typeof e? Vr (e): e} var Gr, Xr = / ^ - - /, Qr = / \ s *! Important $ /, Yr = função (e, t, n) {if (Xr.test (t)) e.style.setProperty (t, n); else if (Qr. test (n)) e.style.setProperty (t, n.replace (Qr, ""), "importante "); senão {var r = Zr (t); if (Array.isArray (n)) para (var i = 0, o = n.length; i <o; i ++) e.style [r] = n [i]; else e.style [r] = n}}, Jr = ["Webkit", "Moz", "ms"], Zr = w (função (e) {if (Gr = Gr || documento. createElement ("div"). style, "filter"! == (e = E (e)) && e em Gr) return e; for (var t = e.charAt (0) .toUpperCase () + e.slice ( 1), n ​​= 0; n <Jr.length; n ++) {var r = Jr [n] + t; se (r em Gr) retornar r}}); função ei (e, t) {var n = t .data, r = e.data; if (! (i (n.staticStyle) && i (n.style) && i (r.staticStyle) && i (r.style))) {var a, s, u = t.elm , c = r.staticStyle, l = r.normalizedStyle || r.style || {}, f = c || l, p = Kr (t.data.style) || {}; t.data.normalizedStyle = o (p .__ ob __)? D ({}, p): p; var d = função (e, t) {var n, r = {}; se (t) para (var i = e; i.comInstância do componente; ) (i = i.componentInstance._vnode) && i.data && (n = zr (i.data)) && D (r, n); (n = zr (e.data)) && D (r, n); para (var o = e; o = o.parent;) o.data && (n = zr (o.data)) && D (r, n); retornar r} (t,! 0) ; para (s em f) i (d [s]) && Yr (u, s, ""); para (s em d) (a = d [s])! == f [s] && Yr (u, s , null == a? "": a)}} var ti = {criar: ei, atualizar: ei}, ni = / \ s + /; função ri (e, t) {if (t && (t = t.trim ())) if (e.classList) t.indexOf ("")> - 1? t.split (ni) .forEach (function (t) {return e.classList.add (t)}): e.classList .add (t); else {var n = "" + (e.getAttribute ("class") || "") + ""; n.indexOf ("" + t + "") <0 && e.setAttribute ("class ", (n + t) .trim ())}} função ii (e, t) {if (t && (t = t.trim ())) if (e.classList) t.indexOf (" ")> - 1? T.split (ni) .forEach (function (t) {return e.classList.remove (t)}): e.classList.remove (t), e.classList.length || e.removeAttribute ("classe ");else {for (var n = "" + (e.getAttribute ("class") || "") + "", r = "" + t + ""; n.indexOf (r)> = 0;) n = n.replace (r, ""); (n = n.trim ())? e.setAttribute ("classe", n): e.removeAttribute ("classe")}} função oi (e) {if (e ) {if ("object" == typeof e) {var t = {}; return! 1! == e.css && D (t, ai (e.name || "v")), D (t, e) , t} return "string" == typeof e? ai (e): void 0}} var ai = w (function (e) {return {enterClass: e + "- enter", enterToClass: e + "- enter-to" , enterActiveClass: e + "- enter-active", leaveClass: e + "- leave", leaveToClass: e + "- leave-to", leaveActiveClass: e + "- leave-active"}}), si = V &&! Q, ui = "transição", ci = "animação", li = "transição", fi = "transição final", pi = "animação", di = "animationend "; si && (void 0 === window.ontransitionend && void 0! == window.onwebkittransitionend && (li =" WebkitTransition ", fi =" webkitTransitionEnd "), void 0 === window.onanimationend && void 0! == window.onwebkitanimationend && ( pi = "WebkitAnimation", di = "webkitAnimationEnd")); var hi = V? window.requestAnimationFrame? window.requestAnimationFrame.bind (window): setTimeout: function (e) {return e ()}; função vi (e) {hi (function () {hi (e)})} função gi (e, t) {var n = e._transitionClasses || (e._transitionClasses = []); n.indexOf (t) <0 && (n. push (t), ri (e, t))} função mi (e, t) {e._transitionClasses && y (e._transitionClasses, t), ii (e, t)} função yi (e, t, n) {var r = bi (e, t), i = r.type, o = r.timeout, a = r.propCount; if (! i) return n (); var s = i === ui? fi: di, u = 0, c = function () {e.removeEventListener (s, l), n ()},l = function (t) {t.target === e && ++ u> = a && c ()}; setTimeout (function () {u <a && c ()}, o + 1), e.addEventListener (s, l) } var _i = / \ b (transformar | todos) (, | $) /; função bi (e, t) {var n, r = window.getComputedStyle (e), i = (r [li + "Atraso"] | | ""). split (","), o = (r [li + "Duração"] || ""). split (","), a = wi (i, o), s = (r [pi + "Atraso"] || ""). Divisão (","), u = (r [pi + "Duração"] || ""). Divisão (","), c = wi (s, u), l = 0, f = 0; return t === ui? A> 0 && (n = ui, l = a, f = o.length): t === ci? C> 0 && (n = ci, l = c , f = u.length): f = (n = (l = Math.max (a, c))> 0? a> c? ui: ci: null)? n === ui? o.length: u .length: 0, {type: n, timeout: l, propCount: f, hasTransform: n === ui && _ i.test (r [li + "Property"])}} function wi (e, t) {for (; e .length <t.length;) e = e.concat (e); retornar Math.max.apply (null, t.map (function (t, n) {return Ti (t) + Ti (e [n])}))} função Ti (e) {return 1e3 * Number (e.slice (0, -1) .replace (" , ",". "))} função Ei (e, t) {var n = e.elm; o (n._leaveCb) && (n._leaveCb.cancelled =! 0, n._leaveCb ()); var r = oi (e.data.transition); if (! i (r) &&! o (n._enterCb) && 1 === n.nodeType) {for (var a = r.css, s = r.type, c = r.enterClass, l = r.enterToClass, f = r.enterActiveClass, p = r.appearClass, d = r.appearToClass, v = r.appearActiveClass, g = r.beforeEnter, m = r.enter, y = r .afterEnter, _ = r.enterCancelled, b = r.beforeAppear, w = r.appear, T = r.afterAppear, E = r.appearCancelled, x = r.duration, C = _t, A = _t. $ vnode; A && A.parent;) C = (A = A.parent) .context; var S =! C._isMounted ||! E.isRootInsert; if (! S || w || "" === w) {var O = S && p? P: c, D = S && v? V: f, I = S && d? D: l, k = S && b || g, N = S && "função" == tipo de w? W: m, L = S && T || y, j = S &&E || _, P = h (u (x)? X.enter: x); 0; var $ =! 1! == a &&! Q, H = Ai (N), M = n._enterCb = R ( function () {$ && (mi (n, I), mi (n, D)), M.cancelado? ($ && mi (n, O), j && j (n)): L && L (n), n._enterCb = null}); e.data.show || ot (e, "inserir", função () {var t = n.parentNode, r = t && t._pending && t._pending [e.key]; r && r.tag === e .tag && r.elm._leaveCb && r.elm._leaveCb (), N && N (n, M)}), k && k (n), $ && (gi (n, O), gi (n, D), vi (função () { mi (n, O), M. cancelado || (gi (n, I), H || (Ci (P)? setTimeout (M, P): yi (n, s, M)))})), e.data.show && (t && t (), N && N (n, M)), $ || H || M ()}}} função xi (e, t) {var n = e.elm; o (n._enterCb ) && (n._enterCb.cancelled =! 0, n._enterCb ()); var r = oi (e.data.transition); if (i (r) || 1! == n.nodeType) return t ( ); if (! o (n._leaveCb)) {var a = r.css, s = r.type, c = r.leaveClass, l = r.leaveToClass, f = r.leaveActiveClass, p = r.beforeLeave, d = r.leave, v = r.afterLeave, g = r.leaveCancelled, m = r.delayLeave, y = r.duration, _ =! 1! == a &&! Q, b = Ai (d), w = h (u (y)? y.leave: y); 0; var T = n._leaveCb = R (function () {n.parentNode && n.parentNode._pending && (n.parentNode._pending [e.key] = nulo), _ && (mi (n, l), mi (n, f)), T.cancelado? (_ && mi (n, c), g && g (n)) :( t (), v && v (n)), n ._leaveCb = null}); m? m (E): E ()} função E () {T.cancelled || (! e.data.show && n.parentNode && ((n.parentNode._pending || (n.parentNode ._pending = {})) [e.key] = e), p && p (n), _ && (gi (n, c), gi (n, f), vi (função () {mi (n, c), T.cancelado || (gi (n, l), b || (Ci (w)? SetTimeout (T, w): yi (n, s, T)))})), d && d (n, T), _ || b || T ())}} função Ci (e) {return "number" == typeof e &&! isNaN (e)} função Ai (e) {if (i (e)) return! 1; var t = e.fns; retornar o (t)? Ai (Array.isArray (t)? t [0]: t) :( e._length || e.length)>1} função Si (e, t) {! 0! == t.data.show && Ei (t)} var Oi = função (e) {var t, n, r = {}, u = e.módulos, c = e.nodeOps; para (t = 0; t <Kn.length; ++ t) para (r [Kn [t]] = [], n = 0; n <u.length; ++ n) o (u [n] [Kn [t]]) && r [Kn [t]]. push (u [n] [Kn [t]]); função l (e) {var t = c.parentNode (e); o ( t) && c.removeChild (t, e)} função f (e, t, n, i, s, u, l) {if (o (e.elm) && o (u) && (e = u [l] = me (e)), e.isRootInsert =! s,! function (e, t, n, i) {var s = e.data; if (o (s)) {var u = o (e.componentInstance) && s .keepAlive; if (o (s = s.hook) && o (s = s.init) && s (e,! 1), o (e.componentInstance)) return p (e, t), d (n, e. elm, i), a (u) && função (e, t, n, i) {para (var a, s = e; s.componentInstance;) if (s = s.componentInstance._vnode, o (a = s. data) && o (a = a.transition)) {for (a = 0; a <r.activate.length; ++ a) r.activate [a] (zn, s); t.push (s); break } d (n, e.elm, i)} (e, t, n, i) ,! 0}} (e, t, n, i)) {var f = e.data, v = e.children, g = e.tag; o (g)? (e.elm = e.ns? c.createElementNS (e.ns, g): c.createElement (g, e), y (e), h (e, v, t), o (f) && m (e, t), d (n, e.elm, i)): a (e.isComment)? (e.elm = c.createComment (e.text), d (n, e. elm, i)) :( e.elm = c.createTextNode (e.text), d (n, e.elm, i))}} função p (e, t) {o (e.data.pendingInsert) && (t.push.apply (t, e.data.pendingInsert), e.data.pendingInsert = null), e.elm = e.componentInstance. $ el, g (e)? (m (e, t), y (e)) :( Vn (e), t.push (e))} função d (e, t, n) {o (e) && (o (n)? c.parentNode (n) === e && c .insertBefore (e, t, n): c.appendChild (e, t))} função h (e, t, n) {if (Array.isArray (t)) for (var r = 0; r <t. comprimento; ++ r) f (t [r], n, e.elm, nulo,! 0, t, r); else s (e.text) && c.appendChild (e.elm, c.createTextNode (String ( e.text)))} função g (e) {for (; e.componentInstance;) e = e.componentInstance._vnode; return o (e.tag)} função m (e, n) {for (var i = 0; i <r.create.length; ++ i) r.create [i] (zn, e); o (t = e.data.gancho) && (o (t.create) && t.create (zn, e), o (t.insert) && n.push (e))} função y (e) {var t; if (o (t = e. fnScopeId)) c.setStyleScope (e.elm, t); else for (var n = e; n;) o (t = n.context) && o (t = t. $ options._scopeId) && c.setStyleScope (e. elm, t), n = n.parent; o (t = _t) && t! == e.context && t! == e.fnContext && o (t = t. $ options._scopeId) && c.setStyleScope (e.elm, t) } função _ (e, t, n, r, i, o) {para (; r <= i; ++ r) f (n [r], o, e, t,! 1, n, r)} função b (e) {var t, n, i = e.data; if (o (i)) para (o (t = i.hook) && o (t = t.destroy) && t (e), t = 0 ; t <r.destroy.length; ++ t) r.destroy [t] (e); if (o (t = e.children)) para (n = 0; n <e.children.length; ++ n) função b (e.children [n])} w (e, t, n, r) {para (; n <= r; ++ n) {var i = t [n]; o (i) && (o (i.tag)? (T (i), b (i)): l (i.elm))}} função T (e, t) {if (o (t) || o (e.data )) {var n, i = r.remove.length + 1; para (o (t)? t.listeners + = i: t = função (e,t) {function n () {0 == - n.listeners && l (e)} return n.listeners = t, n} (e.elm, i), o (n = e.componentInstance) && o (n = n ._vnode) && o (n.data) && T (n, t), n = 0; n <r.remove.length; ++ n) r.remove [n] (e, t); o (n = e. data.hook) && o (n = n.remove)? n (e, t): t ()} else l (e.elm)} função E (e, t, n, r) {for (var i = n ; i <r; i ++) {var a = t [i]; if (o (a) && Gn (e, a)) return i}} função x (e, t, n, s, u, l) {if (e! == t) {o (t.elm) && o (s) && (t = s [u] = me (t)); var p = t.elm = e.elm; if (a (e. isAsyncPlaceholder)) o (t.asyncFactory.resolved)? S (e.elm, t, n): t.isAsyncPlaceholder =! 0; else if (a (t.isStatic) && a (e.isStatic) && t.key == = e.key && (a (t.isCloned) || a (t.isOnce))) t.componentInstance = e.componentInstance; else {var d, h = t.data; o (h) && o (d = h. gancho) && o (d = d.prepatch) && d (e, t); var v = e.children, m = t.children; if (o (h) && g (t)) {for (d = 0; d < r.update.length; ++ d) r.update [d] (e, t); o (d = h.hook) && o (d = d.update) && d (e, t)} i (t.text)? o (v) && o (m)? v! == m && function (e, t, n, r, a) {for (var s, u, l, p = 0, d = 0, h = t.length-1 , v = t [0], g = t [h], m = n.length-1, y = n [0], b = n [m], T =! a; p <= h && d <= m; ) i (v)? v = t [++ p]: i (g)? g = t [- h]: Gn (v, y)? (x (v, y, r, n, d), v = t [++ p], y = n [++ d]): Gn (g, b)? (x (g, b, r, n, m), g = t [- h], b = n [- m]): Gn (v, b)? (x (v, b, r, n, m), T && c.insertBefore (e, v.elm, c.nextSibling (g.elm)), v = t [++ p], b = n [- m]): Gn (g, y)? (x (g, y, r, n, d), T && c.inserirBefore (e, g.elm, v.elm), g = t [- h], y = n [++ d]) :( i (s) && (s = Xn (t, p, h)), i (u = o (y .key)? s [y.key]: E (y, t, p, h))? f (y, r, e, v.elm,! 1, n, d): Gn (l = t [u ], y)? (x (l, y, r, n, d), t [u] = vazio 0, T && c.insertBefore (e, l.elm, v.elm)): f (y, r, e , v.elm,! 1, n, d), y = n [++ d]); p> h? _ (e, i (n [m + 1])? nulo: n [m + 1]. olmo, n, d, m, r): d> m && w (0, t, p, h)} (p, v, m, n, l): o (m)? (o (e.text) && c.setTextContent (p, ""), _ (p, null, m, 0, m.length-1, n)): o (v)? w (0, v, 0, v.length-1): o ( e.text) && c.setTextContent (p, ""): e.text! == t.text && c.setTextContent (p, t.text), o (h) && o (d = h.hook) && o (d = d .postpatch) && d (e, t)}}} função C (e, t, n) {if (a (n) && o (e.parent)) e.parent.data.pendingInsert = t; else for (var r = 0; r <t.length; ++ r) t [r] .data.hook.insert (t [r])} var A = v ("attrs, class, staticClass, staticStyle, key"); função S (e, t, n, r) {var i, s = t.tag, u = t.data, c = t.children; if (r = r || u && u.pre, t.elm = e, a ( t.isComment) && o (t.asyncFactory)) return t.isAsyncPlaceholder =! 0,! 0; if (o (u) && (o (i = u.hook) && o (i = i.init) && i (t, ! 0), o (i = t.componentInstance))) return p (t, n) ,! 0; if (o (s)) {if (o (c)) if (e.hasChildNodes ()) if ( o (i = u) && o (i = i.domProps) && o (i = i.innerHTML)) {if (i! == e.innerHTML) return! 1} else {for (var l =! 0, f = e.firstChild, d = 0; d <c.length; d ++) {if (! f ||! S (f, c [d] , n, r)) {l =! 1; quebrar} f = f.nextSibling} if (! l || f) return! 1} else h (t, c, n); if (o (u)) { var v =! 1; para (var g em u) if (! A (g)) {v =! 0, m (t, n); quebrar}! v && u.class && et (u.class)}} else e. data! == t.text && (e.data = t.text); return! 0} função de retorno (e, t, n, s) {if (! i (t)) {var u, l =! 1, p = []; if (i (e)) l =! 0, f (t, p); else {var d = o (e.nodeType); if (! d && Gn (e, t)) x (e, t, p, nulo, nulo, s); else {if (d) {if (1 === e.nodeType && e.hasAttribute ($) && (e.removeAttribute ($), n =! 0), a (n ) && S (e, t, p)) return C (t, p,! 0), e; u = e, e = new de (c.tagName (u) .toLowerCase (), {}, [], void 0, u)} var h = e.elm, v = c.parentNode (h); if (f (t, p, h._leaveCb? Null: v, c.nextSibling (h)), o (t.parent )) for (var m = t.parent, y = g (t); m;) {for (var _ = 0; _ <r.destroy.length; ++ _) r.destroy [_] (m) ; if (m.elm = t.elm, y) {para (var T = 0; T <r.comprimento de criação; ++ T) r.create [T] (zn, m); var E = m.data.hook.insert; se (E.merged) para (var A = 1; A <E.fns. comprimento; A ++) E.fns [A] ()} else Vn (m); m = m.parent} o (v)? w (0, [e], 0,0): o (e.tag) && b (e)}} retornar C (t, p, l), t.elm} o (e) && b (e)}} ({nodeOps: Bn, módulos: [ar, hr, Wr, Ur, ti, V? {criar: Si, ativar: Si, remover: função (e, t) {! 0! == e.data.show?xi(e,t):t()}}:{}].concat(nr) }); Q && document.addEventListener ("selectionchange", function () {var e = document.activeElement; e && e.vmodel && Ri (e, "input")}); var Di = {inserido: function (e, t, n, r ) {"select" === n.tag? (r.elm &&! r.elm._vOptions? ot (n, "postpatch", function () {Di.componentUpdated (e, t, n)}): Ii ( e, t, n.context), e._vOptions = []. map.call (e.options, Li)) :( "textarea" === n.tag || Wn (e.type)) && (e ._vModifiers = t.modifiers, t.modifiers.lazy || (e.addEventListener ("compositionstart ", ji), e.addEventListener (" compositionend ", Pi), e.addEventListener (" alterar ", Pi), Q && (e.vmodel =! 0)))}, componentUpdated: function (e, t, n ) {if ("selecionar" === n.tag) {Ii (e, t, n.contexto); var r = e._vOptions, i = e._vOptions = []. map.call (e.options, Li); if (i.some (function (e, t) {return! J (e, r [t])})) (e.multiple? T.value.some (function (e) {return Ni (e , i)}): t.value! == t.oldValue && Ni (t.value, i)) && Ri (e, "alterar")}}}; função Ii (e, t, n) {ki (e, t , n), (X || Y) && setTimeout (função () {ki (e, t, n)}, 0)} função ki (e, t, n) {var r = t.valor, i = e. múltiplo; if (! i || Array.isArray (r)) {for (var o, a, s = 0, u = e.options.length; s <u; s ++) if (a = e.options [s ], i) o = P (r, Li (a))> - 1, a.selecionado! == o && (a.selecionado = o); senão if (j (Li (a), r)) return void ( e.selectedIndex! == s && (e.selectedIndex = s)); i || (e.selectedIndex = -1)}} função Ni (e, t) {return t.every (function (t) {return! j (t, e)})} função Li (e) {return "_value" in e? e ._value: e.value} function ji (e) {e.target.composing =! 0} função Pi (e) {e.target.composing && (e.target.composing =! 1, Ri (e.target, " input "))} função Ri (e, t) {var n = document.createEvent (" HTMLEvents "); n.initEvent (t,! 0,! 0), e.dispatchEvent (n)} função $ i (e ) {return! e.componentInstance || e.data && e.data.transition? e: $ i (e.componentInstance._vnode)} var Hi = {model: Di, show: {bind: function (e, t, n) {var r = t.value, i = (n = $ i (n)). data && n.data.transition, o = e .__ vOriginalDisplay = "none" === e.style.display? "": e.style .display; r && i? (n.data.show =! 0, Ei (n, function () {e.style.display = o})): e.style.display = r? o: "nenhum"}, atualizar : function (e, t, n) {var r = t.value;! r! =! t.oldValue && ((n = $ i (n)).data && n.data.transition? (n.data.show =! 0, r? Ei (n, function () {e.style.display = e .__ vOriginalDisplay}): xi (n, function () {e.style. display = "none"})): e.style.display = r? e .__ vOriginalDisplay: "none")}, desvincular: function (e, t, n, r, i) {i || (e.style. display = e .__ vOriginalDisplay)}}}, Mi = {name: String, apareça: Boolean, css: Boolean, mode: String, type: String, enterClass: String, leaveClass: String, enterToClass: String, leaveToClass: String, enterActiveClass : String, leaveActiveClass: String, appearClass: String, appearActiveClass: String, appearToClass: String, duration: [Number, String, Object]}; function Fi (e) {var t = e && e.componentOptions; return t && t.Ctor.options. resumo? Fi (ft (t.children)): e} função Wi (e) {var t = {}, n = e. $ options; for (var r in n.propsData) t [r] = e [r ]; var i = n._parentListeners; for (var o in i) t [E (o)] = i [o]; retornar t} função qi (e,t) {if (/ \ d-keep-alive $ /. test (t.tag)) return e ("keep-alive", {props: t.componentOptions.propsData})} var Bi = function (e) { return e.tag || lt (e)}, Ui = function (e) {return "show" === e.name}, Vi = {nome: "transição", adereços: Mi, resumo:! 0, render : function (e) {var t = this, n = this. $ slots.default; if (n && (n = n.filter (Bi)). length) {0; var r = this.mode; 0; var i = n [0]; if (function (e) {for (; e = e.parent;) if (e.data.transition) return! 0} (this. $ vnode)) return i; var o = Fi ( i); if (! o) return i; if (this._leaving) return qi (e, i); var a = "__ transição -" + this._uid + "-"; o.key = null == o.key ? o.isComment? a + "comentário": a + o.tag: s (o.key)? 0 === String (o.key) .indexOf (a)? o.key: a + o.key: o .key; var u = (o.data || (o.data = {})). transição = Wi (este), c = este._vnode, l = Fi (c); if (o.data.directives && o. data.directives.some (Ui) && (o.data.show =! 0), l && l.data &&! function (e, t) {return t.key === e.key && t.tag === e.tag} (o, l) &&! lt (l) && (! l.componentInstance ||! l. componentInstance._vnode.isComment)) {var f = l.data.transition = D ({}, u); if ("out-in" === r) return this._leaving =! 0, ot (f, " afterLeave ", function () {t._leaving =! 1, t. $ forceUpdate ()}), qi (e, i); if (" in-out "=== r) {if (lt (o)) return c; var p, d = function () {p ()}; ot (u, "afterEnter", d), ot (u, "enterCancelled", d), ot (f, "delayLeave", function (e ) {p = e})}} return i}}}, zi = D ({tag: String, moveClass: String}, Mi); função Ki (e) {e.elm._moveCb && e.elm._moveCb (), e.elm._enterCb && e.elm._enterCb ()} função Gi (e) {e.data.newPos = e.elm.getBoundingClientRect ()} função Xi (e) {var t = e.data.pos, n = e .data.newPos, r = t.left-n.left, i = t.top-n.top; if (r || i) {e.data.moved =! 0; var o = e.elm.style ; o.transform = o.WebkitTransform = "translate (" + r + "px," + i + "px)", o.transitionDuration = "0s"}} delete zi.mode; var Qi = {Transition: Vi, TransitionGroup: {props: zi, beforeMount: function () {var e = this, t = this._update; this._update = function (n, r) {var i = bt (e); e .__ patch __ (e._vnode, e.kept,! 1 ,! 0), e._vnode = e.kept, i (), t.call (e, n, r)}}, render: function (e) {for (var t = this.tag || this. $ Vnode. data.tag || "span", n = Object.create (null), r = this.prevChildren = this.children, i = this. $ slots.default || [], o = this.children = [], a = Wi (this), s = 0; s <i.length; s ++) {var u = i [s]; if (u.tag) if (null! = u.key && 0! == String (u.key ) .indexOf ("__ vlist")) o.push (u), n [u.key] = u, (u.data || (u.data = {})). transição = a; else;} if ( r) {para (var c = [], l = [], f = 0; f <r.length; f ++) {var p = r [f]; p.data.transition = a, p.data.pos = p.elm.getBoundingClientRect (), n [p.key]? c.push (p): l.push (p)} isso.mantido = e (t, nulo, c), this.removed = l} return e (t, nulo, o)}, atualizado: function () {var e = this.prevChildren, t = this.moveClass || (this .name || "v") + "- move"; e.length && this.hasMove (e [0] .elm, t) && (e.forEach (Ki), e.forEach (Gi), e.forEach (Xi ), this._reflow = document.body.offsetHeight, e.forEach (function (e) {if (e.data.moved) {var n = e.elm, r = n.style; gi (n, t), r.transform = r.WebkitTransform = r.transitionDuration = "", n.addEventListener (fi, n._moveCb = function e (r) {r && r.target! == n || r &&! / transform $ /. test (r .propertyName) || (n.removeEventListener (fi, e), n._moveCb = null, mi (n, t))})}}))}, métodos: {hasMove: function (e, t) {if ( ! si) return! 1; if (this._hasMove) return this._hasMove; var n = e.cloneNode (); e._transitionClasses && e._transitionClasses.forEach (function (e) {ii (n, e)}), ri (n, t), n.style.display = "nenhum", isso. $ el.appendChild (n);var r = bi (n); retornar isto. $ el.removeChild (n), this._hasMove = r.hasTransform}}}}; hn.config.mustUseProp = xn, hn.config.isReservedTag = Hn, hn.config .isReservedAttr = Tn, hn.config.getTagNamespace = Mn, hn.config.isUnknownElement = function (e) {if (! V) return! 0; if (Hn (e)) return! 1; if (e = e. toLowerCase (), null! = Fn [e]) retornar Fn [e]; var t = document.createElement (e); retornar e.indexOf ("-")> - 1? Fn [e] = t.constructor = == window.HTMLUnknownElement || t.constructor === window.HTMLElement: Fn [e] = / HTMLUnknownElement / .test (t.toString ())}, D (hn.options.directives, Hi), D (hn .options.components, Qi), hn.prototype .__ patch __ = V? Oi: k, hn.prototype. $ mount = function (e, t) {return function (e, t, n) {var r; return e. $ el = t, e. $ options.render || (e. $ options.render = ve), Et (e, "beforeMount"), r = function () {e._update (e._render (), n )}, novo Nt (e, r, k, {antes: função () {e._isMounted &&! e._isDestroyed &&Et (e, "beforeUpdate")}} ,! 0), n =! 1, null == e. $ Vnode && (e._isMounted =! 0, Et (e, "montado")), e} (isto, e = e && V? qn (e): void 0, t)}, V && setTimeout (function () {F.devtools && re && re.emit ("init", hn)}, 0); var Yi = / \ {\ {((? :. | \ r? \ n) +?) \} \} / g, Ji = / [-. * +? ^ $ {} () | [\] \ / \\] / g, Zi = w ( function (e) {var t = e [0] .replace (Ji, "\\ $ &"), n = e [1] .replace (Ji, "\\ $ &"); retornar novo RegExp (t + " ((?:. | \\ n) +?) "+ n," g ")}); var e o = {staticKeys: [" staticClass "], transformNode: function (e, t) {t.warn; var n = Ar (e, "classe"); n && (e.staticClass = JSON.stringify (n)); var r = Cr (e, "classe",! 1); r && (e.classBinding = r)}, genData: function (e) {var t = ""; return e.staticClass && (t + = "staticClass:" + e.staticClass + ","), e.classBinding && (t + = "class: "+ e.classBinding +", "), t}}; var to, no = {staticKeys: [" staticStyle "], transformNode: function (e, t) {t.warn; var n = Ar (e, "estilo"); n && (e.staticStyle = JSON.stringify (Vr (n))); var r = Cr (e, "estilo",! 1); r && (e.styleBinding = r)}, genData: função (e) {var t = ""; retornar e.staticStyle && (t + = "staticStyle:" + e.staticStyle + ","), e.styleBinding && (t + = "style :(" + e.styleBinding + "),") , t}}, ro = function (e) {return (to = to || document.createElement ("div")). innerHTML = e, to.textContent}, io = v ("area, base, br, col , embed, frame, hr, img, input, isindex, keygen, link, meta, param, source, track, wbr "), oo = v (" colgroup, dd, dt, li, options, p, td, tfoot, th, thead, tr, source "), ao = v (" endereço, artigo, aparte, base, blockquote, body, caption, col, colgroup, dd, details, dialog, div,dl, dt, fieldset, figcaption, figura, rodapé, formulário, h1, h2, h3, h4, h5, h6, head, header, hgroup, hr, html, legend, li, menuitem, meta, optgroup, option, param, rp, rt, source, style, summary, tbody, td, tfoot, th, thead, title, tr, track "), so = / ^ \ s * ([^ \ s" '<> \ / =] +) (?: \ s * (=) \ s * (?: "([^"] *) "+ | '([^'] *) '+ | ([^ \ s"' = <> `] + )))? /, uo = "[a-zA-Z _] [\\ w \\ - \\.] *", co = "((?:" + uo + "\\ :)?" + uo + " ) ", lo = novo RegExp (" ^ <"+ co), fo = / ^ \ s * (\ /?)> /, po = novo RegExp (" ^ <\\ / "+ co +" [^>] *> "), ho = / ^ <! DOCTYPE [^>] +> / i, vo = / ^ <! \ - /, go = / ^ <! \ [/, mo = v (" script, estilo , textarea ",! 0), yo = {}, _ o = {" & lt; ":" <"," & gt; ":"> "," & quot; ": '"', "& amp;": "& "," & # 10; ":"\ n "," & # 9; ":" \ t "}, bo = / & (?: lt | gt | quot | amp); / g, wo = / & (?: lt | gt | quot | amp | # 10 | # 9); / g, To = v ("pre, textarea",! 0), Eo = função (e, t) {return e && To (e) && "\ n" === t [0 ]}; função xo (e, t) {var n = t? wo: bo; return e.replace (n, função (e) {return _o [e]})} var Co, Ao, So, Oo, Do , Io, ko, Não, Lo = / ^ @ | ^ v-on: /, jo = / ^ v- | ^ @ | ^: /, Po = / ([\ s \ S] *?) \ S + ( ?: em | de) \ s + ([\ s \ S] *) /, Ro = /, ([^, \} \]] *) (?:, ([^, \} \]] *)) ? $ /, $ o = / ^ \ (| \) $ / g, Ho = /: (. *) $ /, Mo = / ^: | ^ v-bind: /, Fo = / \. [^. ] + / g, Wo = w (ro); função qo (e, t, n) {return {type: 1, tag: e, attrsList: t, attrsMap: Go (t), parent: n, children: [ ]}} função Bo (e, t) {Co = t.warn || yr, Io = t.isPreTag || N, ko = t.mustUseProp || N, No = t.getTagNamespace || N, So = _r (t.modules, "transformNode"), Oo = _r (t.modules, "preTransformNode"), Do = _r (t.modules, "postTransformNode"), Ao = t.delimiters; var n, r, i = [ ], o =! 1! == t.preserveWhitespace, a =! 1, s =! 1; função u (e) {e.pre && (a =! 1), Io (e.tag) && (s =! 1); para (var n = 0; n <Do.length; n ++) Do [n] (e, t)} função de retorno (e, t) {para (var n, r, i = [], o = t.expectHTML, a = t.isUnaryTag || N, s = t.canBeLeftOpenTag || N, u = 0; e;) {if (n = e, r && mo (r)) {var c = 0, l = r.toLowerCase (), f = yo [l] || (yo [l] = novo RegExp ("([\\ s \\ S] *?) (</" + l + "[^>] *>)", "i")), p = e. substituir (f, função (e, n, r) {return c = r.length, mo (l) || "noscript" === l || (n = n.replace (/ <! \ - ([ \ s \ S] *?) -> / g, "$ 1"). substituir (/ <! \ [CDATA \ [([\ s \ S] *?)]]> / g, "$ 1")) , Eo (l, n) && (n = n.slice (1)), t.chars && t.chars (n), ""}); u + = e.length-p.length, e = p, A (l , uc, u)} else {var d = e.indexOf ("<"); if (0 === d) {if (vo.test (e)) {var h = e.indexOf ("- \ x3e "); if (h> = 0) {t.shouldKeepComment && t.comment (e.substring (4, h)), E (h + 3); continuar}} if (go.test (e)) {var v = e.indexOf ("]>"); if (v> = 0) {E (v + 2); continuar}} var g = e.match (ho); if (g) {E (g [0] .length); continuar} var m = e.match (po); if (m) {var y = u; E (m [0] .comprimento), A (m [1], y, u); continuar} var _ = x (); se (_) {C (_), Eo (_ .tagName, e) && E (1); continue}} var b = void 0, w = void 0, T = void 0; if (d> = 0) {for (w = e.slice (d);! ( po.test (w) || lo.test (w) || vo.test (w) || go.test (w) || (T = w.indexOf ("<", 1)) <0); ) d + = T, w = e.slice (d); b = e.substring (0, d), E (d)} d <0 && (b = e, e = ""), t.chars && b && t.chars ( b)} if (e === n) {t.chars && t.chars (e); quebrar}} função E (t) {u + = t, e = e.substring (t)} função x () {var t = e.match (lo); if (t) {var n, r, i = {tagNome: t [1], atrs: [], início: u}; for (E (t [0] .comprimento); ! (n = e.match (fo)) && (r = e.match (so));) E (r [0] .length), i.attrs.push (r); if (n) retorna i. unarySlash = n [1], E (n [0] .length), i.end = u, i}} função C (e) {var n = e.tagName, u = e.unarySlash; o && ("p" === r && ao (n) && A (r), s (n) && r == = n && A (n)); para (var c = a (n) || !! u, l = e.attrs.length, f = new Array (l), p = 0; p <l; p ++) {var d = e.attrs [p], h = d [3] || d [4] || d [5] || "", v = "a" === n && "href" === d [1 ]? t.shouldDecodeNewlinesForHref: t.shouldDecodeNewlines; f [p] = {nome: d [1], valor: xo (h, v)}} c || (i.push ({tag: n, lowerCasedTag: n. toLowerCase (), attrs: f}), r = n), t.start && t.start (n, f, c, e.start, e.end)} função A (e, n, o) {var a, s ; if (null == n && (n = u), null == o && (o = u), e) for (s = e.toLowerCase (), a = i.length-1; a> = 0 && i [a] .lowerCasedTag! == s; a -); else a = 0; if (a> = 0) {for (var c = i.length-1; c> = a; c -) t.end && t.end (i [c] .tag, n, o); i.length = a, r = a && i [a-1] .tag} else "br" === s? t.start && t.start (e, [], ! 0, n, o): "p "=== s && (t.start && t.start (e, [] ,! 1, n, o), t.end && t.end (e, n, o))} A ()} (e, {warn: Co, expectHTML: t.expectHTML, isUnaryTag: t.isUnaryTag, canBeLeftOpenTag: t.canBeLeftOpenTag, shouldDecodeNewlines: t.shouldDecodeNewlines, shouldDecodeNewlinesForHref: t.shouldDecodeNewlinesForHment: start.com, deve l = r && r.ns || Não (e); X && "svg" === l && (o = função (e) {par; função a (e) {return r? r (e, n): e.uma vez? ya (e, n): ga (e, n)}} (e.ifConditions.slice (), t, n, r )} função ba (e, t) {var n = "{", r = função (e, t) {var n = e.directives; se (! n) retornar; var r, i, o, a, s = "directivas: [", u =! 1; para (r = 0, i = n.length; r <i; r ++) {o = n [r], a =! 0; var c = t.directives [ o.name]; c && (a = !! c (e, o, t.warn)), a && (u =! 0, s + = '{name: "' + o.name + '", rawName: "' + o.rawName + '"' + (o.value?", valor :( "+ o.value +"), expressão: "+ JSON.stringify (o.value):" ") + (o.arg? ', arg : "'+ o.arg +'" ': "") + (o.modifiers? ", modificadores:" + JSON.stringify (o.modifiers): "") + "},")} if (u) return s.slice (0, -1) + "]"} (e, t); r && (n + = r + ","), e.key && (n + = "chave:" + e.key + ","), e .ref && (n + = "ref:"+ e.ref + ","), e.refInFor && (n + = "refInFor: true,"), e.pre && (n + = "pre: true,"), e.component && (n + = 'tag: "' + e .tag + '",'); para (var i = 0; i <t.dataGenFns.length; i ++) n + = t.dataGenFns [i] (e); if (e.attrs && (n + =" attrs: {" + Ca (e.props) + "},"), e.props && (n + = "domProps: {" + Ca (e.props) + "},"), e.events && (n + = la (e.events) ,! 1) + ","), e.nativeEvents && (n + = la (e.nativeEvents,! 0) + ","), e.slotTarget &&! E.slotScope && (n + = "slot:" + e.slotTarget + " , "), e.scopedSlots && (n + = function (e, t) {return" scopedSlots: _u (["+ Object.keys (e) .map (function (n) {return wa (n, e [n], t)}). join (",") + "])"} (e.scopedSlots, t) + ","), e.modelo && (n + = "modelo: {valor:" + e.modelo.value + ", callback:" + e.model.callback + ", expression:" + e.model.expression + "},"), e.inlineTemplate) {var o = function (e, t) {var n = e.children [0]; 0; if (1 === n.type) {var r = va (n, t.options); return "inlineTemplate: {render: function () {" + r.render + "}, staticRenderFns: ["+ r.staticRenderFns.map (function (e) {return" function () {"+ e +"} "}). join (", ") +"]} "}} (e, t); o && ( n + = o + ",")} return n = n.replace (/, $ /, "") + "}", e.wrapData && (n = e.wrapData (n)), e.wrapListeners && (n = e. wrapListeners (n)), n} function wa (e, t, n) {return t.for &&! t.forProcessed? function (e, t, n) {var r = t.for, i = t.alias, o = t.iterator1? "," + t.iterator1: "", a = t.iterator2? "," + t.iterator2: ""; return t.forProcessed =! 0, "_ l ((" + r + ") ,function ("+ i + o + a +") {return "+ wa (e, t, n) +"}) "} (e, t, n):" {tecla: "+ e +", fn: "+ ("function (" + String (t.slotScope) + ") {return" + ("template" === t.tag? t.if? "(" + t.if + ")?" + (Ta (t , n) || "undefined") + ": undefined": Ta (t, n) || "undefined": ga (t, n)) + "}") + "}"} função Ta (e, t , n, r, i) {var o = e.children; if (o.length) {var a = o [0]; if (1 === o.length && a.for && "modelo"! == a.tag && "slot"! == a.tag) {var s = n? t.maybeComponent (a)? ", 1": ", 0": ""; retornar "" + (r || ga) (a, t ) + s} var u = n? função (e, t) {para (var n = 0, r = 0; r <e.length; r ++) {var i = e [r]; if (1 === i.type) {if (Ea (i) || i.ifCondições && i.ifConditions.some (function (e) {return Ea (e.block)})) {n = 2; break} (t (i) || i.ifCondições && i.ifConditions.some (function (e) {return t (e.block)})) && (n = 1)}} return n} (o, t.maybeComponent): 0, c = i || xa; return "[ "+ o.map (function (e) {return c (e, t)}). join (", ") +"] "+ (u?", "+ u:" ")}} função Ea (e ) {return void 0! == e.for || "template" === e.tag || "slot" === e.tag} função xa (e, t) {return 1 === e.type ? ga (e, t): 3 === e.type && e.isComment? (r = e, "_ e (" + JSON.stringify (r.text) + ")"): "_ v (" + (2 = == (n = e) .type? n.expression: Aa (JSON.stringify (n.text))) + ")"; var n, r} função Ca (e) {for (var t = "", n = 0; n <e.length; n ++) {var r = e [n]; t + = '"' + r.name + '":' + Aa (r.value) + ","} return t.slice (0, -1)} função Aa (e) {retornar e.replace (/ \ u2028 / g, "\\ u2028"). Substituir (/ \ u2029 / g, "\\ u2029")} novo RegExp (" \\ b "+" fazer, se, para,let, new, try, var, case, else, with, await, break, catch, class, const, super, throw, while, yield, delete, export, import, return, switch, default, extends, finalmente, continue, depurador, função, argumentos ".split (", "). join (" \\ b | \\ b ") +" \\ b "), novo RegExp (" \\ b "+" delete, typeof, void " .split (","). join ("\\ s * \\ ([^ \\)] * \\) | \\ b") + "\\ s * \\ ([^ \\)] * \\) "); função Sa (e, t) {try {return new Function (e)} catch (n) {return t.push ({err: n, code: e}), k}} função Oa ( e) {var t = Object.create (null); função de retorno (n, r, i) {(r = D ({}, r)). warn; delete r.warn; var o = r.delimiters? String (r.delimitadores) + n: n; se (t [o]) retornar t [o]; var a = e (n, r); var s = {}, u = []; retornar s.render = Sa (a.render, u), s.staticRenderFns = a.staticRenderFns.map (function (e) {return Sa (e, u)}), t [o] = s}} var Da, Ia, ka = (Da = função (e, t) {var n = Bo (e.trim (), t) ;! 1! == t.optimize &&ra (n, t); var r = va (n, t); return {ast: n, render: r.render, staticRenderFns: r.staticRenderFns}}, function (e) {function t (t, n) { var r = Object.create (e), i = [], o = []; if (r.warn = function (e, t) {(t? o: i) .push (e)}, n) para (var a em n.modules && (r.modules = (e.modules || []). concat (n.modules)), n.directives && (r.directives = D (Object.create (e.directives || null ), n.directives)), n) "modules"! == a && "directives"! == a && (r [a] = n [a]); var s = Da (t, r); return s.errors = i, s.tips = o, s} return {compilar: t, compileToFunctions: Oa (t)}}) (ta), Na = (ka.compile, ka.compileToFunctions); função La (e) {return ( Ia = Ia || document.createElement ("div")). InnerHTML = e? '<a href="\n"/>': '<div a = "\ n" />', Ia.innerHTML.indexOf ("& # 10;")> 0} var ja = !! V && La (! 1), Pa = !! V && La (! 0), Ra = w (função (e) {var t = qn (e);return t && t.innerHTML}), $ a = hn.prototype. $ mount; hn.prototype. $ mount = function (e, t) {if ((e = e && qn (e)) === document.body || e === document.documentElement) retornar isso; var n = isso. $ options; if (! n.render) {var r = n.template; if (r) if ("string" == typeof r) "#" === r.charAt (0) && (r = Ra (r)); else {if (! r.nodeType) retorna isso; r = r.innerHTML} else e && (r = function (e) {if (e .outerHTML) return e.outerHTML; var t = document.createElement ("div"); return t.appendChild (e.cloneNode (! 0)), t.innerHTML} (e)); if (r) {0; var i = Na (r, {shouldDecodeNewlines: ja, shouldDecodeNewlinesForHref: Pa, delimiters: n.delimiters, comments: n.comments}, this), o = i.render, a = i.staticRenderFns; n.render = o, n.staticRenderFns = a}} return $ a.call (this, e, t)}, hn.compile = Na, e.exports = hn}). call (this, n (1), n ​​(37) .setImmediate )}, função (e, t, n) {(função (e) {var r = void 0! == e &&e || "indefinido"! = typeof self && self || window, i = Function.prototype.apply; function o (e, t) {this._id = e, this._clearFn = t} t.setTimeout = function () { retornar novo o (i.call (setTimeout, r, argumentos), clearTimeout)}, t.setInterval = função () {retornar novo o (i.call (setInterval, r, argumentos), clearInterval)}, t.clearTimeout = t.clearInterval = function (e) {e && e.close ()}, o.prototype.unref = o.prototype.ref = function () {}, o.prototype.close = function () {this._clearFn.call ( r, this._id)}, t.enroll = function (e, t) {clearTimeout (e._idleTimeoutId), e._idleTimeout = t}, t.unenroll = function (e) {clearTimeout (e._idleTimeoutId), e ._idleTimeout = -1}, t._unrefActive = t.active = function (e) {clearTimeout (e._idleTimeoutId); var t = e._idleTimeout; t> = 0 && (e._idleTimeoutId = setTimeout (function () {e ._onTimeout && e._onTimeout ()}, t))}, n (38), t.setImmediate = "indefinido"!= typeof self && self.setImmediate || void 0! == e && e.setImmediate || this && this.setImmediate, t.clearImmediate = "undefined"! = typeof self && self.clearImmediate || void 0! == e && e.clearImmediate || this && this.clearImmediate || this && this.clearImmediate} ) .call (this, n (1))}, function (e, t, n) {(function (e, t) {! function (e, n) {"use strict"; if (! e.setImmediate) {var r, i, o, a, s, u = 1, c = {}, l =! 1, f = e.document, p = Object.getPrototypeOf && Object.getPrototypeOf (e); p = p && p.setTimeout? p : e, "[processo de objeto]" === {}. toString.call (e.processo)? r = função (e) {t.nextTick (função () {h (e)})} :! função ( ) {if (e.postMessage &&! e.importScripts) {var t =! 0, n = e.onmessage; return e.onmessage = function () {t =! 1}, e.postMessage ("", "*" ), e.onmessage = n, t}} ()? e.MessageChannel? ((o = novo MessageChannel) .port1.onmessage = function (e) {h (e.data)},r = function (e) {o.port2.postMessage (e)}): f && "onreadystatechange" em f.createElement ("script")? (i = f.documentElement, r = function (e) {var t = f .createElement ("script"); t.onreadystatechange = function () {h (e), t.onreadystatechange = null, i.removeChild (t), t = null}, i.appendChild (t)}): r = function (e) {setTimeout (h, 0, e)} :( a = "setImmediate $" + Math.random () + "$", s = function (t) {t.source === e && "string" == typeof t.data && 0 === t.data.indexOf (a) && h (+ t.data.slice (a.length))}, e.addEventListener? e.addEventListener ("mensagem", s,! 1) : e.attachEvent ("onmessage", s), r = function (t) {e.postMessage (a + t, "*")}), p.setImmediate = function (e) {"function"! = typeof e && (e = nova Função ("" + e)); para (var t = novo Array (argumentos.Comprimento-1), n ​​= 0; n <t.comprimento;n ++) t [n] = argumentos [n + 1]; var i = {callback: e, args: t}; return c [u] = i, r (u), u ++}, função p.clearImmediate = d} d (e) {deletar c [e]} função h (e) {if (l) setTimeout (h, 0, e); else {var t = c [e]; if (t) {l =! 0; tente {! função (e) {var t = e.callback, r = e.args; switch (r.length) {case 0: t (); break; case 1: t (r [0]); break; caso 2: t (r [0], r [1]); quebra; caso 3: t (r [0], r [1], r [2]); quebra; padrão: t.aplicar (n, r )}} (t)} finalmente {d (e), l =! 1}}}}} ("undefined" == typeof self? void 0 === e? this: e: self)}). call ( este, n (1), n ​​(6))}, função (e, t, n) {"usar estrito"; nr (t); var r = função (e, t, n, r, i, o, a, s) {var u, c = "função" == typeof e? e.options: e; if (t && (c.render = t, c.staticRenderFns = n, c._compiled =! 0), r && ( c.functional =! 0), o && (c._scopeId = "data-v -" + o), a? (u = function (e) {(e = e || this. $ vnode && this. $ vnode.ssrContext | | this.parent && this.parent. $ vnode && this.pai. $ vnode.ssrContext) || "undefined" == typeof __VUE_SSR_CONTEXT__ || (e = __ VUE_SSR_CONTEXT __), i && i.call (this, e), e && e._registeredComponents & = e._registeredComponents.add} (a) ): i && (u = s? function () {i.call (this, this. $ root. $ options.shadowRoot)}: i), u) if (c.functional) {c._injectStyles = u; var l = c.render; c.render = function (e, t) {return u.call (t), l (e, t)}} else {var f = c.beforeCreate; c.beforeCreate = f? []. concat (f, u): [u]} retornar {exportações: e, opções: c}} ({montado: função () {console.log ("Componente montado.")}}, função () {este. $ createElement; this._self._c; return this._m (0)}, [function () {var e = this. $ createElement, t = this._self._c || e; return t ("div", {staticClass : "container"}, [t ("div", {staticClass: "row justify-content-center"}, [t ("div", {staticClass: "col-md-8"}, [t ("div", {staticClass: "card"}, [t ("div", {staticClass: "card-header"}, [this._v ("Exemplo de componente")]), this._v (""), t ("div", {staticClass: "card-body"}, [this._v ("\ n Sou um exemplo de componente. \ n")])])])])]) }] ,! 1, nulo, nulo, nulo); r.options .__ arquivo = "ExampleComponent.vue"; t.default = r.exports}, função (e, t) {}]);exportações}, função (e, t) {}]);exportações}, função (e, t) {}]);